!function(e){var F={};function n(B){if(F[B])return F[B].exports;var Q=F[B]={i:B,l:!1,exports:{}};return e[B].call(Q.exports,Q,Q.exports,n),Q.l=!0,Q.exports}n.m=e,n.c=F,n.d=function(B,Q,e){n.o(B,Q)||Object.defineProperty(B,Q,{enumerable:!0,get:e})},n.r=function(B){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(B,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(B,"__esModule",{value:!0})},n.t=function(Q,B){if(1&B&&(Q=n(Q)),8&B)return Q;if(4&B&&"object"==typeof Q&&Q&&Q.__esModule)return Q;var e=Object.create(null);if(n.r(e),Object.defineProperty(e,"default",{enumerable:!0,value:Q}),2&B&&"string"!=typeof Q)for(var F in Q)n.d(e,F,function(B){return Q[B]}.bind(null,F));return e},n.n=function(B){var Q=B&&B.__esModule?function(){return B.default}:function(){return B};return n.d(Q,"a",Q),Q},n.o=function(B,Q){return Object.prototype.hasOwnProperty.call(B,Q)},n.p="/js/",n(n.s=7)}([,,,,,,,function(module,exports,__webpack_require__){"use strict";eval("\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\n__webpack_require__(8);\n\nvar _popper = __webpack_require__(9);\n\nvar _popper2 = _interopRequireDefault(_popper);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Shiptimize = function () {\n  function Shiptimize() {\n    _classCallCheck(this, Shiptimize);\n\n    console.log(\"I'm alive!\");\n    this.boostrap();\n  }\n\n  /** \n   *  \n   */\n\n\n  _createClass(Shiptimize, [{\n    key: 'boostrap',\n    value: function boostrap() {\n      var _this = this;\n\n      if (jQuery(\".shiptimize-tooltip-message\").size() == 0) {\n        setTimeout(function () {\n          _this.boostrap();\n        }, 500);\n        return;\n      }\n\n      console.log(jQuery(\".shiptimize-tooltip-message\").size());\n\n      this.tooltips();\n      this.loadAnalytics();\n    }\n  }, {\n    key: 'tooltips',\n    value: function tooltips() {\n      var toltip = jQuery(\".shiptimize-tooltip-message\");\n\n      if (toltip.size() == 0) {\n        return;\n      }\n\n      var me = this;\n      toltip.each(function (idx, elem) {\n        me.attachPopper(elem, container);\n      });\n    }\n  }, {\n    key: 'attachPopper',\n    value: function attachPopper(toltip, container) {\n      var eToltip = jQuery(toltip);\n      var toltipReference = eToltip.siblings(\".shiptimize-tooltip-reference\");\n      var arrow = eToltip.children('.shiptimize-tooltip-message__arrow').get(0);\n\n      var popper = new _popper2.default(toltipReference.get(0), toltip, {\n        placement: 'left',\n        modifiers: {\n          flip: {\n            behavior: ['top', 'left', 'bottom']\n          },\n          preventOverflow: {\n            boundariesElement: container\n          },\n          offset: {\n            enabled: true,\n            offset: '10,10'\n          },\n          arrow: {\n            enabled: true,\n            element: arrow\n          }\n        }\n      });\n      setTimeout(function () {\n        popper.update();\n      }, 200);\n    }\n  }, {\n    key: 'exportSuccess',\n    value: function exportSuccess(appLink) {\n      this.platform.exportSuccess(appLink);\n    }\n\n    /** \n     * @param string category \n     * @param string action \n     * @param string label \n     */\n\n  }, {\n    key: 'sendAnalyticsEvent',\n    value: function sendAnalyticsEvent(category, action, label) {\n      ga('shiptimize.send', 'event', category, action, label, { transport: 'beacon' });\n    }\n  }, {\n    key: 'loadAnalytics',\n    value: function loadAnalytics() {\n      if (typeof ga == 'undefined') {\n        (function (i, s, o, g, r, a, m) {\n          i['GoogleAnalyticsObject'] = r;\n          i[r] = i[r] || function () {\n            (i[r].q = i[r].q || []).push(arguments);\n          }, i[r].l = 1 * new Date();\n          a = s.createElement(o), m = s.getElementsByTagName(o)[0];\n          a.async = 1;\n          a.src = g;\n          m.parentNode.insertBefore(a, m);\n        })(window, document, 'script', 'https://www.google-analytics.com/analytics.js', 'ga');\n        console.log(\"inserting analytics \");\n      }\n      ga('create', 'UA-101485643-1', 'auto', 'shiptimize');\n      ga('shiptimize.set', 'anonymizeIp', true);\n      console.log(\"creating tracker\");\n    }\n\n    /**\n     * Request the label status every 1s \n     */\n\n  }, {\n    key: 'monitorLabelStatus',\n    value: function monitorLabelStatus(callbackUrl) {\n      var _this2 = this;\n\n      var data = {\n        'action': 'shiptimize_label_status',\n        'callbackUrl': callbackUrl\n      };\n\n      console.log(\"Monitor label status with data \", data);\n\n      jQuery.post(labelmonitorurl, data, function (data) {\n        console.log(data);\n\n        if (typeof data.response != 'undefined') {\n\n          // Check for falta errors \n          if (data.httpCode == '200') {\n            _this2.loaderMsg(shiptimize_label_request + ' ' + data.response.Finished + '%');\n          } else {\n            _this2.loaderMsg(\"Fatal API error \" + data.httpCode);\n            setTimeout(function () {\n              _this2.closeLoader();\n            }, 5000);\n            return;\n          }\n\n          // Print API errors\n          if (data.response.Error.Id > 0) {\n            _this2.loaderMsg(data.response.Error.Info);\n          }\n\n          if (data.response.Error.Id == 902) {\n            //No process running \n            setTimeout(function () {\n              _this2.closeLoader();\n            }, 2000);\n          }\n\n          if (data.response.Finished == 100) {\n            if (data.response.LabelFile.length > 0) {\n              var labelinfo = shiptimize_label_click.replace('%', '<a href=\"' + data.response.LabelFile + '\" target=\\'_blank\\'>' + shiptimize_label_label + '</a>');\n              jQuery(\"#shiptimize_label_status\").html('<div class=\"notice notice-info is-dismissible updated\">' + labelinfo + '</div>');\n              window.open(data.response.LabelFile, '_blank');\n              _this2.closeLoader();\n\n              /** \n               * Make sure the info is updated without the need to reload the page \n               */\n              for (var x = 0; x < data.response.ClientReferenceCodeList.length; ++x) {\n                var labelresult = data.response.ClientReferenceCodeList[x];\n                if (labelresult.Error.Id == 0) {\n                  jQuery(\"#shiptimize-label\" + labelresult.ReferenceCode).addClass('shiptimize-icon-print-printed');\n                } else {\n                  jQuery(\"#shiptimize-label\" + labelresult.ReferenceCode).addClass(\"shiptimize-icon-print-error\");\n                }\n\n                jQuery(\"#shiptimize-tooltip\" + labelresult.ReferenceCode).html(labelresult.message);\n              }\n            } else {\n              var msg = '';\n              for (var x = 0; x < data.response.ClientReferenceCodeList.length; ++x) {\n                var _labelresult = data.response.ClientReferenceCodeList[0];\n                if (_labelresult.Error.Id > 0) {\n                  msg += \"<div class='shiptimize-label-error error'>\" + _labelresult.Error.Info + \"</div>\";\n                }\n                jQuery(\"#shiptimize-label\" + _labelresult.ReferenceCode).addClass(\"shiptimize-icon-print-error\");\n                jQuery(\"#shiptimize-tooltip\" + _labelresult.ReferenceCode).html(_labelresult.message);\n              }\n\n              _this2.loaderMsg(msg);\n              setTimeout(function () {\n                _this2.closeLoader();\n              }, 5000);\n            }\n          }\n\n          if (data.response.Finished < 100) {\n            setTimeout(function () {\n              _this2.monitorLabelStatus(callbackUrl);\n            }, 2000);\n          }\n        }\n      }, \"json\");\n    }\n  }, {\n    key: 'loaderMsg',\n    value: function loaderMsg(message) {\n      jQuery(\".shiptimize-loader-message\").html(message);\n    }\n  }, {\n    key: 'openLoader',\n    value: function openLoader(message) {\n      jQuery('body').append('<div class=\"shiptimize-loader-wrapper\"><div class=\"shiptimize-loader\"><div></div><div></div><div></div></div><div class=\"shiptimize-loader-message\">' + message + '</div></div>');\n    }\n  }, {\n    key: 'closeLoader',\n    value: function closeLoader() {\n      jQuery(\".shiptimize-loader-wrapper\").remove();\n    }\n  }]);\n\n  return Shiptimize;\n}();\n\njQuery(function () {\n  window.shiptimize = new Shiptimize();\n  window.Popper = _popper2.default;\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zaGlwdGltaXplLWFkbWluLmpzPzM4YTIiXSwibmFtZXMiOlsiU2hpcHRpbWl6ZSIsImNvbnNvbGUiLCJsb2ciLCJib29zdHJhcCIsImpRdWVyeSIsInNpemUiLCJzZXRUaW1lb3V0IiwidG9vbHRpcHMiLCJsb2FkQW5hbHl0aWNzIiwidG9sdGlwIiwibWUiLCJlYWNoIiwiaWR4IiwiZWxlbSIsImF0dGFjaFBvcHBlciIsImNvbnRhaW5lciIsImVUb2x0aXAiLCJ0b2x0aXBSZWZlcmVuY2UiLCJzaWJsaW5ncyIsImFycm93IiwiY2hpbGRyZW4iLCJnZXQiLCJwb3BwZXIiLCJQb3BwZXIiLCJwbGFjZW1lbnQiLCJtb2RpZmllcnMiLCJmbGlwIiwiYmVoYXZpb3IiLCJwcmV2ZW50T3ZlcmZsb3ciLCJib3VuZGFyaWVzRWxlbWVudCIsIm9mZnNldCIsImVuYWJsZWQiLCJlbGVtZW50IiwidXBkYXRlIiwiYXBwTGluayIsInBsYXRmb3JtIiwiZXhwb3J0U3VjY2VzcyIsImNhdGVnb3J5IiwiYWN0aW9uIiwibGFiZWwiLCJnYSIsInRyYW5zcG9ydCIsImkiLCJzIiwibyIsImciLCJyIiwiYSIsIm0iLCJxIiwicHVzaCIsImFyZ3VtZW50cyIsImwiLCJEYXRlIiwiY3JlYXRlRWxlbWVudCIsImdldEVsZW1lbnRzQnlUYWdOYW1lIiwiYXN5bmMiLCJzcmMiLCJwYXJlbnROb2RlIiwiaW5zZXJ0QmVmb3JlIiwid2luZG93IiwiZG9jdW1lbnQiLCJjYWxsYmFja1VybCIsImRhdGEiLCJwb3N0IiwibGFiZWxtb25pdG9ydXJsIiwicmVzcG9uc2UiLCJodHRwQ29kZSIsImxvYWRlck1zZyIsInNoaXB0aW1pemVfbGFiZWxfcmVxdWVzdCIsIkZpbmlzaGVkIiwiY2xvc2VMb2FkZXIiLCJFcnJvciIsIklkIiwiSW5mbyIsIkxhYmVsRmlsZSIsImxlbmd0aCIsImxhYmVsaW5mbyIsInNoaXB0aW1pemVfbGFiZWxfY2xpY2siLCJyZXBsYWNlIiwic2hpcHRpbWl6ZV9sYWJlbF9sYWJlbCIsImh0bWwiLCJvcGVuIiwieCIsIkNsaWVudFJlZmVyZW5jZUNvZGVMaXN0IiwibGFiZWxyZXN1bHQiLCJSZWZlcmVuY2VDb2RlIiwiYWRkQ2xhc3MiLCJtZXNzYWdlIiwibXNnIiwibW9uaXRvckxhYmVsU3RhdHVzIiwiYXBwZW5kIiwicmVtb3ZlIiwic2hpcHRpbWl6ZSJdLCJtYXBwaW5ncyI6Ijs7OztBQUFBOztBQUNBOzs7Ozs7OztJQUVNQSxVO0FBRUosd0JBQWE7QUFBQTs7QUFDWEMsWUFBUUMsR0FBUixDQUFZLFlBQVo7QUFDQSxTQUFLQyxRQUFMO0FBQ0Q7O0FBRUQ7Ozs7Ozs7K0JBR1U7QUFBQTs7QUFDUixVQUFJQyxPQUFPLDZCQUFQLEVBQXNDQyxJQUF0QyxNQUFpRCxDQUFyRCxFQUF5RDtBQUNyREMsbUJBQVcsWUFBSTtBQUFFLGdCQUFLSCxRQUFMO0FBQWtCLFNBQW5DLEVBQXFDLEdBQXJDO0FBQ0E7QUFDSDs7QUFFREYsY0FBUUMsR0FBUixDQUFZRSxPQUFPLDZCQUFQLEVBQXNDQyxJQUF0QyxFQUFaOztBQUVBLFdBQUtFLFFBQUw7QUFDQSxXQUFLQyxhQUFMO0FBQ0Q7OzsrQkFFVTtBQUNULFVBQUlDLFNBQVNMLE9BQU8sNkJBQVAsQ0FBYjs7QUFFQSxVQUFJSyxPQUFPSixJQUFQLE1BQWlCLENBQXJCLEVBQXdCO0FBQ3RCO0FBQ0Q7O0FBRUQsVUFBSUssS0FBSyxJQUFUO0FBQ0FELGFBQU9FLElBQVAsQ0FBYSxVQUFXQyxHQUFYLEVBQWdCQyxJQUFoQixFQUF1QjtBQUNsQ0gsV0FBR0ksWUFBSCxDQUFnQkQsSUFBaEIsRUFBcUJFLFNBQXJCO0FBQ0QsT0FGRDtBQUdEOzs7aUNBRVlOLE0sRUFBUU0sUyxFQUFVO0FBQzdCLFVBQUlDLFVBQVVaLE9BQU9LLE1BQVAsQ0FBZDtBQUNBLFVBQUlRLGtCQUFrQkQsUUFBUUUsUUFBUixDQUFpQiwrQkFBakIsQ0FBdEI7QUFDQSxVQUFJQyxRQUFRSCxRQUFRSSxRQUFSLENBQWlCLG9DQUFqQixFQUF1REMs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QUtHLFFBQUwsQ0FBY0ksUUFBZCxHQUF5QixHQUE1QixFQUFpQztBQUMvQmhFLHVCQUFZLFlBQU07QUFBRSxxQkFBS29GLGtCQUFMLENBQXdCNUIsV0FBeEI7QUFBdUMsYUFBM0QsRUFBNkQsSUFBN0Q7QUFDRDtBQUNGO0FBRUYsT0FyRUQsRUFxRUcsTUFyRUg7QUFzRUQ7Ozs4QkFFUzBCLE8sRUFBUztBQUNqQnBGLGFBQU8sNEJBQVAsRUFBcUM2RSxJQUFyQyxDQUEwQ08sT0FBMUM7QUFDRDs7OytCQUVVQSxPLEVBQVM7QUFDbEJwRixhQUFPLE1BQVAsRUFBZXVGLE1BQWYsQ0FBc0IseUpBQXlKSCxPQUF6SixHQUFvSyxjQUExTDtBQUNEOzs7a0NBRVk7QUFDWHBGLGFBQU8sNEJBQVAsRUFBcUN3RixNQUFyQztBQUNEOzs7Ozs7QUFHSHhGLE9BQU8sWUFBWTtBQUNqQndELFNBQU9pQyxVQUFQLEdBQW9CLElBQUk3RixVQUFKLEVBQXBCO0FBQ0E0RCxTQUFPckMsTUFBUCxHQUFnQkEsZ0JBQWhCO0FBQ0QsQ0FIRCIsImZpbGUiOiI3LmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICcuL3Njc3Mvc2hpcHRpbWl6ZS1hZG1pbi5zY3NzJztcbmltcG9ydCBQb3BwZXIgZnJvbSAncG9wcGVyLmpzJzsgIFxuXG5jbGFzcyBTaGlwdGltaXplIHtcblxuICBjb25zdHJ1Y3Rvcigpe1xuICAgIGNvbnNvbGUubG9nKFwiSSdtIGFsaXZlIVwiKTsgXG4gICAgdGhpcy5ib29zdHJhcCgpOyBcbiAgfVxuXG4gIC8qKiBcbiAgICogIFxuICAgKi8gXG4gIGJvb3N0cmFwKCl7XG4gICAgaWYgKGpRdWVyeShcIi5zaGlwdGltaXplLXRvb2x0aXAtbWVzc2FnZVwiKS5zaXplKCkgID09IDAgKSB7XG4gICAgICAgIHNldFRpbWVvdXQoKCk9PnsgdGhpcy5ib29zdHJhcCgpOyB9LCA1MDApOyAgXG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zb2xlLmxvZyhqUXVlcnkoXCIuc2hpcHRpbWl6ZS10b29sdGlwLW1lc3NhZ2VcIikuc2l6ZSgpKTtcblxuICAgIHRoaXMudG9vbHRpcHMoKTsgICBcbiAgICB0aGlzLmxvYWRBbmFseXRpY3MoKTsgICBcbiAgfVxuXG4gIHRvb2x0aXBzKCApe1xuICAgIGxldCB0b2x0aXAgPSBqUXVlcnkoXCIuc2hpcHRpbWl6ZS10b29sdGlwLW1lc3NhZ2VcIik7IFxuXG4gICAgaWYoIHRvbHRpcC5zaXplKCkgPT0gMCApe1xuICAgICAgcmV0dXJuOyBcbiAgICB9XG5cbiAgICBsZXQgbWUgPSB0aGlzOyBcbiAgICB0b2x0aXAuZWFjaCggZnVuY3Rpb24gKCBpZHgsIGVsZW0gKSB7XG4gICAgICBtZS5hdHRhY2hQb3BwZXIoZWxlbSxjb250YWluZXIpOyAgXG4gICAgfSk7ICAgICAgXG4gIH1cblxuICBhdHRhY2hQb3BwZXIodG9sdGlwLCBjb250YWluZXIpeyAgXG4gICAgbGV0IGVUb2x0aXAgPSBqUXVlcnkodG9sdGlwKTsgXG4gICAgbGV0IHRvbHRpcFJlZmVyZW5jZSA9IGVUb2x0aXAuc2libGluZ3MoXCIuc2hpcHRpbWl6ZS10b29sdGlwLXJlZmVyZW5jZVwiKTtcbiAgICBsZXQgYXJyb3cgPSBlVG9sdGlwLmNoaWxkcmVuKCcuc2hpcHRpbWl6ZS10b29sdGlwLW1lc3NhZ2VfX2Fycm93JykuZ2V0KDApOyBcblxuICAgIHZhciBwb3BwZXIgPSBuZXcgUG9wcGVyKHRvbHRpcFJlZmVyZW5jZS5nZXQoMCksIHRvbHRpcCwge1xuICAgICAgcGxhY2VtZW50OiAnbGVmdCcsXG4gICAgICBtb2RpZmllcnM6IHtcbiAgICAgICAgICBmbGlwOiB7XG4gICAgICAgICAgICAgIGJlaGF2aW9yOiBbJ3RvcCcsJ2xlZnQnLCAnYm90dG9tJ11cbiAgICAgICAgICB9LFxuICAgICAgICAgIHByZXZlbnRPdmVyZmxvdzoge1xuICAgICAgICAgICAgICBib3VuZGFyaWVzRWxlbWVudDogY29udGFpbmVyLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgb2Zmc2V0OiB7IFxuICAgICAgICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICAgICAgICBvZmZzZXQ6ICcxMCwxMCdcbiAgICAgICAgICB9LFxuICAgICAgICAgIGFycm93OiB7XG4gICAgICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICAgICAgZWxlbWVudDogYXJyb3dcbiAgICAgICAgICB9XG4gICAgICB9LCBcbiAgICB9KTsgIFxuICAgIHNldFRpbWVvdXQgKCAoKSA9PiB7IHBvcHBlci51cGRhdGUoKTsgfSAsIDIwMCk7ICAgICBcbiAgfVxuXG4gIGV4cG9ydFN1Y2Nlc3MoYXBwTGluayl7XG4gICAgdGhpcy5wbGF0Zm9ybS5leHBvcnRTdWNjZXNzKGFwcExpbmspO1xuICB9XG5cbiAgLyoqIFxuICAgKiBAcGFyYW0gc3RyaW5nIGNhdGVnb3J5IFxuICAgKiBAcGFyYW0gc3RyaW5nIGFjdGlvbiBcbiAgICogQHBhcmFtIHN0cmluZyBsYWJlbCBcbiAgICovXG4gIHNlbmRBbmFseXRpY3NFdmVudChjYXRlZ29yeSwgYWN0aW9uLCBsYWJlbCkge1xuICAgICAgZ2EoJ3NoaXB0aW1pemUuc2VuZCcsICdldmVudCcsIGNhdGVnb3J5LCBhY3Rpb24sIGxhYmVsLCB7IHRyYW5zcG9ydDogJ2JlYWNvbicgfSk7XG4gIH1cblxuICBsb2FkQW5hbHl0aWNzKCkge1xuICAgICAgaWYgKHR5cGVvZihnYSkgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAoZnVuY3Rpb24oaSwgcywgbywgZywgciwgYSwgbSkge1xuICAgICAgICAgICAgICBpWydHb29nbGVBbmFseXRpY3NPYmplY3QnXSA9IHI7XG4gICAgICAgICAgICAgIGlbcl0gPSBpW3JdIHx8IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgKGlbcl0ucSA9IGlbcl0ucSB8fCBbXSkucHVzaChhcmd1bWVudHMpXG4gICAgICAgICAgICAgIH0sIGlbcl0ubCA9IDEgKiBuZXcgRGF0ZSgpO1xuICAgICAgICAgICAgICBhID0gcy5jcmVhdGVFbGVtZW50KG8pLFxuICAgICAgICAgICAgICAgICAgbSA9IHMuZ2V0RWxlbWVudHNCeVRhZ05hbWUobylbMF07XG4gICAgICAgICAgICAgIGEuYXN5bmMgPSAxO1xuICAgICAgICAgICAgICBhLnNyYyA9IGc7XG4gICAgICAgICAgICAgIG0ucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoYSwgbSlcbiAgICAgICAgICB9KSh3aW5kb3csIGRvY3VtZW50LCAnc2NyaXB0JywgJ2h0dHBzOi8vd3d3Lmdvb2dsZS1hbmFseXRpY3MuY29tL2FuYWx5dGljcy5qcycsICdnYScpO1xuICAgICAgICAgIGNvbnNvbGUubG9nKFwiaW5zZXJ0aW5nIGFuYWx5dGljcyBcIik7XG4gICAgICB9IFxuICAgICAgZ2EoJ2NyZWF0ZScsICdVQS0xMDE0ODU2NDMtMScsICdhdXRvJywgJ3NoaXB0aW1pemUnKTtcbiAgICAgIGdhKCdzaGlwdGltaXplLnNldCcsICdhbm9ueW1pemVJcCcsIHRydWUpO1xuICAgICAgY29uc29sZS5sb2coXCJjcmVhdGluZyB0cmFja2VyXCIpO1xuICB9XG5cblxuICAvKipcbiAgICogUmVxdWVzdCB0aGUgbGFiZWwgc3RhdHVzIGV2ZXJ5IDFzIFxuICAgKi9cbiAgbW9uaXRvckxhYmVsU3RhdHVzKGNhbGxiYWNrVXJsKSB7XG4gICAgdmFyIGRhdGEgPSB7XG4gICAgICAnYWN0aW9uJzogJ3NoaXB0aW1pemVfbGFiZWxfc3RhdHVzJyxcbiAgICAgICdjYWxsYmFja1VybCc6IGNhbGxiYWNrVXJsXG4gICAgfTsgXG4gICAgXG4gICAgY29uc29sZS5sb2coXCJNb25pdG9yIGxhYmVsIHN0YXR1cyB3aXRoIGRhdGEgXCIgLCBkYXRhICk7IFxuXG4gICAgalF1ZXJ5LnBvc3QobGFiZWxtb25pdG9ydXJsLCBkYXRhLCAoZGF0YSkgPT4ge1xuICAgICAgY29uc29sZS5sb2coZGF0YSk7IFxuXG4gICAgICBpZih0eXBlb2YoZGF0YS5yZXNwb25zZSkhPSAndW5kZWZpbmVkJykge1xuXG4gICAgICAgIC8vIENoZWNrIGZvciBmYWx0YSBlcnJvcnMgXG4gICAgICAgIGlmKGRhdGEuaHR0cENvZGUgPT0gJzIwMCcpIHtcbiAgICAgICAgICB0aGlzLmxvYWRlck1zZyhzaGlwdGltaXplX2xhYmVsX3JlcXVlc3QgKyAnICcgKyBkYXRhLnJlc3BvbnNlLkZpbmlzaGVkICsgJyUnKTsgICAgICAgICBcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB0aGlzLmxvYWRlck1zZyhcIkZhdGFsIEFQSSBlcnJvciBcIiArIGRhdGEuaHR0cENvZGUpO1xuICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4geyB0aGlzLmNsb3NlTG9hZGVyKCk7IH0sIDUwMDApO1xuICAgICAgICAgIHJldHVybjsgXG4gICAgICAgIH1cblxuICAgICAgICAvLyBQcmludCBBUEkgZXJyb3JzXG4gICAgICAgIGlmIChkYXRhLnJlc3BvbnNlLkVycm9yLklkID4gMCkge1xuICAgICAgICAgIHRoaXMubG9hZGVyTXNnKGRhdGEucmVzcG9uc2UuRXJyb3IuSW5mbyk7IFxuICAgICAgICB9XG5cbiAgICAgICAgaWYoZGF0YS5yZXNwb25zZS5FcnJvci5JZCA9PSA5MDIpIHsgLy9ObyBwcm9jZXNzIHJ1bm5pbmcgXG4gICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgIHRoaXMuY2xvc2VMb2FkZXIoKVxuICAgICAgICAgIH0sIDIwMDApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoZGF0YS5yZXNwb25zZS5GaW5pc2hlZCA9PSAxMDAgKSB7XG4gICAgICAgICAgaWYgKCBkYXRhLnJlc3BvbnNlLkxhYmVsRmlsZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBsZXQgbGFiZWxpbmZvID0gc2hpcHRpbWl6ZV9sYWJlbF9jbGljay5yZXBsYWNlKCclJyxgPGEgaHJlZj1cIiR7ZGF0YS5yZXNwb25zZS5MYWJlbEZpbGV9XCIgdGFyZ2V0PSdfYmxhbmsnPiR7c2hpcHRpbWl6ZV9sYWJlbF9sYWJlbH08L2E+YCk7XG4gICAgICAgICAgICBqUXVlcnkoXCIjc2hpcHRpbWl6ZV9sYWJlbF9zdGF0dXNcIikuaHRtbChgPGRpdiBjbGFzcz1cIm5vdGljZSBub3RpY2UtaW5mbyBpcy1kaXNtaXNzaWJsZSB1cGRhdGVkXCI+JHtsYWJlbGluZm99PC9kaXY+YCk7XG4gICAgICAgICAgICB3aW5kb3cub3BlbihkYXRhLnJlc3BvbnNlLkxhYmVsRmlsZSwnX2JsYW5rJyk7IFxuICAgICAgICAgICAgdGhpcy5jbG9zZUxvYWRlcigpO1xuXG4gICAgICAgICAgICAvKiogXG4gICAgICAgICAgICAgKiBNYWtlIHN1cmUgdGhlIGluZm8gaXMgdXBkYXRlZCB3aXRob3V0IHRoZSBuZWVkIHRvIHJlbG9hZCB0aGUgcGFnZSBcbiAgICAgICAgICAgICAqLyBcbiAgICAgICAgICAgIGZvcih2YXIgeCA9MDsgeCA8IGRhdGEucmVzcG9uc2UuQ2xpZW50UmVmZXJlbmNlQ29kZUxpc3QubGVuZ3RoOyArK3gpIHtcbiAgICAgICAgICAgICAgdmFyIGxhYmVscmVzdWx0ID0gZGF0YS5yZXNwb25zZS5DbGllbnRSZWZlcmVuY2VDb2RlTGlzdFt4XTsgXG4gICAgICAgICAgICAgIGlmKGxhYmVscmVzdWx0LkVycm9yLklkID09IDApIHsgXG4gICAgICAgICAgICAgICAgalF1ZXJ5KFwiI3NoaXB0aW1pemUtbGFiZWxcIiArIGxhYmVscmVzdWx0LlJlZmVyZW5jZUNvZGUpLmFkZENsYXNzKCdzaGlwdGltaXplLWljb24tcHJpbnQtcHJpbnRlZCcpOyAgIFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGpRdWVyeShcIiNzaGlwdGltaXplLWxhYmVsXCIgKyBsYWJlbHJlc3VsdC5SZWZlcmVuY2VDb2RlKS5hZGRDbGFzcyhcInNoaXB0aW1pemUtaWNvbi1wcmludC1lcnJvclwiKTsgIFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICBqUXVlcnkoXCIjc2hpcHRpbWl6ZS10b29sdGlwXCIgKyBsYWJlbHJlc3VsdC5SZWZlcmVuY2VDb2RlKS5odG1sKGxhYmVscmVzdWx0Lm1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBtc2cgPSAnJzsgXG4gICAgICAgICAgICBmb3IgKCB2YXIgeD0wOyB4IDwgZGF0YS5yZXNwb25zZS5DbGllbnRSZWZlcmVuY2VDb2RlTGlzdC5sZW5ndGg7ICsreCApIHtcbiAgICAgICAgICAgICAgbGV0IGxhYmVscmVzdWx0ID0gZGF0YS5yZXNwb25zZS5DbGllbnRSZWZlcmVuY2VDb2RlTGlzdFswXTsgXG4gICAgICAgICAgICAgIGlmKGxhYmVscmVzdWx0LkVycm9yLklkID4gMCkge1xuICAgICAgICAgICAgICAgIG1zZyArPSBcIjxkaXYgY2xhc3M9J3NoaXB0aW1pemUtbGFiZWwtZXJyb3IgZXJyb3InPlwiICsgbGFiZWxyZXN1bHQuRXJyb3IuSW5mbyArIFwiPC9kaXY+XCI7IFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGpRdWVyeShcIiNzaGlwdGltaXplLWxhYmVsXCIgKyBsYWJlbHJlc3VsdC5SZWZlcmVuY2VDb2RlKS5hZGRDbGFzcyhcInNoaXB0aW1pemUtaWNvbi1wcmludC1lcnJvclwiKTsgIFxuICAgICAgICAgICAgICBqUXVlcnkoXCIjc2hpcHRpbWl6ZS10b29sdGlwXCIgKyBsYWJlbHJlc3VsdC5SZWZlcmVuY2VDb2RlKS5odG1sKGxhYmVscmVzdWx0Lm1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmxvYWRlck1zZyhtc2cpOyBcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4geyB0aGlzLmNsb3NlTG9hZGVyKCk7IH0sIDUwMDApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmKGRhdGEucmVzcG9uc2UuRmluaXNoZWQgPCAxMDApIHtcbiAgICAgICAgICBzZXRUaW1lb3V0KCAoKSA9PiB7IHRoaXMubW9uaXRvckxhYmVsU3RhdHVzKGNhbGxiYWNrVXJsKTsgfSwgMjAwMCk7IFxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICB9LCBcImpzb25cIik7XG4gIH1cblxuICBsb2FkZXJNc2cobWVzc2FnZSkge1xuICAgIGpRdWVyeShcIi5zaGlwdGltaXplLWxvYWRlci1tZXNzYWdlXCIpLmh0bWwobWVzc2FnZSk7IFxuICB9XG5cbiAgb3BlbkxvYWRlcihtZXNzYWdlKSB7XG4gICAgalF1ZXJ5KCdib2R5JykuYXBwZW5kKCc8ZGl2IGNsYXNzPVwic2hpcHRpbWl6ZS1sb2FkZXItd3JhcHBlclwiPjxkaXYgY2xhc3M9XCJzaGlwdGltaXplLWxvYWRlclwiPjxkaXY+PC9kaXY+PGRpdj48L2Rpdj48ZGl2PjwvZGl2PjwvZGl2PjxkaXYgY2xhc3M9XCJzaGlwdGltaXplLWxvYWRlci1tZXNzYWdlXCI+JyArIG1lc3NhZ2UgICsgJzwvZGl2PjwvZGl2PicpOyBcbiAgfVxuXG4gIGNsb3NlTG9hZGVyKCl7XG4gICAgalF1ZXJ5KFwiLnNoaXB0aW1pemUtbG9hZGVyLXdyYXBwZXJcIikucmVtb3ZlKCk7IFxuICB9XG59XG5cbmpRdWVyeShmdW5jdGlvbiAoKSB7XG4gIHdpbmRvdy5zaGlwdGltaXplID0gbmV3IFNoaXB0aW1pemUoKTtcbiAgd2luZG93LlBvcHBlciA9IFBvcHBlcjtcbn0pO1xuXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///7\n")},function(module,exports,__webpack_require__){eval("// extracted by mini-css-extract-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zY3NzL3NoaXB0aW1pemUtYWRtaW4uc2Nzcz82MGM5Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBIiwiZmlsZSI6IjguanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///8\n")},function(module,exports,__webpack_require__){"use strict";eval("/* WEBPACK VAR INJECTION */(function(global) {\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**!\n * @fileOverview Kickass library to create and place poppers near their reference elements.\n * @version 1.14.6\n * @license\n * Copyright (c) 2016 Federico Zivolo and contributors\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\nvar isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined';\n\nvar longerTimeoutBrowsers = ['Edge', 'Trident', 'Firefox'];\nvar timeoutDuration = 0;\nfor (var i = 0; i < longerTimeoutBrowsers.length; i += 1) {\n  if (isBrowser && navigator.userAgent.indexOf(longerTimeoutBrowsers[i]) >= 0) {\n    timeoutDuration = 1;\n    break;\n  }\n}\n\nfunction microtaskDebounce(fn) {\n  var called = false;\n  return function () {\n    if (called) {\n      return;\n    }\n    called = true;\n    window.Promise.resolve().then(function () {\n      called = false;\n      fn();\n    });\n  };\n}\n\nfunction taskDebounce(fn) {\n  var scheduled = false;\n  return function () {\n    if (!scheduled) {\n      scheduled = true;\n      setTimeout(function () {\n        scheduled = false;\n        fn();\n      }, timeoutDuration);\n    }\n  };\n}\n\nvar supportsMicroTasks = isBrowser && window.Promise;\n\n/**\n* Create a debounced version of a method, that's asynchronously deferred\n* but called in the minimum time possible.\n*\n* @method\n* @memberof Popper.Utils\n* @argument {Function} fn\n* @returns {Function}\n*/\nvar debounce = supportsMicroTasks ? microtaskDebounce : taskDebounce;\n\n/**\n * Check if the given variable is a function\n * @method\n * @memberof Popper.Utils\n * @argument {Any} functionToCheck - variable to check\n * @returns {Boolean} answer to: is a function?\n */\nfunction isFunction(functionToCheck) {\n  var getType = {};\n  return functionToCheck && getType.toString.call(functionToCheck) === '[object Function]';\n}\n\n/**\n * Get CSS computed property of the given element\n * @method\n * @memberof Popper.Utils\n * @argument {Eement} element\n * @argument {String} property\n */\nfunction getStyleComputedProperty(element, property) {\n  if (element.nodeType !== 1) {\n    return [];\n  }\n  // NOTE: 1 DOM access here\n  var window = element.ownerDocument.defaultView;\n  var css = window.getComputedStyle(element, null);\n  return property ? css[property] : css;\n}\n\n/**\n * Returns the parentNode or the host of the element\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @returns {Element} parent\n */\nfunction getParentNode(element) {\n  if (element.nodeName === 'HTML') {\n    return element;\n  }\n  return element.parentNode || element.host;\n}\n\n/**\n * Returns the scrolling parent of the given element\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @returns {Element} scroll parent\n */\nfunction getScrollParent(element) {\n  // Return body, `getScroll` will take care to get the correct `scrollTop` from it\n  if (!element) {\n    return document.body;\n  }\n\n  switch (element.nodeName) {\n    case 'HTML':\n    case 'BODY':\n      return element.ownerDocument.body;\n    case '#document':\n      return element.body;\n  }\n\n  // Firefox want us to check `-x` and `-y` variations as well\n\n  var _getStyleComputedProp = getStyleComputedProperty(element),\n      overflow = _getStyleComputedProp.overflow,\n      overflowX = _getStyleComputedProp.overflowX,\n      overflowY = _getStyleComputedProp.overflowY;\n\n  if (/(auto|scroll|overlay)/.test(overflow + overflowY + overflowX)) {\n    return element;\n  }\n\n  return getScrollParent(getParentNode(element));\n}\n\nvar isIE11 = isBrowser && !!(window.MSInputMethodContext && document.documentMode);\nvar isIE10 = isBrowser && /MSIE 10/.test(navigator.userAgent);\n\n/**\n * Determines if the browser is Internet Explorer\n * @method\n * @memberof Popper.Utils\n * @param {Number} version to check\n * @returns {Boolean} isIE\n */\nfunction isIE(version) {\n  if (version === 11) {\n    return isIE11;\n  }\n  if (version === 10) {\n    return isIE10;\n  }\n  return isIE11 || isIE10;\n}\n\n/**\n * Returns the offset parent of the given element\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @returns {Element} offset parent\n */\nfunction getOffsetParent(element) {\n  if (!element) {\n    return document.documentElement;\n  }\n\n  var noOffsetParent = isIE(10) ? document.body : null;\n\n  // NOTE: 1 DOM access here\n  var offsetParent = element.offsetParent || null;\n  // Skip hidden elements which don't have an offsetParent\n  while (offsetParent === noOffsetParent && element.nextElementSibling) {\n    offsetParent = (element = element.nextElementSibling).offsetParent;\n  }\n\n  var nodeName = offsetParent && offsetParent.nodeName;\n\n  if (!nodeName || nodeName === 'BODY' || nodeName === 'HTML') {\n    return element ? element.ownerDocument.documentElement : document.documentElement;\n  }\n\n  // .offsetParent will return the closest TH, TD or TABLE in case\n  // no offsetParent is present, I hate this job...\n  if (['TH', 'TD', 'TABLE'].indexOf(offsetParent.nodeName) !== -1 && getStyleComputedProperty(offsetParent, 'position') === 'static') {\n    return getOffsetParent(offsetParent);\n  }\n\n  return offsetParent;\n}\n\nfunction isOffsetContainer(element) {\n  var nodeName = element.nodeName;\n\n  if (nodeName === 'BODY') {\n    return false;\n  }\n  return nodeName === 'HTML' || getOffsetParent(element.firstElementChild) === element;\n}\n\n/**\n * Finds the root node (document, shadowDOM root) of the given element\n * @method\n * @memberof Popper.Utils\n * @argument {Element} node\n * @returns {Element} root node\n */\nfunction getRoot(node) {\n  if (node.parentNode !== null) {\n    return getRoot(node.parentNode);\n  }\n\n  return node;\n}\n\n/**\n * Finds the offset parent common to the two provided nodes\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element1\n * @argument {Element} element2\n * @returns {Element} common offset parent\n */\nfunction findCommonOffsetParent(element1, element2) {\n  // This check is needed to avoid errors in case one of the elements isn't defined for any reason\n  if (!element1 || !element1.nodeType || !element2 || !element2.nodeType) {\n    return document.documentElement;\n  }\n\n  // Here we make sure to give as \"start\" the element that comes first in the DOM\n  var order = element1.compareDocumentPosition(element2) & Node.DOCUMENT_POSITION_FOLLOWING;\n  var start = order ? element1 : element2;\n  var end = order ? element2 : element1;\n\n  // Get common ancestor container\n  var range = document.createRange();\n  range.setStart(start, 0);\n  range.setEnd(end, 0);\n  var commonAncestorContainer = range.commonAncestorContainer;\n\n  // Both nodes are inside #document\n\n  if (element1 !== commonAncestorContainer && element2 !== commonAncestorContainer || start.contains(end)) {\n    if (isOffsetContainer(commonAncestorContainer)) {\n      return commonAncestorContainer;\n    }\n\n    return getOffsetParent(commonAncestorContainer);\n  }\n\n  // one of the nodes is inside shadowDOM, find which one\n  var element1root = getRoot(element1);\n  if (element1root.host) {\n    return findCommonOffsetParent(element1root.host, element2);\n  } else {\n    return findCommonOffsetParent(element1, getRoot(element2).host);\n  }\n}\n\n/**\n * Gets the scroll value of the given element in the given side (top and left)\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @argument {String} side `top` or `left`\n * @returns {number} amount of scrolled pixels\n */\nfunction getScroll(element) {\n  var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'top';\n\n  var upperSide = side === 'top' ? 'scrollTop' : 'scrollLeft';\n  var nodeName = element.nodeName;\n\n  if (nodeName === 'BODY' || nodeName === 'HTML') {\n    var html = element.ownerDocument.documentElement;\n    var scrollingElement = element.ownerDocument.scrollingElement || html;\n    return scrollingElement[upperSide];\n  }\n\n  return element[upperSide];\n}\n\n/*\n * Sum or subtract the element scroll values (left and top) from a given rect object\n * @method\n * @memberof Popper.Utils\n * @param {Object} rect - Rect object you want to change\n * @param {HTMLElement} element - The element from the function reads the scroll values\n * @param {Boolean} subtract - set to true if you want to subtract the scroll values\n * @return {Object} rect - The modifier rect object\n */\nfunction includeScroll(rect, element) {\n  var subtract = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n  var scrollTop = getScroll(element, 'top');\n  var scrollLeft = getScroll(element, 'left');\n  var modifier = subtract ? -1 : 1;\n  rect.top += scrollTop * modifier;\n  rect.bottom += scrollTop * modifier;\n  rect.left += scrollLeft * modifier;\n  rect.right += scrollLeft * modifier;\n  return rect;\n}\n\n/*\n * Helper to detect borders of a given element\n * @method\n * @memberof Popper.Utils\n * @param {CSSStyleDeclaration} styles\n * Result of `getStyleComputedProperty` on the given element\n * @param {String} axis - `x` or `y`\n * @return {number} borders - The borders size of the given axis\n */\n\nfunction getBordersSize(styles, axis) {\n  var sideA = axis === 'x' ? 'Left' : 'Top';\n  var sideB = sideA === 'Left' ? 'Right' : 'Bottom';\n\n  return parseFloat(styles['border' + sideA + 'Width'], 10) + parseFloat(styles['border' + sideB + 'Width'], 10);\n}\n\nfunction getSize(axis, body, html, computedStyle) {\n  return Math.max(body['offset' + axis], body['scroll' + axis], html['client' + axis], html['offset' + axis], html['scroll' + axis], isIE(10) ? parseInt(html['offset' + axis]) + parseInt(computedStyle['margin' + (axis === 'Height' ? 'Top' : 'Left')]) + parseInt(computedStyle['margin' + (axis === 'Height' ? 'Bottom' : 'Right')]) : 0);\n}\n\nfunction getWindowSizes(document) {\n  var body = document.body;\n  var html = document.documentElement;\n  var computedStyle = isIE(10) && getComputedStyle(html);\n\n  return {\n    height: getSize('Height', body, html, computedStyle),\n    width: getSize('Width', body, html, computedStyle)\n  };\n}\n\nvar classCallCheck = function classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nvar createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar defineProperty = function defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n};\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\n/**\n * Given element offsets, generate an output similar to getBoundingClientRect\n * @method\n * @memberof Popper.Utils\n * @argument {Object} offsets\n * @returns {Object} ClientRect like output\n */\nfunction getClientRect(offsets) {\n  return _extends({}, offsets, {\n    right: offsets.left + offsets.width,\n    bottom: offsets.top + offsets.height\n  });\n}\n\n/**\n * Get bounding client rect of given element\n * @method\n * @memberof Popper.Utils\n * @param {HTMLElement} element\n * @return {Object} client rect\n */\nfunction getBoundingClientRect(element) {\n  var rect = {};\n\n  // IE10 10 FIX: Please, don't ask, the element isn't\n  // considered in DOM in some circumstances...\n  // This isn't reproducible in IE10 compatibility mode of IE11\n  try {\n    if (isIE(10)) {\n      rect = element.getBoundingClientRect();\n      var scrollTop = getScroll(element, 'top');\n      var scrollLeft = getScroll(element, 'left');\n      rect.top += scrollTop;\n      rect.left += scrollLeft;\n      rect.bottom += scrollTop;\n      rect.right += scrollLeft;\n    } else {\n      rect = element.getBoundingClientRect();\n    }\n  } catch (e) {}\n\n  var result = {\n    left: rect.left,\n    top: rect.top,\n    width: rect.right - rect.left,\n    height: rect.bottom - rect.top\n  };\n\n  // subtract scrollbar size from sizes\n  var sizes = element.nodeName === 'HTML' ? getWindowSizes(element.ownerDocument) : {};\n  var width = sizes.width || element.clientWidth || result.right - result.left;\n  var height = sizes.height || element.clientHeight || result.bottom - result.top;\n\n  var horizScrollbar = element.offsetWidth - width;\n  var vertScrollbar = element.offsetHeight - height;\n\n  // if an hypothetical scrollbar is detected, we must be sure it's not a `border`\n  // we make this check conditional for performance reasons\n  if (horizScrollbar || vertScrollbar) {\n    var styles = getStyleComputedProperty(element);\n    horizScrollbar -= getBordersSize(styles, 'x');\n    vertScrollbar -= getBordersSize(styles, 'y');\n\n    result.width -= horizScrollbar;\n    result.height -= vertScrollbar;\n  }\n\n  return getClientRect(result);\n}\n\nfunction getOffsetRectRelativeToArbitraryNode(children, parent) {\n  var fixedPosition = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n  var isIE10 = isIE(10);\n  var isHTML = parent.nodeName === 'HTML';\n  var childrenRect = getBoundingClientRect(children);\n  var parentRect = getBoundingClientRect(parent);\n  var scrollParent = getScrollParent(children);\n\n  var styles = getStyleComputedProperty(parent);\n  var borderTopWidth = parseFloat(styles.borderTopWidth, 10);\n  var borderLeftWidth = parseFloat(styles.borderLeftWidth, 10);\n\n  // In cases where the parent is fixed, we must ignore negative scroll in offset calc\n  if (fixedPosition && isHTML) {\n    parentRect.top = Math.max(parentRect.top, 0);\n    parentRect.left = Math.max(parentRect.left, 0);\n  }\n  var offsets = getClientRect({\n    top: childrenRect.top - parentRect.top - borderTopWidth,\n    left: childrenRect.left - parentRect.left - borderLeftWidth,\n    width: childrenRect.width,\n    height: childrenRect.height\n  });\n  offsets.marginTop = 0;\n  offsets.marginLeft = 0;\n\n  // Subtract margins of documentElement in case it's being used as parent\n  // we do this only on HTML because it's the only element that behaves\n  // differently when margins are applied to it. The margins are included in\n  // the box of the documentElement, in the other cases not.\n  if (!isIE10 && isHTML) {\n    var marginTop = parseFloat(styles.marginTop, 10);\n    var marginLeft = parseFloat(styles.marginLeft, 10);\n\n    offsets.top -= borderTopWidth - marginTop;\n    offsets.bottom -= borderTopWidth - marginTop;\n    offsets.left -= borderLeftWidth - marginLeft;\n    offsets.right -= borderLeftWidth - marginLeft;\n\n    // Attach marginTop and marginLeft because in some circumstances we may need them\n    offsets.marginTop = marginTop;\n    offsets.marginLeft = marginLeft;\n  }\n\n  if (isIE10 && !fixedPosition ? parent.contains(scrollParent) : parent === scrollParent && scrollParent.nodeName !== 'BODY') {\n    offsets = includeScroll(offsets, parent);\n  }\n\n  return offsets;\n}\n\nfunction getViewportOffsetRectRelativeToArtbitraryNode(element) {\n  var excludeScroll = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n  var html = element.ownerDocument.documentElement;\n  var relativeOffset = getOffsetRectRelativeToArbitraryNode(element, html);\n  var width = Math.max(html.clientWidth, window.innerWidth || 0);\n  var height = Math.max(html.clientHeight, window.innerHeight || 0);\n\n  var scrollTop = !excludeScroll ? getScroll(html) : 0;\n  var scrollLeft = !excludeScroll ? getScroll(html, 'left') : 0;\n\n  var offset = {\n    top: scrollTop - relativeOffset.top + relativeOffset.marginTop,\n    left: scrollLeft - relativeOffset.left + relativeOffset.marginLeft,\n    width: width,\n    height: height\n  };\n\n  return getClientRect(offset);\n}\n\n/**\n * Check if the given element is fixed or is inside a fixed parent\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @argument {Element} customContainer\n * @returns {Boolean} answer to \"isFixed?\"\n */\nfunction isFixed(element) {\n  var nodeName = element.nodeName;\n  if (nodeName === 'BODY' || nodeName === 'HTML') {\n    return false;\n  }\n  if (getStyleComputedProperty(element, 'position') === 'fixed') {\n    return true;\n  }\n  return isFixed(getParentNode(element));\n}\n\n/**\n * Finds the first parent of an element that has a transformed property defined\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @returns {Element} first transformed parent or documentElement\n */\n\nfunction getFixedPositionOffsetParent(element) {\n  // This check is needed to avoid errors in case one of the elements isn't defined for any reason\n  if (!element || !element.parentElement || isIE()) {\n    return document.documentElement;\n  }\n  var el = element.parentElement;\n  while (el && getStyleComputedProperty(el, 'transform') === 'none') {\n    el = el.parentElement;\n  }\n  return el || document.documentElement;\n}\n\n/**\n * Computed the boundaries limits and return them\n * @method\n * @memberof Popper.Utils\n * @param {HTMLElement} popper\n * @param {HTMLElement} reference\n * @param {number} padding\n * @param {HTMLElement} boundariesElement - Element used to define the boundaries\n * @param {Boolean} fixedPosition - Is in fixed position mode\n * @returns {Object} Coordinates of the boundaries\n */\nfunction getBoundaries(popper, reference, padding, boundariesElement) {\n  var fixedPosition = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n\n  // NOTE: 1 DOM access here\n\n  var boundaries = { top: 0, left: 0 };\n  var offsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, reference);\n\n  // Handle viewport case\n  if (boundariesElement === 'viewport') {\n    boundaries = getViewportOffsetRectRelativeToArtbitraryNode(offsetParent, fixedPosition);\n  } else {\n    // Handle other cases based on DOM element used as boundaries\n    var boundariesNode = void 0;\n    if (boundariesElement === 'scrollParent') {\n      boundariesNode = getScrollParent(getParentNode(reference));\n      if (boundariesNode.nodeName === 'BODY') {\n        boundariesNode = popper.ownerDocument.documentElement;\n      }\n    } else if (boundariesElement === 'window') {\n      boundariesNode = popper.ownerDocument.documentElement;\n    } else {\n      boundariesNode = boundariesElement;\n    }\n\n    var offsets = getOffsetRectRelativeToArbitraryNode(boundariesNode, offsetParent, fixedPosition);\n\n    // In case of HTML, we need a different computation\n    if (boundariesNode.nodeName === 'HTML' && !isFixed(offsetParent)) {\n      var _getWindowSizes = getWindowSizes(popper.ownerDocument),\n          height = _getWindowSizes.height,\n          width = _getWindowSizes.width;\n\n      boundaries.top += offsets.top - offsets.marginTop;\n      boundaries.bottom = height + offsets.top;\n      boundaries.left += offsets.left - offsets.marginLeft;\n      boundaries.right = width + offsets.left;\n    } else {\n      // for all the other DOM elements, this one is good\n      boundaries = offsets;\n    }\n  }\n\n  // Add paddings\n  padding = padding || 0;\n  var isPaddingNumber = typeof padding === 'number';\n  boundaries.left += isPaddingNumber ? padding : padding.left || 0;\n  boundaries.top += isPaddingNumber ? padding : padding.top || 0;\n  boundaries.right -= isPaddingNumber ? padding : padding.right || 0;\n  boundaries.bottom -= isPaddingNumber ? padding : padding.bottom || 0;\n\n  return boundaries;\n}\n\nfunction getArea(_ref) {\n  var width = _ref.width,\n      height = _ref.height;\n\n  return width * height;\n}\n\n/**\n * Utility used to transform the `auto` placement to the placement with more\n * available space.\n * @method\n * @memberof Popper.Utils\n * @argument {Object} data - The data object generated by update method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction computeAutoPlacement(placement, refRect, popper, reference, boundariesElement) {\n  var padding = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;\n\n  if (placement.indexOf('auto') === -1) {\n    return placement;\n  }\n\n  var boundaries = getBoundaries(popper, reference, padding, boundariesElement);\n\n  var rects = {\n    top: {\n      width: boundaries.width,\n      height: refRect.top - boundaries.top\n    },\n    right: {\n      width: boundaries.right - refRect.right,\n      height: boundaries.height\n    },\n    bottom: {\n      width: boundaries.width,\n      height: boundaries.bottom - refRect.bottom\n    },\n    left: {\n      width: refRect.left - boundaries.left,\n      height: boundaries.height\n    }\n  };\n\n  var sortedAreas = Object.keys(rects).map(function (key) {\n    return _extends({\n      key: key\n    }, rects[key], {\n      area: getArea(rects[key])\n    });\n  }).sort(function (a, b) {\n    return b.area - a.area;\n  });\n\n  var filteredAreas = sortedAreas.filter(function (_ref2) {\n    var width = _ref2.width,\n        height = _ref2.height;\n    return width >= popper.clientWidth && height >= popper.clientHeight;\n  });\n\n  var computedPlacement = filteredAreas.length > 0 ? filteredAreas[0].key : sortedAreas[0].key;\n\n  var variation = placement.split('-')[1];\n\n  return computedPlacement + (variation ? '-' + variation : '');\n}\n\n/**\n * Get offsets to the reference element\n * @method\n * @memberof Popper.Utils\n * @param {Object} state\n * @param {Element} popper - the popper element\n * @param {Element} reference - the reference element (the popper will be relative to this)\n * @param {Element} fixedPosition - is in fixed position mode\n * @returns {Object} An object containing the offsets which will be applied to the popper\n */\nfunction getReferenceOffsets(state, popper, reference) {\n  var fixedPosition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n\n  var commonOffsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, reference);\n  return getOffsetRectRelativeToArbitraryNode(reference, commonOffsetParent, fixedPosition);\n}\n\n/**\n * Get the outer sizes of the given element (offset size + margins)\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @returns {Object} object containing width and height properties\n */\nfunction getOuterSizes(element) {\n  var window = element.ownerDocument.defaultView;\n  var styles = window.getComputedStyle(element);\n  var x = parseFloat(styles.marginTop || 0) + parseFloat(styles.marginBottom || 0);\n  var y = parseFloat(styles.marginLeft || 0) + parseFloat(styles.marginRight || 0);\n  var result = {\n    width: element.offsetWidth + y,\n    height: element.offsetHeight + x\n  };\n  return result;\n}\n\n/**\n * Get the opposite placement of the given one\n * @method\n * @memberof Popper.Utils\n * @argument {String} placement\n * @returns {String} flipped placement\n */\nfunction getOppositePlacement(placement) {\n  var hash = { left: 'right', right: 'left', bottom: 'top', top: 'bottom' };\n  return placement.replace(/left|right|bottom|top/g, function (matched) {\n    return hash[matched];\n  });\n}\n\n/**\n * Get offsets to the popper\n * @method\n * @memberof Popper.Utils\n * @param {Object} position - CSS position the Popper will get applied\n * @param {HTMLElement} popper - the popper element\n * @param {Object} referenceOffsets - the reference offsets (the popper will be relative to this)\n * @param {String} placement - one of the valid placement options\n * @returns {Object} popperOffsets - An object containing the offsets which will be applied to the popper\n */\nfunction getPopperOffsets(popper, referenceOffsets, placement) {\n  placement = placement.split('-')[0];\n\n  // Get popper node sizes\n  var popperRect = getOuterSizes(popper);\n\n  // Add position, width and height to our offsets object\n  var popperOffsets = {\n    width: popperRect.width,\n    height: popperRect.height\n  };\n\n  // depending by the popper placement we have to compute its offsets slightly differently\n  var isHoriz = ['right', 'left'].indexOf(placement) !== -1;\n  var mainSide = isHoriz ? 'top' : 'left';\n  var secondarySide = isHoriz ? 'left' : 'top';\n  var measurement = isHoriz ? 'height' : 'width';\n  var secondaryMeasurement = !isHoriz ? 'height' : 'width';\n\n  popperOffsets[mainSide] = referenceOffsets[mainSide] + referenceOffsets[measurement] / 2 - popperRect[measurement] / 2;\n  if (placement === secondarySide) {\n    popperOffsets[secondarySide] = referenceOffsets[secondarySide] - popperRect[secondaryMeasurement];\n  } else {\n    popperOffsets[secondarySide] = referenceOffsets[getOppositePlacement(secondarySide)];\n  }\n\n  return popperOffsets;\n}\n\n/**\n * Mimics the `find` method of Array\n * @method\n * @memberof Popper.Utils\n * @argument {Array} arr\n * @argument prop\n * @argument value\n * @returns index or -1\n */\nfunction find(arr, check) {\n  // use native find if supported\n  if (Array.prototype.find) {\n    return arr.find(check);\n  }\n\n  // use `filter` to obtain the same behavior of `find`\n  return arr.filter(check)[0];\n}\n\n/**\n * Return the index of the matching object\n * @method\n * @memberof Popper.Utils\n * @argument {Array} arr\n * @argument prop\n * @argument value\n * @returns index or -1\n */\nfunction findIndex(arr, prop, value) {\n  // use native findIndex if supported\n  if (Array.prototype.findIndex) {\n    return arr.findIndex(function (cur) {\n      return cur[prop] === value;\n    });\n  }\n\n  // use `find` + `indexOf` if `findIndex` isn't supported\n  var match = find(arr, function (obj) {\n    return obj[prop] === value;\n  });\n  return arr.indexOf(match);\n}\n\n/**\n * Loop trough the list of modifiers and run them in order,\n * each of them will then edit the data object.\n * @method\n * @memberof Popper.Utils\n * @param {dataObject} data\n * @param {Array} modifiers\n * @param {String} ends - Optional modifier name used as stopper\n * @returns {dataObject}\n */\nfunction runModifiers(modifiers, data, ends) {\n  var modifiersToRun = ends === undefined ? modifiers : modifiers.slice(0, findIndex(modifiers, 'name', ends));\n\n  modifiersToRun.forEach(function (modifier) {\n    if (modifier['function']) {\n      // eslint-disable-line dot-notation\n      console.warn('`modifier.function` is deprecated, use `modifier.fn`!');\n    }\n    var fn = modifier['function'] || modifier.fn; // eslint-disable-line dot-notation\n    if (modifier.enabled && isFunction(fn)) {\n      // Add properties to offsets to make them a complete clientRect object\n      // we do this before each modifier to make sure the previous one doesn't\n      // mess with these values\n      data.offsets.popper = getClientRect(data.offsets.popper);\n      data.offsets.reference = getClientRect(data.offsets.reference);\n\n      data = fn(data, modifier);\n    }\n  });\n\n  return data;\n}\n\n/**\n * Updates the position of the popper, computing the new offsets and applying\n * the new style.<br />\n * Prefer `scheduleUpdate` over `update` because of performance reasons.\n * @method\n * @memberof Popper\n */\nfunction update() {\n  // if popper is destroyed, don't perform any further update\n  if (this.state.isDestroyed) {\n    return;\n  }\n\n  var data = {\n    instance: this,\n    styles: {},\n    arrowStyles: {},\n    attributes: {},\n    flipped: false,\n    offsets: {}\n  };\n\n  // compute reference element offsets\n  data.offsets.reference = getReferenceOffsets(this.state, this.popper, this.reference, this.options.positionFixed);\n\n  // compute auto placement, store placement inside the data object,\n  // modifiers will be able to edit `placement` if needed\n  // and refer to originalPlacement to know the original value\n  data.placement = computeAutoPlacement(this.options.placement, data.offsets.reference, this.popper, this.reference, this.options.modifiers.flip.boundariesElement, this.options.modifiers.flip.padding);\n\n  // store the computed placement inside `originalPlacement`\n  data.originalPlacement = data.placement;\n\n  data.positionFixed = this.options.positionFixed;\n\n  // compute the popper offsets\n  data.offsets.popper = getPopperOffsets(this.popper, data.offsets.reference, data.placement);\n\n  data.offsets.popper.position = this.options.positionFixed ? 'fixed' : 'absolute';\n\n  // run the modifiers\n  data = runModifiers(this.modifiers, data);\n\n  // the first `update` will call `onCreate` callback\n  // the other ones will call `onUpdate` callback\n  if (!this.state.isCreated) {\n    this.state.isCreated = true;\n    this.options.onCreate(data);\n  } else {\n    this.options.onUpdate(data);\n  }\n}\n\n/**\n * Helper used to know if the given modifier is enabled.\n * @method\n * @memberof Popper.Utils\n * @returns {Boolean}\n */\nfunction isModifierEnabled(modifiers, modifierName) {\n  return modifiers.some(function (_ref) {\n    var name = _ref.name,\n        enabled = _ref.enabled;\n    return enabled && name === modifierName;\n  });\n}\n\n/**\n * Get the prefixed supported property name\n * @method\n * @memberof Popper.Utils\n * @argument {String} property (camelCase)\n * @returns {String} prefixed property (camelCase or PascalCase, depending on the vendor prefix)\n */\nfunction getSupportedPropertyName(property) {\n  var prefixes = [false, 'ms', 'Webkit', 'Moz', 'O'];\n  var upperProp = property.charAt(0).toUpperCase() + property.slice(1);\n\n  for (var i = 0; i < prefixes.length; i++) {\n    var prefix = prefixes[i];\n    var toCheck = prefix ? '' + prefix + upperProp : property;\n    if (typeof document.body.style[toCheck] !== 'undefined') {\n      return toCheck;\n    }\n  }\n  return null;\n}\n\n/**\n * Destroys the popper.\n * @method\n * @memberof Popper\n */\nfunction destroy() {\n  this.state.isDestroyed = true;\n\n  // touch DOM only if `applyStyle` modifier is enabled\n  if (isModifierEnabled(this.modifiers, 'applyStyle')) {\n    this.popper.removeAttribute('x-placement');\n    this.popper.style.position = '';\n    this.popper.style.top = '';\n    this.popper.style.left = '';\n    this.popper.style.right = '';\n    this.popper.style.bottom = '';\n    this.popper.style.willChange = '';\n    this.popper.style[getSupportedPropertyName('transform')] = '';\n  }\n\n  this.disableEventListeners();\n\n  // remove the popper if user explicity asked for the deletion on destroy\n  // do not use `remove` because IE11 doesn't support it\n  if (this.options.removeOnDestroy) {\n    this.popper.parentNode.removeChild(this.popper);\n  }\n  return this;\n}\n\n/**\n * Get the window associated with the element\n * @argument {Element} element\n * @returns {Window}\n */\nfunction getWindow(element) {\n  var ownerDocument = element.ownerDocument;\n  return ownerDocument ? ownerDocument.defaultView : window;\n}\n\nfunction attachToScrollParents(scrollParent, event, callback, scrollParents) {\n  var isBody = scrollParent.nodeName === 'BODY';\n  var target = isBody ? scrollParent.ownerDocument.defaultView : scrollParent;\n  target.addEventListener(event, callback, { passive: true });\n\n  if (!isBody) {\n    attachToScrollParents(getScrollParent(target.parentNode), event, callback, scrollParents);\n  }\n  scrollParents.push(target);\n}\n\n/**\n * Setup needed event listeners used to update the popper position\n * @method\n * @memberof Popper.Utils\n * @private\n */\nfunction setupEventListeners(reference, options, state, updateBound) {\n  // Resize event listener on window\n  state.updateBound = updateBound;\n  getWindow(reference).addEventListener('resize', state.updateBound, { passive: true });\n\n  // Scroll event listener on scroll parents\n  var scrollElement = getScrollParent(reference);\n  attachToScrollParents(scrollElement, 'scroll', state.updateBound, state.scrollParents);\n  state.scrollElement = scrollElement;\n  state.eventsEnabled = true;\n\n  return state;\n}\n\n/**\n * It will add resize/scroll events and start recalculating\n * position of the popper element when they are triggered.\n * @method\n * @memberof Popper\n */\nfunction enableEventListeners() {\n  if (!this.state.eventsEnabled) {\n    this.state = setupEventListeners(this.reference, this.options, this.state, this.scheduleUpdate);\n  }\n}\n\n/**\n * Remove event listeners used to update the popper position\n * @method\n * @memberof Popper.Utils\n * @private\n */\nfunction removeEventListeners(reference, state) {\n  // Remove resize event listener on window\n  getWindow(reference).removeEventListener('resize', state.updateBound);\n\n  // Remove scroll event listener on scroll parents\n  state.scrollParents.forEach(function (target) {\n    target.removeEventListener('scroll', state.updateBound);\n  });\n\n  // Reset state\n  state.updateBound = null;\n  state.scrollParents = [];\n  state.scrollElement = null;\n  state.eventsEnabled = false;\n  return state;\n}\n\n/**\n * It will remove resize/scroll events and won't recalculate popper position\n * when they are triggered. It also won't trigger `onUpdate` callback anymore,\n * unless you call `update` method manually.\n * @method\n * @memberof Popper\n */\nfunction disableEventListeners() {\n  if (this.state.eventsEnabled) {\n    cancelAnimationFrame(this.scheduleUpdate);\n    this.state = removeEventListeners(this.reference, this.state);\n  }\n}\n\n/**\n * Tells if a given input is a number\n * @method\n * @memberof Popper.Utils\n * @param {*} input to check\n * @return {Boolean}\n */\nfunction isNumeric(n) {\n  return n !== '' && !isNaN(parseFloat(n)) && isFinite(n);\n}\n\n/**\n * Set the style to the given popper\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element - Element to apply the style to\n * @argument {Object} styles\n * Object with a list of properties and values which will be applied to the element\n */\nfunction setStyles(element, styles) {\n  Object.keys(styles).forEach(function (prop) {\n    var unit = '';\n    // add unit if the value is numeric and is one of the following\n    if (['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(prop) !== -1 && isNumeric(styles[prop])) {\n      unit = 'px';\n    }\n    element.style[prop] = styles[prop] + unit;\n  });\n}\n\n/**\n * Set the attributes to the given popper\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element - Element to apply the attributes to\n * @argument {Object} styles\n * Object with a list of properties and values which will be applied to the element\n */\nfunction setAttributes(element, attributes) {\n  Object.keys(attributes).forEach(function (prop) {\n    var value = attributes[prop];\n    if (value !== false) {\n      element.setAttribute(prop, attributes[prop]);\n    } else {\n      element.removeAttribute(prop);\n    }\n  });\n}\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by `update` method\n * @argument {Object} data.styles - List of style properties - values to apply to popper element\n * @argument {Object} data.attributes - List of attribute properties - values to apply to popper element\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The same data object\n */\nfunction applyStyle(data) {\n  // any property present in `data.styles` will be applied to the popper,\n  // in this way we can make the 3rd party modifiers add custom styles to it\n  // Be aware, modifiers could override the properties defined in the previous\n  // lines of this modifier!\n  setStyles(data.instance.popper, data.styles);\n\n  // any property present in `data.attributes` will be applied to the popper,\n  // they will be set as HTML attributes of the element\n  setAttributes(data.instance.popper, data.attributes);\n\n  // if arrowElement is defined and arrowStyles has some properties\n  if (data.arrowElement && Object.keys(data.arrowStyles).length) {\n    setStyles(data.arrowElement, data.arrowStyles);\n  }\n\n  return data;\n}\n\n/**\n * Set the x-placement attribute before everything else because it could be used\n * to add margins to the popper margins needs to be calculated to get the\n * correct popper offsets.\n * @method\n * @memberof Popper.modifiers\n * @param {HTMLElement} reference - The reference element used to position the popper\n * @param {HTMLElement} popper - The HTML element used as popper\n * @param {Object} options - Popper.js options\n */\nfunction applyStyleOnLoad(reference, popper, options, modifierOptions, state) {\n  // compute reference element offsets\n  var referenceOffsets = getReferenceOffsets(state, popper, reference, options.positionFixed);\n\n  // compute auto placement, store placement inside the data object,\n  // modifiers will be able to edit `placement` if needed\n  // and refer to originalPlacement to know the original value\n  var placement = computeAutoPlacement(options.placement, referenceOffsets, popper, reference, options.modifiers.flip.boundariesElement, options.modifiers.flip.padding);\n\n  popper.setAttribute('x-placement', placement);\n\n  // Apply `position` to popper before anything else because\n  // without the position applied we can't guarantee correct computations\n  setStyles(popper, { position: options.positionFixed ? 'fixed' : 'absolute' });\n\n  return options;\n}\n\n/**\n * @function\n * @memberof Popper.Utils\n * @argument {Object} data - The data object generated by `update` method\n * @argument {Boolean} shouldRound - If the offsets should be rounded at all\n * @returns {Object} The popper's position offsets rounded\n *\n * The tale of pixel-perfect positioning. It's still not 100% perfect, but as\n * good as it can be within reason.\n * Discussion here: https://github.com/FezVrasta/popper.js/pull/715\n *\n * Low DPI screens cause a popper to be blurry if not using full pixels (Safari\n * as well on High DPI screens).\n *\n * Firefox prefers no rounding for positioning and does not have blurriness on\n * high DPI screens.\n *\n * Only horizontal placement and left/right values need to be considered.\n */\nfunction getRoundedOffsets(data, shouldRound) {\n  var _data$offsets = data.offsets,\n      popper = _data$offsets.popper,\n      reference = _data$offsets.reference;\n\n  var isVertical = ['left', 'right'].indexOf(data.placement) !== -1;\n  var isVariation = data.placement.indexOf('-') !== -1;\n  var sameWidthOddness = reference.width % 2 === popper.width % 2;\n  var bothOddWidth = reference.width % 2 === 1 && popper.width % 2 === 1;\n  var noRound = function noRound(v) {\n    return v;\n  };\n\n  var horizontalToInteger = !shouldRound ? noRound : isVertical || isVariation || sameWidthOddness ? Math.round : Math.floor;\n  var verticalToInteger = !shouldRound ? noRound : Math.round;\n\n  return {\n    left: horizontalToInteger(bothOddWidth && !isVariation && shouldRound ? popper.left - 1 : popper.left),\n    top: verticalToInteger(popper.top),\n    bottom: verticalToInteger(popper.bottom),\n    right: horizontalToInteger(popper.right)\n  };\n}\n\nvar isFirefox = isBrowser && /Firefox/i.test(navigator.userAgent);\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by `update` method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction computeStyle(data, options) {\n  var x = options.x,\n      y = options.y;\n  var popper = data.offsets.popper;\n\n  // Remove this legacy support in Popper.js v2\n\n  var legacyGpuAccelerationOption = find(data.instance.modifiers, function (modifier) {\n    return modifier.name === 'applyStyle';\n  }).gpuAcceleration;\n  if (legacyGpuAccelerationOption !== undefined) {\n    console.warn('WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!');\n  }\n  var gpuAcceleration = legacyGpuAccelerationOption !== undefined ? legacyGpuAccelerationOption : options.gpuAcceleration;\n\n  var offsetParent = getOffsetParent(data.instance.popper);\n  var offsetParentRect = getBoundingClientRect(offsetParent);\n\n  // Styles\n  var styles = {\n    position: popper.position\n  };\n\n  var offsets = getRoundedOffsets(data, window.devicePixelRatio < 2 || !isFirefox);\n\n  var sideA = x === 'bottom' ? 'top' : 'bottom';\n  var sideB = y === 'right' ? 'left' : 'right';\n\n  // if gpuAcceleration is set to `true` and transform is supported,\n  //  we use `translate3d` to apply the position to the popper we\n  // automatically use the supported prefixed version if needed\n  var prefixedProperty = getSupportedPropertyName('transform');\n\n  // now, let's make a step back and look at this code closely (wtf?)\n  // If the content of the popper grows once it's been positioned, it\n  // may happen that the popper gets misplaced because of the new content\n  // overflowing its reference element\n  // To avoid this problem, we provide two options (x and y), which allow\n  // the consumer to define the offset origin.\n  // If we position a popper on top of a reference element, we can set\n  // `x` to `top` to make the popper grow towards its top instead of\n  // its bottom.\n  var left = void 0,\n      top = void 0;\n  if (sideA === 'bottom') {\n    // when offsetParent is <html> the positioning is relative to the bottom of the screen (excluding the scrollbar)\n    // and not the bottom of the html element\n    if (offsetParent.nodeName === 'HTML') {\n      top = -offsetParent.clientHeight + offsets.bottom;\n    } else {\n      top = -offsetParentRect.height + offsets.bottom;\n    }\n  } else {\n    top = offsets.top;\n  }\n  if (sideB === 'right') {\n    if (offsetParent.nodeName === 'HTML') {\n      left = -offsetParent.clientWidth + offsets.right;\n    } else {\n      left = -offsetParentRect.width + offsets.right;\n    }\n  } else {\n    left = offsets.left;\n  }\n  if (gpuAcceleration && prefixedProperty) {\n    styles[prefixedProperty] = 'translate3d(' + left + 'px, ' + top + 'px, 0)';\n    styles[sideA] = 0;\n    styles[sideB] = 0;\n    styles.willChange = 'transform';\n  } else {\n    // othwerise, we use the standard `top`, `left`, `bottom` and `right` properties\n    var invertTop = sideA === 'bottom' ? -1 : 1;\n    var invertLeft = sideB === 'right' ? -1 : 1;\n    styles[sideA] = top * invertTop;\n    styles[sideB] = left * invertLeft;\n    styles.willChange = sideA + ', ' + sideB;\n  }\n\n  // Attributes\n  var attributes = {\n    'x-placement': data.placement\n  };\n\n  // Update `data` attributes, styles and arrowStyles\n  data.attributes = _extends({}, attributes, data.attributes);\n  data.styles = _extends({}, styles, data.styles);\n  data.arrowStyles = _extends({}, data.offsets.arrow, data.arrowStyles);\n\n  return data;\n}\n\n/**\n * Helper used to know if the given modifier depends from another one.<br />\n * It checks if the needed modifier is listed and enabled.\n * @method\n * @memberof Popper.Utils\n * @param {Array} modifiers - list of modifiers\n * @param {String} requestingName - name of requesting modifier\n * @param {String} requestedName - name of requested modifier\n * @returns {Boolean}\n */\nfunction isModifierRequired(modifiers, requestingName, requestedName) {\n  var requesting = find(modifiers, function (_ref) {\n    var name = _ref.name;\n    return name === requestingName;\n  });\n\n  var isRequired = !!requesting && modifiers.some(function (modifier) {\n    return modifier.name === requestedName && modifier.enabled && modifier.order < requesting.order;\n  });\n\n  if (!isRequired) {\n    var _requesting = '`' + requestingName + '`';\n    var requested = '`' + requestedName + '`';\n    console.warn(requested + ' modifier is required by ' + _requesting + ' modifier in order to work, be sure to include it before ' + _requesting + '!');\n  }\n  return isRequired;\n}\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by update method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction arrow(data, options) {\n  var _data$offsets$arrow;\n\n  // arrow depends on keepTogether in order to work\n  if (!isModifierRequired(data.instance.modifiers, 'arrow', 'keepTogether')) {\n    return data;\n  }\n\n  var arrowElement = options.element;\n\n  // if arrowElement is a string, suppose it's a CSS selector\n  if (typeof arrowElement === 'string') {\n    arrowElement = data.instance.popper.querySelector(arrowElement);\n\n    // if arrowElement is not found, don't run the modifier\n    if (!arrowElement) {\n      return data;\n    }\n  } else {\n    // if the arrowElement isn't a query selector we must check that the\n    // provided DOM node is child of its popper node\n    if (!data.instance.popper.contains(arrowElement)) {\n      console.warn('WARNING: `arrow.element` must be child of its popper element!');\n      return data;\n    }\n  }\n\n  var placement = data.placement.split('-')[0];\n  var _data$offsets = data.offsets,\n      popper = _data$offsets.popper,\n      reference = _data$offsets.reference;\n\n  var isVertical = ['left', 'right'].indexOf(placement) !== -1;\n\n  var len = isVertical ? 'height' : 'width';\n  var sideCapitalized = isVertical ? 'Top' : 'Left';\n  var side = sideCapitalized.toLowerCase();\n  var altSide = isVertical ? 'left' : 'top';\n  var opSide = isVertical ? 'bottom' : 'right';\n  var arrowElementSize = getOuterSizes(arrowElement)[len];\n\n  //\n  // extends keepTogether behavior making sure the popper and its\n  // reference have enough pixels in conjunction\n  //\n\n  // top/left side\n  if (reference[opSide] - arrowElementSize < popper[side]) {\n    data.offsets.popper[side] -= popper[side] - (reference[opSide] - arrowElementSize);\n  }\n  // bottom/right side\n  if (reference[side] + arrowElementSize > popper[opSide]) {\n    data.offsets.popper[side] += reference[side] + arrowElementSize - popper[opSide];\n  }\n  data.offsets.popper = getClientRect(data.offsets.popper);\n\n  // compute center of the popper\n  var center = reference[side] + reference[len] / 2 - arrowElementSize / 2;\n\n  // Compute the sideValue using the updated popper offsets\n  // take popper margin in account because we don't have this info available\n  var css = getStyleComputedProperty(data.instance.popper);\n  var popperMarginSide = parseFloat(css['margin' + sideCapitalized], 10);\n  var popperBorderSide = parseFloat(css['border' + sideCapitalized + 'Width'], 10);\n  var sideValue = center - data.offsets.popper[side] - popperMarginSide - popperBorderSide;\n\n  // prevent arrowElement from being placed not contiguously to its popper\n  sideValue = Math.max(Math.min(popper[len] - arrowElementSize, sideValue), 0);\n\n  data.arrowElement = arrowElement;\n  data.offsets.arrow = (_data$offsets$arrow = {}, defineProperty(_data$offsets$arrow, side, Math.round(sideValue)), defineProperty(_data$offsets$arrow, altSide, ''), _data$offsets$arrow);\n\n  return data;\n}\n\n/**\n * Get the opposite placement variation of the given one\n * @method\n * @memberof Popper.Utils\n * @argument {String} placement variation\n * @returns {String} flipped placement variation\n */\nfunction getOppositeVariation(variation) {\n  if (variation === 'end') {\n    return 'start';\n  } else if (variation === 'start') {\n    return 'end';\n  }\n  return variation;\n}\n\n/**\n * List of accepted placements to use as values of the `placement` option.<br />\n * Valid placements are:\n * - `auto`\n * - `top`\n * - `right`\n * - `bottom`\n * - `left`\n *\n * Each placement can have a variation from this list:\n * - `-start`\n * - `-end`\n *\n * Variations are interpreted easily if you think of them as the left to right\n * written languages. Horizontally (`top` and `bottom`), `start` is left and `end`\n * is right.<br />\n * Vertically (`left` and `right`), `start` is top and `end` is bottom.\n *\n * Some valid examples are:\n * - `top-end` (on top of reference, right aligned)\n * - `right-start` (on right of reference, top aligned)\n * - `bottom` (on bottom, centered)\n * - `auto-end` (on the side with more space available, alignment depends by placement)\n *\n * @static\n * @type {Array}\n * @enum {String}\n * @readonly\n * @method placements\n * @memberof Popper\n */\nvar placements = ['auto-start', 'auto', 'auto-end', 'top-start', 'top', 'top-end', 'right-start', 'right', 'right-end', 'bottom-end', 'bottom', 'bottom-start', 'left-end', 'left', 'left-start'];\n\n// Get rid of `auto` `auto-start` and `auto-end`\nvar validPlacements = placements.slice(3);\n\n/**\n * Given an initial placement, returns all the subsequent placements\n * clockwise (or counter-clockwise).\n *\n * @method\n * @memberof Popper.Utils\n * @argument {String} placement - A valid placement (it accepts variations)\n * @argument {Boolean} counter - Set to true to walk the placements counterclockwise\n * @returns {Array} placements including their variations\n */\nfunction clockwise(placement) {\n  var counter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n  var index = validPlacements.indexOf(placement);\n  var arr = validPlacements.slice(index + 1).concat(validPlacements.slice(0, index));\n  return counter ? arr.reverse() : arr;\n}\n\nvar BEHAVIORS = {\n  FLIP: 'flip',\n  CLOCKWISE: 'clockwise',\n  COUNTERCLOCKWISE: 'counterclockwise'\n};\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by update method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction flip(data, options) {\n  // if `inner` modifier is enabled, we can't use the `flip` modifier\n  if (isModifierEnabled(data.instance.modifiers, 'inner')) {\n    return data;\n  }\n\n  if (data.flipped && data.placement === data.originalPlacement) {\n    // seems like flip is trying to loop, probably there's not enough space on any of the flippable sides\n    return data;\n  }\n\n  var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, options.boundariesElement, data.positionFixed);\n\n  var placement = data.placement.split('-')[0];\n  var placementOpposite = getOppositePlacement(placement);\n  var variation = data.placement.split('-')[1] || '';\n\n  var flipOrder = [];\n\n  switch (options.behavior) {\n    case BEHAVIORS.FLIP:\n      flipOrder = [placement, placementOpposite];\n      break;\n    case BEHAVIORS.CLOCKWISE:\n      flipOrder = clockwise(placement);\n      break;\n    case BEHAVIORS.COUNTERCLOCKWISE:\n      flipOrder = clockwise(placement, true);\n      break;\n    default:\n      flipOrder = options.behavior;\n  }\n\n  flipOrder.forEach(function (step, index) {\n    if (placement !== step || flipOrder.length === index + 1) {\n      return data;\n    }\n\n    placement = data.placement.split('-')[0];\n    placementOpposite = getOppositePlacement(placement);\n\n    var popperOffsets = data.offsets.popper;\n    var refOffsets = data.offsets.reference;\n\n    // using floor because the reference offsets may contain decimals we are not going to consider here\n    var floor = Math.floor;\n    var overlapsRef = placement === 'left' && floor(popperOffsets.right) > floor(refOffsets.left) || placement === 'right' && floor(popperOffsets.left) < floor(refOffsets.right) || placement === 'top' && floor(popperOffsets.bottom) > floor(refOffsets.top) || placement === 'bottom' && floor(popperOffsets.top) < floor(refOffsets.bottom);\n\n    var overflowsLeft = floor(popperOffsets.left) < floor(boundaries.left);\n    var overflowsRight = floor(popperOffsets.right) > floor(boundaries.right);\n    var overflowsTop = floor(popperOffsets.top) < floor(boundaries.top);\n    var overflowsBottom = floor(popperOffsets.bottom) > floor(boundaries.bottom);\n\n    var overflowsBoundaries = placement === 'left' && overflowsLeft || placement === 'right' && overflowsRight || placement === 'top' && overflowsTop || placement === 'bottom' && overflowsBottom;\n\n    // flip the variation if required\n    var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;\n    var flippedVariation = !!options.flipVariations && (isVertical && variation === 'start' && overflowsLeft || isVertical && variation === 'end' && overflowsRight || !isVertical && variation === 'start' && overflowsTop || !isVertical && variation === 'end' && overflowsBottom);\n\n    if (overlapsRef || overflowsBoundaries || flippedVariation) {\n      // this boolean to detect any flip loop\n      data.flipped = true;\n\n      if (overlapsRef || overflowsBoundaries) {\n        placement = flipOrder[index + 1];\n      }\n\n      if (flippedVariation) {\n        variation = getOppositeVariation(variation);\n      }\n\n      data.placement = placement + (variation ? '-' + variation : '');\n\n      // this object contains `position`, we want to preserve it along with\n      // any additional property we may add in the future\n      data.offsets.popper = _extends({}, data.offsets.popper, getPopperOffsets(data.instance.popper, data.offsets.reference, data.placement));\n\n      data = runModifiers(data.instance.modifiers, data, 'flip');\n    }\n  });\n  return data;\n}\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by update method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction keepTogether(data) {\n  var _data$offsets = data.offsets,\n      popper = _data$offsets.popper,\n      reference = _data$offsets.reference;\n\n  var placement = data.placement.split('-')[0];\n  var floor = Math.floor;\n  var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;\n  var side = isVertical ? 'right' : 'bottom';\n  var opSide = isVertical ? 'left' : 'top';\n  var measurement = isVertical ? 'width' : 'height';\n\n  if (popper[side] < floor(reference[opSide])) {\n    data.offsets.popper[opSide] = floor(reference[opSide]) - popper[measurement];\n  }\n  if (popper[opSide] > floor(reference[side])) {\n    data.offsets.popper[opSide] = floor(reference[side]);\n  }\n\n  return data;\n}\n\n/**\n * Converts a string containing value + unit into a px value number\n * @function\n * @memberof {modifiers~offset}\n * @private\n * @argument {String} str - Value + unit string\n * @argument {String} measurement - `height` or `width`\n * @argument {Object} popperOffsets\n * @argument {Object} referenceOffsets\n * @returns {Number|String}\n * Value in pixels, or original string if no values were extracted\n */\nfunction toValue(str, measurement, popperOffsets, referenceOffsets) {\n  // separate value from unit\n  var split = str.match(/((?:\\-|\\+)?\\d*\\.?\\d*)(.*)/);\n  var value = +split[1];\n  var unit = split[2];\n\n  // If it's not a number it's an operator, I guess\n  if (!value) {\n    return str;\n  }\n\n  if (unit.indexOf('%') === 0) {\n    var element = void 0;\n    switch (unit) {\n      case '%p':\n        element = popperOffsets;\n        break;\n      case '%':\n      case '%r':\n      default:\n        element = referenceOffsets;\n    }\n\n    var rect = getClientRect(element);\n    return rect[measurement] / 100 * value;\n  } else if (unit === 'vh' || unit === 'vw') {\n    // if is a vh or vw, we calculate the size based on the viewport\n    var size = void 0;\n    if (unit === 'vh') {\n      size = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);\n    } else {\n      size = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);\n    }\n    return size / 100 * value;\n  } else {\n    // if is an explicit pixel unit, we get rid of the unit and keep the value\n    // if is an implicit unit, it's px, and we return just the value\n    return value;\n  }\n}\n\n/**\n * Parse an `offset` string to extrapolate `x` and `y` numeric offsets.\n * @function\n * @memberof {modifiers~offset}\n * @private\n * @argument {String} offset\n * @argument {Object} popperOffsets\n * @argument {Object} referenceOffsets\n * @argument {String} basePlacement\n * @returns {Array} a two cells array with x and y offsets in numbers\n */\nfunction parseOffset(offset, popperOffsets, referenceOffsets, basePlacement) {\n  var offsets = [0, 0];\n\n  // Use height if placement is left or right and index is 0 otherwise use width\n  // in this way the first offset will use an axis and the second one\n  // will use the other one\n  var useHeight = ['right', 'left'].indexOf(basePlacement) !== -1;\n\n  // Split the offset string to obtain a list of values and operands\n  // The regex addresses values with the plus or minus sign in front (+10, -20, etc)\n  var fragments = offset.split(/(\\+|\\-)/).map(function (frag) {\n    return frag.trim();\n  });\n\n  // Detect if the offset string contains a pair of values or a single one\n  // they could be separated by comma or space\n  var divider = fragments.indexOf(find(fragments, function (frag) {\n    return frag.search(/,|\\s/) !== -1;\n  }));\n\n  if (fragments[divider] && fragments[divider].indexOf(',') === -1) {\n    console.warn('Offsets separated by white space(s) are deprecated, use a comma (,) instead.');\n  }\n\n  // If divider is found, we divide the list of values and operands to divide\n  // them by ofset X and Y.\n  var splitRegex = /\\s*,\\s*|\\s+/;\n  var ops = divider !== -1 ? [fragments.slice(0, divider).concat([fragments[divider].split(splitRegex)[0]]), [fragments[divider].split(splitRegex)[1]].concat(fragments.slice(divider + 1))] : [fragments];\n\n  // Convert the values with units to absolute pixels to allow our computations\n  ops = ops.map(function (op, index) {\n    // Most of the units rely on the orientation of the popper\n    var measurement = (index === 1 ? !useHeight : useHeight) ? 'height' : 'width';\n    var mergeWithPrevious = false;\n    return op\n    // This aggregates any `+` or `-` sign that aren't considered operators\n    // e.g.: 10 + +5 => [10, +, +5]\n    .reduce(function (a, b) {\n      if (a[a.length - 1] === '' && ['+', '-'].indexOf(b) !== -1) {\n        a[a.length - 1] = b;\n        mergeWithPrevious = true;\n        return a;\n      } else if (mergeWithPrevious) {\n        a[a.length - 1] += b;\n        mergeWithPrevious = false;\n        return a;\n      } else {\n        return a.concat(b);\n      }\n    }, [])\n    // Here we convert the string values into number values (in px)\n    .map(function (str) {\n      return toValue(str, measurement, popperOffsets, referenceOffsets);\n    });\n  });\n\n  // Loop trough the offsets arrays and execute the operations\n  ops.forEach(function (op, index) {\n    op.forEach(function (frag, index2) {\n      if (isNumeric(frag)) {\n        offsets[index] += frag * (op[index2 - 1] === '-' ? -1 : 1);\n      }\n    });\n  });\n  return offsets;\n}\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by update method\n * @argument {Object} options - Modifiers configuration and options\n * @argument {Number|String} options.offset=0\n * The offset value as described in the modifier description\n * @returns {Object} The data object, properly modified\n */\nfunction offset(data, _ref) {\n  var offset = _ref.offset;\n  var placement = data.placement,\n      _data$offsets = data.offsets,\n      popper = _data$offsets.popper,\n      reference = _data$offsets.reference;\n\n  var basePlacement = placement.split('-')[0];\n\n  var offsets = void 0;\n  if (isNumeric(+offset)) {\n    offsets = [+offset, 0];\n  } else {\n    offsets = parseOffset(offset, popper, reference, basePlacement);\n  }\n\n  if (basePlacement === 'left') {\n    popper.top += offsets[0];\n    popper.left -= offsets[1];\n  } else if (basePlacement === 'right') {\n    popper.top += offsets[0];\n    popper.left += offsets[1];\n  } else if (basePlacement === 'top') {\n    popper.left += offsets[0];\n    popper.top -= offsets[1];\n  } else if (basePlacement === 'bottom') {\n    popper.left += offsets[0];\n    popper.top += offsets[1];\n  }\n\n  data.popper = popper;\n  return data;\n}\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by `update` method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction preventOverflow(data, options) {\n  var boundariesElement = options.boundariesElement || getOffsetParent(data.instance.popper);\n\n  // If offsetParent is the reference element, we really want to\n  // go one step up and use the next offsetParent as reference to\n  // avoid to make this modifier completely useless and look like broken\n  if (data.instance.reference === boundariesElement) {\n    boundariesElement = getOffsetParent(boundariesElement);\n  }\n\n  // NOTE: DOM access here\n  // resets the popper's position so that the document size can be calculated excluding\n  // the size of the popper element itself\n  var transformProp = getSupportedPropertyName('transform');\n  var popperStyles = data.instance.popper.style; // assignment to help minification\n  var top = popperStyles.top,\n      left = popperStyles.left,\n      transform = popperStyles[transformProp];\n\n  popperStyles.top = '';\n  popperStyles.left = '';\n  popperStyles[transformProp] = '';\n\n  var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, boundariesElement, data.positionFixed);\n\n  // NOTE: DOM access here\n  // restores the original style properties after the offsets have been computed\n  popperStyles.top = top;\n  popperStyles.left = left;\n  popperStyles[transformProp] = transform;\n\n  options.boundaries = boundaries;\n\n  var order = options.priority;\n  var popper = data.offsets.popper;\n\n  var check = {\n    primary: function primary(placement) {\n      var value = popper[placement];\n      if (popper[placement] < boundaries[placement] && !options.escapeWithReference) {\n        value = Math.max(popper[placement], boundaries[placement]);\n      }\n      return defineProperty({}, placement, value);\n    },\n    secondary: function secondary(placement) {\n      var mainSide = placement === 'right' ? 'left' : 'top';\n      var value = popper[mainSide];\n      if (popper[placement] > boundaries[placement] && !options.escapeWithReference) {\n        value = Math.min(popper[mainSide], boundaries[placement] - (placement === 'right' ? popper.width : popper.height));\n      }\n      return defineProperty({}, mainSide, value);\n    }\n  };\n\n  order.forEach(function (placement) {\n    var side = ['left', 'top'].indexOf(placement) !== -1 ? 'primary' : 'secondary';\n    popper = _extends({}, popper, check[side](placement));\n  });\n\n  data.offsets.popper = popper;\n\n  return data;\n}\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by `update` method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction shift(data) {\n  var placement = data.placement;\n  var basePlacement = placement.split('-')[0];\n  var shiftvariation = placement.split('-')[1];\n\n  // if shift shiftvariation is specified, run the modifier\n  if (shiftvariation) {\n    var _data$offsets = data.offsets,\n        reference = _data$offsets.reference,\n        popper = _data$offsets.popper;\n\n    var isVertical = ['bottom', 'top'].indexOf(basePlacement) !== -1;\n    var side = isVertical ? 'left' : 'top';\n    var measurement = isVertical ? 'width' : 'height';\n\n    var shiftOffsets = {\n      start: defineProperty({}, side, reference[side]),\n      end: defineProperty({}, side, reference[side] + reference[measurement] - popper[measurement])\n    };\n\n    data.offsets.popper = _extends({}, popper, shiftOffsets[shiftvariation]);\n  }\n\n  return data;\n}\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by update method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction hide(data) {\n  if (!isModifierRequired(data.instance.modifiers, 'hide', 'preventOverflow')) {\n    return data;\n  }\n\n  var refRect = data.offsets.reference;\n  var bound = find(data.instance.modifiers, function (modifier) {\n    return modifier.name === 'preventOverflow';\n  }).boundaries;\n\n  if (refRect.bottom < bound.top || refRect.left > bound.right || refRect.top > bound.bottom || refRect.right < bound.left) {\n    // Avoid unnecessary DOM access if visibility hasn't changed\n    if (data.hide === true) {\n      return data;\n    }\n\n    data.hide = true;\n    data.attributes['x-out-of-boundaries'] = '';\n  } else {\n    // Avoid unnecessary DOM access if visibility hasn't changed\n    if (data.hide === false) {\n      return data;\n    }\n\n    data.hide = false;\n    data.attributes['x-out-of-boundaries'] = false;\n  }\n\n  return data;\n}\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by `update` method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction inner(data) {\n  var placement = data.placement;\n  var basePlacement = placement.split('-')[0];\n  var _data$offsets = data.offsets,\n      popper = _data$offsets.popper,\n      reference = _data$offsets.reference;\n\n  var isHoriz = ['left', 'right'].indexOf(basePlacement) !== -1;\n\n  var subtractLength = ['top', 'left'].indexOf(basePlacement) === -1;\n\n  popper[isHoriz ? 'left' : 'top'] = reference[basePlacement] - (subtractLength ? popper[isHoriz ? 'width' : 'height'] : 0);\n\n  data.placement = getOppositePlacement(placement);\n  data.offsets.popper = getClientRect(popper);\n\n  return data;\n}\n\n/**\n * Modifier function, each modifier can have a function of this type assigned\n * to its `fn` property.<br />\n * These functions will be called on each update, this means that you must\n * make sure they are performant enough to avoid performance bottlenecks.\n *\n * @function ModifierFn\n * @argument {dataObject} data - The data object generated by `update` method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {dataObject} The data object, properly modified\n */\n\n/**\n * Modifiers are plugins used to alter the behavior of your poppers.<br />\n * Popper.js uses a set of 9 modifiers to provide all the basic functionalities\n * needed by the library.\n *\n * Usually you don't want to override the `order`, `fn` and `onLoad` props.\n * All the other properties are configurations that could be tweaked.\n * @namespace modifiers\n */\nvar modifiers = {\n  /**\n   * Modifier used to shift the popper on the start or end of its reference\n   * element.<br />\n   * It will read the variation of the `placement` property.<br />\n   * It can be one either `-end` or `-start`.\n   * @memberof modifiers\n   * @inner\n   */\n  shift: {\n    /** @prop {number} order=100 - Index used to define the order of execution */\n    order: 100,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: shift\n  },\n\n  /**\n   * The `offset` modifier can shift your popper on both its axis.\n   *\n   * It accepts the following units:\n   * - `px` or unit-less, interpreted as pixels\n   * - `%` or `%r`, percentage relative to the length of the reference element\n   * - `%p`, percentage relative to the length of the popper element\n   * - `vw`, CSS viewport width unit\n   * - `vh`, CSS viewport height unit\n   *\n   * For length is intended the main axis relative to the placement of the popper.<br />\n   * This means that if the placement is `top` or `bottom`, the length will be the\n   * `width`. In case of `left` or `right`, it will be the `height`.\n   *\n   * You can provide a single value (as `Number` or `String`), or a pair of values\n   * as `String` divided by a comma or one (or more) white spaces.<br />\n   * The latter is a deprecated method because it leads to confusion and will be\n   * removed in v2.<br />\n   * Additionally, it accepts additions and subtractions between different units.\n   * Note that multiplications and divisions aren't supported.\n   *\n   * Valid examples are:\n   * ```\n   * 10\n   * '10%'\n   * '10, 10'\n   * '10%, 10'\n   * '10 + 10%'\n   * '10 - 5vh + 3%'\n   * '-10px + 5vh, 5px - 6%'\n   * ```\n   * > **NB**: If you desire to apply offsets to your poppers in a way that may make them overlap\n   * > with their reference element, unfortunately, you will have to disable the `flip` modifier.\n   * > You can read more on this at this [issue](https://github.com/FezVrasta/popper.js/issues/373).\n   *\n   * @memberof modifiers\n   * @inner\n   */\n  offset: {\n    /** @prop {number} order=200 - Index used to define the order of execution */\n    order: 200,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: offset,\n    /** @prop {Number|String} offset=0\n     * The offset value as described in the modifier description\n     */\n    offset: 0\n  },\n\n  /**\n   * Modifier used to prevent the popper from being positioned outside the boundary.\n   *\n   * A scenario exists where the reference itself is not within the boundaries.<br />\n   * We can say it has \"escaped the boundaries\" — or just \"escaped\".<br />\n   * In this case we need to decide whether the popper should either:\n   *\n   * - detach from the reference and remain \"trapped\" in the boundaries, or\n   * - if it should ignore the boundary and \"escape with its reference\"\n   *\n   * When `escapeWithReference` is set to`true` and reference is completely\n   * outside its boundaries, the popper will overflow (or completely leave)\n   * the boundaries in order to remain attached to the edge of the reference.\n   *\n   * @memberof modifiers\n   * @inner\n   */\n  preventOverflow: {\n    /** @prop {number} order=300 - Index used to define the order of execution */\n    order: 300,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: preventOverflow,\n    /**\n     * @prop {Array} [priority=['left','right','top','bottom']]\n     * Popper will try to prevent overflow following these priorities by default,\n     * then, it could overflow on the left and on top of the `boundariesElement`\n     */\n    priority: ['left', 'right', 'top', 'bottom'],\n    /**\n     * @prop {number} padding=5\n     * Amount of pixel used to define a minimum distance between the boundaries\n     * and the popper. This makes sure the popper always has a little padding\n     * between the edges of its container\n     */\n    padding: 5,\n    /**\n     * @prop {String|HTMLElement} boundariesElement='scrollParent'\n     * Boundaries used by the modifier. Can be `scrollParent`, `window`,\n     * `viewport` or any DOM element.\n     */\n    boundariesElement: 'scrollParent'\n  },\n\n  /**\n   * Modifier used to make sure the reference and its popper stay near each other\n   * without leaving any gap between the two. Especially useful when the arrow is\n   * enabled and you want to ensure that it points to its reference element.\n   * It cares only about the first axis. You can still have poppers with margin\n   * between the popper and its reference element.\n   * @memberof modifiers\n   * @inner\n   */\n  keepTogether: {\n    /** @prop {number} order=400 - Index used to define the order of execution */\n    order: 400,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: keepTogether\n  },\n\n  /**\n   * This modifier is used to move the `arrowElement` of the popper to make\n   * sure it is positioned between the reference element and its popper element.\n   * It will read the outer size of the `arrowElement` node to detect how many\n   * pixels of conjunction are needed.\n   *\n   * It has no effect if no `arrowElement` is provided.\n   * @memberof modifiers\n   * @inner\n   */\n  arrow: {\n    /** @prop {number} order=500 - Index used to define the order of execution */\n    order: 500,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: arrow,\n    /** @prop {String|HTMLElement} element='[x-arrow]' - Selector or node used as arrow */\n    element: '[x-arrow]'\n  },\n\n  /**\n   * Modifier used to flip the popper's placement when it starts to overlap its\n   * reference element.\n   *\n   * Requires the `preventOverflow` modifier before it in order to work.\n   *\n   * **NOTE:** this modifier will interrupt the current update cycle and will\n   * restart it if it detects the need to flip the placement.\n   * @memberof modifiers\n   * @inner\n   */\n  flip: {\n    /** @prop {number} order=600 - Index used to define the order of execution */\n    order: 600,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: flip,\n    /**\n     * @prop {String|Array} behavior='flip'\n     * The behavior used to change the popper's placement. It can be one of\n     * `flip`, `clockwise`, `counterclockwise` or an array with a list of valid\n     * placements (with optional variations)\n     */\n    behavior: 'flip',\n    /**\n     * @prop {number} padding=5\n     * The popper will flip if it hits the edges of the `boundariesElement`\n     */\n    padding: 5,\n    /**\n     * @prop {String|HTMLElement} boundariesElement='viewport'\n     * The element which will define the boundaries of the popper position.\n     * The popper will never be placed outside of the defined boundaries\n     * (except if `keepTogether` is enabled)\n     */\n    boundariesElement: 'viewport'\n  },\n\n  /**\n   * Modifier used to make the popper flow toward the inner of the reference element.\n   * By default, when this modifier is disabled, the popper will be placed outside\n   * the reference element.\n   * @memberof modifiers\n   * @inner\n   */\n  inner: {\n    /** @prop {number} order=700 - Index used to define the order of execution */\n    order: 700,\n    /** @prop {Boolean} enabled=false - Whether the modifier is enabled or not */\n    enabled: false,\n    /** @prop {ModifierFn} */\n    fn: inner\n  },\n\n  /**\n   * Modifier used to hide the popper when its reference element is outside of the\n   * popper boundaries. It will set a `x-out-of-boundaries` attribute which can\n   * be used to hide with a CSS selector the popper when its reference is\n   * out of boundaries.\n   *\n   * Requires the `preventOverflow` modifier before it in order to work.\n   * @memberof modifiers\n   * @inner\n   */\n  hide: {\n    /** @prop {number} order=800 - Index used to define the order of execution */\n    order: 800,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: hide\n  },\n\n  /**\n   * Computes the style that will be applied to the popper element to gets\n   * properly positioned.\n   *\n   * Note that this modifier will not touch the DOM, it just prepares the styles\n   * so that `applyStyle` modifier can apply it. This separation is useful\n   * in case you need to replace `applyStyle` with a custom implementation.\n   *\n   * This modifier has `850` as `order` value to maintain backward compatibility\n   * with previous versions of Popper.js. Expect the modifiers ordering method\n   * to change in future major versions of the library.\n   *\n   * @memberof modifiers\n   * @inner\n   */\n  computeStyle: {\n    /** @prop {number} order=850 - Index used to define the order of execution */\n    order: 850,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: computeStyle,\n    /**\n     * @prop {Boolean} gpuAcceleration=true\n     * If true, it uses the CSS 3D transformation to position the popper.\n     * Otherwise, it will use the `top` and `left` properties\n     */\n    gpuAcceleration: true,\n    /**\n     * @prop {string} [x='bottom']\n     * Where to anchor the X axis (`bottom` or `top`). AKA X offset origin.\n     * Change this if your popper should grow in a direction different from `bottom`\n     */\n    x: 'bottom',\n    /**\n     * @prop {string} [x='left']\n     * Where to anchor the Y axis (`left` or `right`). AKA Y offset origin.\n     * Change this if your popper should grow in a direction different from `right`\n     */\n    y: 'right'\n  },\n\n  /**\n   * Applies the computed styles to the popper element.\n   *\n   * All the DOM manipulations are limited to this modifier. This is useful in case\n   * you want to integrate Popper.js inside a framework or view library and you\n   * want to delegate all the DOM manipulations to it.\n   *\n   * Note that if you disable this modifier, you must make sure the popper element\n   * has its position set to `absolute` before Popper.js can do its work!\n   *\n   * Just disable this modifier and define your own to achieve the desired effect.\n   *\n   * @memberof modifiers\n   * @inner\n   */\n  applyStyle: {\n    /** @prop {number} order=900 - Index used to define the order of execution */\n    order: 900,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: applyStyle,\n    /** @prop {Function} */\n    onLoad: applyStyleOnLoad,\n    /**\n     * @deprecated since version 1.10.0, the property moved to `computeStyle` modifier\n     * @prop {Boolean} gpuAcceleration=true\n     * If true, it uses the CSS 3D transformation to position the popper.\n     * Otherwise, it will use the `top` and `left` properties\n     */\n    gpuAcceleration: undefined\n  }\n};\n\n/**\n * The `dataObject` is an object containing all the information used by Popper.js.\n * This object is passed to modifiers and to the `onCreate` and `onUpdate` callbacks.\n * @name dataObject\n * @property {Object} data.instance The Popper.js instance\n * @property {String} data.placement Placement applied to popper\n * @property {String} data.originalPlacement Placement originally defined on init\n * @property {Boolean} data.flipped True if popper has been flipped by flip modifier\n * @property {Boolean} data.hide True if the reference element is out of boundaries, useful to know when to hide the popper\n * @property {HTMLElement} data.arrowElement Node used as arrow by arrow modifier\n * @property {Object} data.styles Any CSS property defined here will be applied to the popper. It expects the JavaScript nomenclature (eg. `marginBottom`)\n * @property {Object} data.arrowStyles Any CSS property defined here will be applied to the popper arrow. It expects the JavaScript nomenclature (eg. `marginBottom`)\n * @property {Object} data.boundaries Offsets of the popper boundaries\n * @property {Object} data.offsets The measurements of popper, reference and arrow elements\n * @property {Object} data.offsets.popper `top`, `left`, `width`, `height` values\n * @property {Object} data.offsets.reference `top`, `left`, `width`, `height` values\n * @property {Object} data.offsets.arrow] `top` and `left` offsets, only one of them will be different from 0\n */\n\n/**\n * Default options provided to Popper.js constructor.<br />\n * These can be overridden using the `options` argument of Popper.js.<br />\n * To override an option, simply pass an object with the same\n * structure of the `options` object, as the 3rd argument. For example:\n * ```\n * new Popper(ref, pop, {\n *   modifiers: {\n *     preventOverflow: { enabled: false }\n *   }\n * })\n * ```\n * @type {Object}\n * @static\n * @memberof Popper\n */\nvar Defaults = {\n  /**\n   * Popper's placement.\n   * @prop {Popper.placements} placement='bottom'\n   */\n  placement: 'bottom',\n\n  /**\n   * Set this to true if you want popper to position it self in 'fixed' mode\n   * @prop {Boolean} positionFixed=false\n   */\n  positionFixed: false,\n\n  /**\n   * Whether events (resize, scroll) are initially enabled.\n   * @prop {Boolean} eventsEnabled=true\n   */\n  eventsEnabled: true,\n\n  /**\n   * Set to true if you want to automatically remove the popper when\n   * you call the `destroy` method.\n   * @prop {Boolean} removeOnDestroy=false\n   */\n  removeOnDestroy: false,\n\n  /**\n   * Callback called when the popper is created.<br />\n   * By default, it is set to no-op.<br />\n   * Access Popper.js instance with `data.instance`.\n   * @prop {onCreate}\n   */\n  onCreate: function onCreate() {},\n\n  /**\n   * Callback called when the popper is updated. This callback is not called\n   * on the initialization/creation of the popper, but only on subsequent\n   * updates.<br />\n   * By default, it is set to no-op.<br />\n   * Access Popper.js instance with `data.instance`.\n   * @prop {onUpdate}\n   */\n  onUpdate: function onUpdate() {},\n\n  /**\n   * List of modifiers used to modify the offsets before they are applied to the popper.\n   * They provide most of the functionalities of Popper.js.\n   * @prop {modifiers}\n   */\n  modifiers: modifiers\n};\n\n/**\n * @callback onCreate\n * @param {dataObject} data\n */\n\n/**\n * @callback onUpdate\n * @param {dataObject} data\n */\n\n// Utils\n// Methods\nvar Popper = function () {\n  /**\n   * Creates a new Popper.js instance.\n   * @class Popper\n   * @param {HTMLElement|referenceObject} reference - The reference element used to position the popper\n   * @param {HTMLElement} popper - The HTML element used as the popper\n   * @param {Object} options - Your custom options to override the ones defined in [Defaults](#defaults)\n   * @return {Object} instance - The generated Popper.js instance\n   */\n  function Popper(reference, popper) {\n    var _this = this;\n\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    classCallCheck(this, Popper);\n\n    this.scheduleUpdate = function () {\n      return requestAnimationFrame(_this.update);\n    };\n\n    // make update() debounced, so that it only runs at most once-per-tick\n    this.update = debounce(this.update.bind(this));\n\n    // with {} we create a new object with the options inside it\n    this.options = _extends({}, Popper.Defaults, options);\n\n    // init state\n    this.state = {\n      isDestroyed: false,\n      isCreated: false,\n      scrollParents: []\n    };\n\n    // get reference and popper elements (allow jQuery wrappers)\n    this.reference = reference && reference.jquery ? reference[0] : reference;\n    this.popper = popper && popper.jquery ? popper[0] : popper;\n\n    // Deep merge modifiers options\n    this.options.modifiers = {};\n    Object.keys(_extends({}, Popper.Defaults.modifiers, options.modifiers)).forEach(function (name) {\n      _this.options.modifiers[name] = _extends({}, Popper.Defaults.modifiers[name] || {}, options.modifiers ? options.modifiers[name] : {});\n    });\n\n    // Refactoring modifiers' list (Object => Array)\n    this.modifiers = Object.keys(this.options.modifiers).map(function (name) {\n      return _extends({\n        name: name\n      }, _this.options.modifiers[name]);\n    })\n    // sort the modifiers by order\n    .sort(function (a, b) {\n      return a.order - b.order;\n    });\n\n    // modifiers have the ability to execute arbitrary code when Popper.js get inited\n    // such code is executed in the same order of its modifier\n    // they could add new properties to their options configuration\n    // BE AWARE: don't add options to `options.modifiers.name` but to `modifierOptions`!\n    this.modifiers.forEach(function (modifierOptions) {\n      if (modifierOptions.enabled && isFunction(modifierOptions.onLoad)) {\n        modifierOptions.onLoad(_this.reference, _this.popper, _this.options, modifierOptions, _this.state);\n      }\n    });\n\n    // fire the first update to position the popper in the right place\n    this.update();\n\n    var eventsEnabled = this.options.eventsEnabled;\n    if (eventsEnabled) {\n      // setup event listeners, they will take care of update the position in specific situations\n      this.enableEventListeners();\n    }\n\n    this.state.eventsEnabled = eventsEnabled;\n  }\n\n  // We can't use class properties because they don't get listed in the\n  // class prototype and break stuff like Sinon stubs\n\n\n  createClass(Popper, [{\n    key: 'update',\n    value: function update$$1() {\n      return update.call(this);\n    }\n  }, {\n    key: 'destroy',\n    value: function destroy$$1() {\n      return destroy.call(this);\n    }\n  }, {\n    key: 'enableEventListeners',\n    value: function enableEventListeners$$1() {\n      return enableEventListeners.call(this);\n    }\n  }, {\n    key: 'disableEventListeners',\n    value: function disableEventListeners$$1() {\n      return disableEventListeners.call(this);\n    }\n\n    /**\n     * Schedules an update. It will run on the next UI update available.\n     * @method scheduleUpdate\n     * @memberof Popper\n     */\n\n    /**\n     * Collection of utilities useful when writing custom modifiers.\n     * Starting from version 1.7, this method is available only if you\n     * include `popper-utils.js` before `popper.js`.\n     *\n     * **DEPRECATION**: This way to access PopperUtils is deprecated\n     * and will be removed in v2! Use the PopperUtils module directly instead.\n     * Due to the high instability of the methods contained in Utils, we can't\n     * guarantee them to follow semver. Use them at your own risk!\n     * @static\n     * @private\n     * @type {Object}\n     * @deprecated since version 1.8\n     * @member Utils\n     * @memberof Popper\n     */\n\n  }]);\n  return Popper;\n}();\n\n/**\n * The `referenceObject` is an object that provides an interface compatible with Popper.js\n * and lets you use it as replacement of a real DOM node.<br />\n * You can use this method to position a popper relatively to a set of coordinates\n * in case you don't have a DOM node to use as reference.\n *\n * ```\n * new Popper(referenceObject, popperNode);\n * ```\n *\n * NB: This feature isn't supported in Internet Explorer 10.\n * @name referenceObject\n * @property {Function} data.getBoundingClientRect\n * A function that returns a set of coordinates compatible with the native `getBoundingClientRect` method.\n * @property {number} data.clientWidth\n * An ES6 getter that will return the width of the virtual reference element.\n * @property {number} data.clientHeight\n * An ES6 getter that will return the height of the virtual reference element.\n */\n\nPopper.Utils = (typeof window !== 'undefined' ? window : global).PopperUtils;\nPopper.placements = placements;\nPopper.Defaults = Defaults;\n\nexports.default = Popper;\n//# sourceMappingURL=popper.js.map\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(10)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcG9wcGVyLmpzL2Rpc3QvZXNtL3BvcHBlci5qcz9mMGJkIl0sIm5hbWVzIjpbImlzQnJvd3NlciIsIndpbmRvdyIsImRvY3VtZW50IiwibG9uZ2VyVGltZW91dEJyb3dzZXJzIiwidGltZW91dER1cmF0aW9uIiwiaSIsImxlbmd0aCIsIm5hdmlnYXRvciIsInVzZXJBZ2VudCIsImluZGV4T2YiLCJtaWNyb3Rhc2tEZWJvdW5jZSIsImZuIiwiY2FsbGVkIiwiUHJvbWlzZSIsInJlc29sdmUiLCJ0aGVuIiwidGFza0RlYm91bmNlIiwic2NoZWR1bGVkIiwic2V0VGltZW91dCIsInN1cHBvcnRzTWljcm9UYXNrcyIsImRlYm91bmNlIiwiaXNGdW5jdGlvbiIsImZ1bmN0aW9uVG9DaGVjayIsImdldFR5cGUiLCJ0b1N0cmluZyIsImNhbGwiLCJnZXRTdHlsZUNvbXB1dGVkUHJvcGVydHkiLCJlbGVtZW50IiwicHJvcGVydHkiLCJub2RlVHlwZSIsIm93bmVyRG9jdW1lbnQiLCJkZWZhdWx0VmlldyIsImNzcyIsImdldENvbXB1dGVkU3R5bGUiLCJnZXRQYXJlbnROb2RlIiwibm9kZU5hbWUiLCJwYXJlbnROb2RlIiwiaG9zdCIsImdldFNjcm9sbFBhcmVudCIsImJvZHkiLCJfZ2V0U3R5bGVDb21wdXRlZFByb3AiLCJvdmVyZmxvdyIsIm92ZXJmbG93WCIsIm92ZXJmbG93WSIsInRlc3QiLCJpc0lFMTEiLCJNU0lucHV0TWV0aG9kQ29udGV4dCIsImRvY3VtZW50TW9kZSIsImlzSUUxMCIsImlzSUUiLCJ2ZXJzaW9uIiwiZ2V0T2Zmc2V0UGFyZW50IiwiZG9jdW1lbnRFbGVtZW50Iiwibm9PZmZzZXRQYXJlbnQiLCJvZmZzZXRQYXJlbnQiLCJuZXh0RWxlbWVudFNpYmxpbmciLCJpc09mZnNldENvbnRhaW5lciIsImZpcnN0RWxlbWVudENoaWxkIiwiZ2V0Um9vdCIsIm5vZGUiLCJmaW5kQ29tbW9uT2Zmc2V0UGFyZW50IiwiZWxlbWVudDEiLCJlbGVtZW50MiIsIm9yZGVyIiwiY29tcGFyZURvY3VtZW50UG9zaXRpb24iLCJOb2RlIiwiRE9DVU1FTlRfUE9TSVRJT05fRk9MTE9XSU5HIiwic3RhcnQiLCJlbmQiLCJyYW5nZSIsImNyZWF0ZVJhbmdlIiwic2V0U3RhcnQiLCJzZXRFbmQiLCJjb21tb25BbmNlc3RvckNvbnRhaW5lciIsImNvbnRhaW5zIiwiZWxlbWVudDFyb290IiwiZ2V0U2Nyb2xsIiwic2lkZSIsImFyZ3VtZW50cyIsInVuZGVmaW5lZCIsInVwcGVyU2lkZSIsImh0bWwiLCJzY3JvbGxpbmdFbGVtZW50IiwiaW5jbHVkZVNjcm9sbCIsInJlY3QiLCJzdWJ0cmFjdCIsInNjcm9sbFRvcCIsInNjcm9sbExlZnQiLCJtb2RpZmllciIsInRvcCIsImJvdHRvbSIsImxlZnQiLCJyaWdodCIsImdldEJvcmRlcnNTaXplIiwic3R5bGVzIiwiYXhpcyIsInNpZGVBIiwic2lkZUIiLCJwYXJzZUZsb2F0IiwiZ2V0U2l6ZSIsImNvbXB1dGVkU3R5bGUiLCJNYXRoIiwibWF4IiwicGFyc2VJbnQiLCJnZXRXaW5kb3dTaXplcyIsImhlaWdodCIsIndpZHRoIiwiY2xhc3NDYWxsQ2hlY2siLCJpbnN0YW5jZSIsIkNvbnN0cnVjdG9yIiwiVHlwZUVycm9yIiwiY3JlYXRlQ2xhc3MiLCJkZWZpbmVQcm9wZXJ0aWVzIiwidGFyZ2V0IiwicHJvcHMiLCJkZXNjcmlwdG9yIiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJrZXkiLCJwcm90b1Byb3BzIiwic3RhdGljUHJvcHMiLCJwcm90b3R5cGUiLCJvYmoiLCJ2YWx1ZSIsIl9leHRlbmRzIiwiYXNzaWduIiwic291cmNlIiwiaGFzT3duUHJvcGVydHkiLCJnZXRDbGllbnRSZWN0Iiwib2Zmc2V0cyIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImUiLCJyZXN1bHQiLCJzaXplcyIsImNsaWVudFdpZHRoIiwiY2xpZW50SGVpZ2h0IiwiaG9yaXpTY3JvbGxiYXIiLCJvZmZzZXRXaWR0aCIsInZlcnRTY3JvbGxiYXIiLCJvZmZzZXRIZWlnaHQiLCJnZXRPZmZzZXRSZWN0UmVsYXRpdmVUb0FyYml0cmFyeU5vZGUiLCJjaGlsZHJlbiIsInBhcmVudCIsImZpeGVkUG9zaXRpb24iLCJpc0hUTUwiLCJjaGlsZHJlblJlY3QiLCJwYXJlbnRSZWN0Iiwic2Nyb2xsUGFyZW50IiwiYm9yZGVyVG9wV2lkdGgiLCJib3JkZXJMZWZ0V2lkdGgiLCJtYXJnaW5Ub3AiLCJtYXJnaW5MZWZ0IiwiZ2V0Vmlld3BvcnRPZmZzZXRSZWN0UmVsYXRpdmVUb0FydGJpdHJhcnlOb2RlIiwiZXhjbHVkZVNjcm9sbCIsInJlbGF0aXZlT2Zmc2V0IiwiaW5uZXJXaWR0aCIsImlubmVySGVpZ2h0Iiwib2Zmc2V0IiwiaXNGaXhlZCIsImdldEZpeGVkUG9zaXRpb25PZmZzZXRQYXJlbnQiLCJwYXJlbnRFbGVtZW50IiwiZWwiLCJnZXRCb3VuZGFyaWVzIiwicG9wcGVyIiwicmVmZXJlbmNlIiwicGFkZGluZyIsImJvdW5kYXJpZXNFbGVtZW50IiwiYm91bmRhcmllcyIsImJvdW5kYXJpZXNOb2RlIiwiX2dldFdpbmRvd1NpemVzIiwiaXNQYWRkaW5nTnVtYmVyIiwiZ2V0QXJlYSIsIl9yZWYiLCJjb21wdXRlQXV0b1BsYWNlbWVudCIsInBsYWNlbWVudCIsInJlZlJlY3QiLCJyZWN0cyIsInNvcnRlZEFyZWFzIiwia2V5cyIsIm1hcCIsImFyZWEiLCJzb3J0IiwiYSIsImIiLCJmaWx0ZXJlZEFyZWFzIiwiZmlsdGVyIiwiX3JlZjIiLCJjb21wdXRlZFBsYWNlbWVudCIsInZhcmlhdGlvbiIsInNwbGl0IiwiZ2V0UmVmZXJlbmNlT2Zmc2V0cyIsInN0YXRlIiwiY29tbW9uT2Zmc2V0UGFyZW50IiwiZ2V0T3V0ZXJTaXplcyIsIngiLCJtYXJnaW5Cb3R0b20iLCJ5IiwibWFyZ2luUmlnaHQiLCJnZXRPcHBvc2l0ZVBsYWNlbWVudCIsImhhc2giLCJyZXBsYWNlIiwibWF0Y2hlZCIsImdldFBvcHBlck9mZnNldHMiLCJyZWZlcmVuY2VPZmZzZXRzIiwicG9wcGVyUmVjdCIsInBvcHBlck9mZnNldHMiLCJpc0hvcml6IiwibWFpblNpZGUiLCJzZWNvbmRhcnlTaWRlIiwibWVhc3VyZW1lbnQiLCJzZWNvbmRhcnlNZWFzdXJlbWVudCIsImZpbmQiLCJhcnIiLCJjaGVjayIsIkFycmF5IiwiZmluZEluZGV4IiwicHJvcCIsImN1ciIsIm1hdGNoIiwicnVuTW9kaWZpZXJzIiwibW9kaWZpZXJzIiwiZGF0YSIsImVuZHMiLCJtb2RpZmllcnNUb1J1biIsInNsaWNlIiwiZm9yRWFjaCIsImNvbnNvbGUiLCJ3YXJuIiwiZW5hYmxlZCIsInVwZGF0ZSIsImlzRGVzdHJveWVkIiwiYXJyb3dTdHlsZXMiLCJhdHRyaWJ1dGVzIiwiZmxpcHBlZCIsIm9wdGlvbnMiLCJwb3NpdGlvbkZpeGVkIiwiZmxpcCIsIm9yaWdpbmFsUGxhY2VtZW50IiwicG9zaXRpb24iLCJpc0NyZWF0ZWQiLCJvbkNyZWF0ZSIsIm9uVXBkYXRlIiwiaXNNb2RpZmllckVuYWJsZWQiLCJtb2RpZmllck5hbWUiLCJzb21lIiwibmFtZSIsImdldFN1cHBvcnRlZFByb3BlcnR5TmFtZSIsInByZWZpeGVzIiwidXBwZXJQcm9wIiwiY2hhckF0IiwidG9VcHBlckNhc2UiLCJwcmVmaXgiLCJ0b0NoZWNrIiwic3R5bGUiLCJkZXN0cm95IiwicmVtb3ZlQXR0cmlidXRlIiwid2lsbENoYW5nZSIsImRpc2FibGVFdmVudExpc3RlbmVycyIsInJlbW92ZU9uRGVzdHJveSIsInJlbW92ZUNoaWxkIiwiZ2V0V2luZG93IiwiYXR0YWNoVG9TY3JvbGxQYXJlbnRzIiwiZXZlbnQiLCJjYWxsYmFjayIsInNjcm9sbFBhcmVudHMiLCJpc0JvZHkiLCJhZGRFdmVudExpc3RlbmVyIiwicGFzc2l2ZSIsInB1c2giLCJzZXR1cEV2ZW50TGlzdGVuZXJzIiwidXBkYXRlQm91bmQiLCJzY3JvbGxFbGVtZW50IiwiZXZlbnRzRW5hYmxlZCIsImVuYWJsZUV2ZW50TGlzdGVuZXJzIiwic2NoZWR1bGVVcGRhdGUiLCJyZW1vdmVFdmVudExpc3RlbmVycyIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJjYW5jZWxBbmltYXRpb25GcmFtZSIsImlzTnVtZXJpYyIsIm4iLCJpc05hTiIsImlzRmluaXRlIiwic2V0U3R5bGVzIiwidW5pdCIsInNldEF0dHJpYnV0ZXMiLCJzZXRBdHRyaWJ1dGUiLCJhcHBseVN0eWxlIiwiYXJyb3dFbGVtZW50IiwiYXBwbHlTdHlsZU9uTG9hZCIsIm1vZGlmaWVyT3B0aW9ucyIsImdldFJvdW5kZWRPZmZzZXRzIiwic2hvdWxkUm91bmQiLCJfZGF0YSRvZmZzZXRzIiwiaXNWZXJ0aWNhbCIsImlzVmFyaWF0aW9uIiwic2FtZVdpZHRoT2RkbmVzcyIsImJvdGhPZGRXaWR0aCIsIm5vUm91bmQiLCJ2IiwiaG9yaXpvbnRhbFRvSW50ZWdlciIsInJvdW5kIiwiZmxvb3IiLCJ2ZXJ0aWNhbFRvSW50ZWdlciIsImlzRmlyZWZveCIsImNvbXB1dGVTdHlsZSIsImxlZ2FjeUdwdUFjY2VsZXJhdGlvbk9wdGlvbiIsImdwdUFjY2VsZXJhdGlvbiIsIm9mZnNldFBhcmVudFJlY3QiLCJkZXZpY2VQaXhlbFJhdGlvIiwicHJlZml4ZWRQcm9wZXJ0eSIsImludmVydFRvcCIsImludmVydExlZnQiLCJhcnJvdyIsImlzTW9kaWZpZXJSZXF1aXJlZCIsInJlcXVlc3RpbmdOYW1lIiwicmVxdWVzdGVkTmFtZSIsInJlcXVlc3RpbmciLCJpc1JlcXVpcmVkIiwiX3JlcXVlc3RpbmciLCJyZXF1ZXN0ZWQiLCJfZGF0YSRvZmZzZXRzJGFycm93IiwicXVlcnlTZWxlY3RvciIsImxlbiIsInNpZGVDYXBpdGFsaXplZCIsInRvTG93ZXJDYXNlIiwiYWx0U2lkZSIsIm9wU2lkZSIsImFycm93RWxlbWVudFNpemUiLCJjZW50ZXIiLCJwb3BwZXJNYXJnaW5TaWRlIiwicG9wcGVyQm9yZGVyU2lkZSIsInNpZGVWYWx1ZSIsIm1pbiIsImdldE9wcG9zaXRlVmFyaWF0aW9uIiwicGxhY2VtZW50cyIsInZhbGlkUGxhY2VtZW50cyIsImNsb2Nrd2lzZSIsImNvdW50ZXIiLCJpbmRleCIsImNvbmNhdCIsInJldmVyc2UiLCJCRUhBVklPUlMiLCJGTElQIiwiQ0xPQ0tXSVNFIiwiQ09VTlRFUkNMT0NLV0lTRSIsInBsYWNlbWVudE9wcG9zaXRlIiwiZmxpcE9yZGVyIiwiYmVoYXZpb3IiLCJzdGVwIiwicmVmT2Zmc2V0cyIsIm92ZXJsYXBzUmVmIiwib3ZlcmZsb3dzTGVmdCIsIm92ZXJmbG93c1JpZ2h0Iiwib3ZlcmZsb3dzVG9wIiwib3ZlcmZsb3dzQm90dG9tIiwib3ZlcmZsb3dzQm91bmRhcmllcyIsImZsaXBwZWRWYXJpYXRpb24iLCJmbGlwVmFyaWF0aW9ucyIsImtlZXBUb2dldGhlciIsInRvVmFsdWUiLCJzdHIiLCJzaXplIiwicGFyc2VPZmZzZXQiLCJiYXNlUGxhY2VtZW50IiwidXNlSGVpZ2h0IiwiZnJhZ21lbnRzIiwiZnJhZyIsInRyaW0iLCJkaXZpZGVyIiwic2VhcmNoIiwic3BsaXRSZWdleCIsIm9wcyIsIm9wIiwibWVyZ2VXaXRoUHJldmlvdXMiLCJyZWR1Y2UiLCJpbmRleDIiLCJwcmV2ZW50T3ZlcmZsb3ciLCJ0cmFuc2Zvcm1Qcm9wIiwicG9wcGVyU3R5bGVzIiwidHJhbnNmb3JtIiwicHJpb3JpdHkiLCJwcmltYXJ5IiwiZXNjYXBlV2l0aFJlZmVyZW5jZSIsInNlY29uZGFyeSIsInNoaWZ0Iiwic2hpZnR2YXJpYXRpb24iLCJzaGlmdE9mZnNldHMiLCJoaWRlIiwiYm91bmQiLCJpbm5lciIsInN1YnRyYWN0TGVuZ3RoIiwib25Mb2FkIiwiRGVmYXVsdHMiLCJQb3BwZXIiLCJfdGhpcyIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsImJpbmQiLCJqcXVlcnkiLCJ1cGRhdGUkJDEiLCJkZXN0cm95JCQxIiwiZW5hYmxlRXZlbnRMaXN0ZW5lcnMkJDEiLCJkaXNhYmxlRXZlbnRMaXN0ZW5lcnMk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T0FBT3BaLE1BQVAsS0FBa0IsV0FBbEIsR0FBZ0NBLE1BQWhDLEdBQXlDcVosTUFBMUMsRUFBa0RDLFdBQWpFO0FBQ0FYLE9BQU8zRCxVQUFQLEdBQW9CQSxVQUFwQjtBQUNBMkQsT0FBT0QsUUFBUCxHQUFrQkEsUUFBbEI7O2tCQUVlQyxNO0FBQ2Ysa0MiLCJmaWxlIjoiOS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKiFcbiAqIEBmaWxlT3ZlcnZpZXcgS2lja2FzcyBsaWJyYXJ5IHRvIGNyZWF0ZSBhbmQgcGxhY2UgcG9wcGVycyBuZWFyIHRoZWlyIHJlZmVyZW5jZSBlbGVtZW50cy5cbiAqIEB2ZXJzaW9uIDEuMTQuNlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAoYykgMjAxNiBGZWRlcmljbyBaaXZvbG8gYW5kIGNvbnRyaWJ1dG9yc1xuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcbiAqIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICogU09GVFdBUkUuXG4gKi9cbnZhciBpc0Jyb3dzZXIgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnO1xuXG52YXIgbG9uZ2VyVGltZW91dEJyb3dzZXJzID0gWydFZGdlJywgJ1RyaWRlbnQnLCAnRmlyZWZveCddO1xudmFyIHRpbWVvdXREdXJhdGlvbiA9IDA7XG5mb3IgKHZhciBpID0gMDsgaSA8IGxvbmdlclRpbWVvdXRCcm93c2Vycy5sZW5ndGg7IGkgKz0gMSkge1xuICBpZiAoaXNCcm93c2VyICYmIG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZihsb25nZXJUaW1lb3V0QnJvd3NlcnNbaV0pID49IDApIHtcbiAgICB0aW1lb3V0RHVyYXRpb24gPSAxO1xuICAgIGJyZWFrO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1pY3JvdGFza0RlYm91bmNlKGZuKSB7XG4gIHZhciBjYWxsZWQgPSBmYWxzZTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoY2FsbGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNhbGxlZCA9IHRydWU7XG4gICAgd2luZG93LlByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgY2FsbGVkID0gZmFsc2U7XG4gICAgICBmbigpO1xuICAgIH0pO1xuICB9O1xufVxuXG5mdW5jdGlvbiB0YXNrRGVib3VuY2UoZm4pIHtcbiAgdmFyIHNjaGVkdWxlZCA9IGZhbHNlO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGlmICghc2NoZWR1bGVkKSB7XG4gICAgICBzY2hlZHVsZWQgPSB0cnVlO1xuICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNjaGVkdWxlZCA9IGZhbHNlO1xuICAgICAgICBmbigpO1xuICAgICAgfSwgdGltZW91dER1cmF0aW9uKTtcbiAgICB9XG4gIH07XG59XG5cbnZhciBzdXBwb3J0c01pY3JvVGFza3MgPSBpc0Jyb3dzZXIgJiYgd2luZG93LlByb21pc2U7XG5cbi8qKlxuKiBDcmVhdGUgYSBkZWJvdW5jZWQgdmVyc2lvbiBvZiBhIG1ldGhvZCwgdGhhdCdzIGFzeW5jaHJvbm91c2x5IGRlZmVycmVkXG4qIGJ1dCBjYWxsZWQgaW4gdGhlIG1pbmltdW0gdGltZSBwb3NzaWJsZS5cbipcbiogQG1ldGhvZFxuKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4qIEBhcmd1bWVudCB7RnVuY3Rpb259IGZuXG4qIEByZXR1cm5zIHtGdW5jdGlvbn1cbiovXG52YXIgZGVib3VuY2UgPSBzdXBwb3J0c01pY3JvVGFza3MgPyBtaWNyb3Rhc2tEZWJvdW5jZSA6IHRhc2tEZWJvdW5jZTtcblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgZ2l2ZW4gdmFyaWFibGUgaXMgYSBmdW5jdGlvblxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtBbnl9IGZ1bmN0aW9uVG9DaGVjayAtIHZhcmlhYmxlIHRvIGNoZWNrXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gYW5zd2VyIHRvOiBpcyBhIGZ1bmN0aW9uP1xuICovXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGZ1bmN0aW9uVG9DaGVjaykge1xuICB2YXIgZ2V0VHlwZSA9IHt9O1xuICByZXR1cm4gZnVuY3Rpb25Ub0NoZWNrICYmIGdldFR5cGUudG9TdHJpbmcuY2FsbChmdW5jdGlvblRvQ2hlY2spID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xufVxuXG4vKipcbiAqIEdldCBDU1MgY29tcHV0ZWQgcHJvcGVydHkgb2YgdGhlIGdpdmVuIGVsZW1lbnRcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7RWVtZW50fSBlbGVtZW50XG4gKiBAYXJndW1lbnQge1N0cmluZ30gcHJvcGVydHlcbiAqL1xuZnVuY3Rpb24gZ2V0U3R5bGVDb21wdXRlZFByb3BlcnR5KGVsZW1lbnQsIHByb3BlcnR5KSB7XG4gIGlmIChlbGVtZW50Lm5vZGVUeXBlICE9PSAxKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIC8vIE5PVEU6IDEgRE9NIGFjY2VzcyBoZXJlXG4gIHZhciB3aW5kb3cgPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXc7XG4gIHZhciBjc3MgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50LCBudWxsKTtcbiAgcmV0dXJuIHByb3BlcnR5ID8gY3NzW3Byb3BlcnR5XSA6IGNzcztcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBwYXJlbnROb2RlIG9yIHRoZSBob3N0IG9mIHRoZSBlbGVtZW50XG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEByZXR1cm5zIHtFbGVtZW50fSBwYXJlbnRcbiAqL1xuZnVuY3Rpb24gZ2V0UGFyZW50Tm9kZShlbGVtZW50KSB7XG4gIGlmIChlbGVtZW50Lm5vZGVOYW1lID09PSAnSFRNTCcpIHtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuICByZXR1cm4gZWxlbWVudC5wYXJlbnROb2RlIHx8IGVsZW1lbnQuaG9zdDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBzY3JvbGxpbmcgcGFyZW50IG9mIHRoZSBnaXZlbiBlbGVtZW50XG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEByZXR1cm5zIHtFbGVtZW50fSBzY3JvbGwgcGFyZW50XG4gKi9cbmZ1bmN0aW9uIGdldFNjcm9sbFBhcmVudChlbGVtZW50KSB7XG4gIC8vIFJldHVybiBib2R5LCBgZ2V0U2Nyb2xsYCB3aWxsIHRha2UgY2FyZSB0byBnZXQgdGhlIGNvcnJlY3QgYHNjcm9sbFRvcGAgZnJvbSBpdFxuICBpZiAoIWVsZW1lbnQpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuYm9keTtcbiAgfVxuXG4gIHN3aXRjaCAoZWxlbWVudC5ub2RlTmFtZSkge1xuICAgIGNhc2UgJ0hUTUwnOlxuICAgIGNhc2UgJ0JPRFknOlxuICAgICAgcmV0dXJuIGVsZW1lbnQub3duZXJEb2N1bWVudC5ib2R5O1xuICAgIGNhc2UgJyNkb2N1bWVudCc6XG4gICAgICByZXR1cm4gZWxlbWVudC5ib2R5O1xuICB9XG5cbiAgLy8gRmlyZWZveCB3YW50IHVzIHRvIGNoZWNrIGAteGAgYW5kIGAteWAgdmFyaWF0aW9ucyBhcyB3ZWxsXG5cbiAgdmFyIF9nZXRTdHlsZUNvbXB1dGVkUHJvcCA9IGdldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eShlbGVtZW50KSxcbiAgICAgIG92ZXJmbG93ID0gX2dldFN0eWxlQ29tcHV0ZWRQcm9wLm92ZXJmbG93LFxuICAgICAgb3ZlcmZsb3dYID0gX2dldFN0eWxlQ29tcHV0ZWRQcm9wLm92ZXJmbG93WCxcbiAgICAgIG92ZXJmbG93WSA9IF9nZXRTdHlsZUNvbXB1dGVkUHJvcC5vdmVyZmxvd1k7XG5cbiAgaWYgKC8oYXV0b3xzY3JvbGx8b3ZlcmxheSkvLnRlc3Qob3ZlcmZsb3cgKyBvdmVyZmxvd1kgKyBvdmVyZmxvd1gpKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cblxuICByZXR1cm4gZ2V0U2Nyb2xsUGFyZW50KGdldFBhcmVudE5vZGUoZWxlbWVudCkpO1xufVxuXG52YXIgaXNJRTExID0gaXNCcm93c2VyICYmICEhKHdpbmRvdy5NU0lucHV0TWV0aG9kQ29udGV4dCAmJiBkb2N1bWVudC5kb2N1bWVudE1vZGUpO1xudmFyIGlzSUUxMCA9IGlzQnJvd3NlciAmJiAvTVNJRSAxMC8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcblxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIHRoZSBicm93c2VyIGlzIEludGVybmV0IEV4cGxvcmVyXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcGFyYW0ge051bWJlcn0gdmVyc2lvbiB0byBjaGVja1xuICogQHJldHVybnMge0Jvb2xlYW59IGlzSUVcbiAqL1xuZnVuY3Rpb24gaXNJRSh2ZXJzaW9uKSB7XG4gIGlmICh2ZXJzaW9uID09PSAxMSkge1xuICAgIHJldHVybiBpc0lFMTE7XG4gIH1cbiAgaWYgKHZlcnNpb24gPT09IDEwKSB7XG4gICAgcmV0dXJuIGlzSUUxMDtcbiAgfVxuICByZXR1cm4gaXNJRTExIHx8IGlzSUUxMDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBvZmZzZXQgcGFyZW50IG9mIHRoZSBnaXZlbiBlbGVtZW50XG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEByZXR1cm5zIHtFbGVtZW50fSBvZmZzZXQgcGFyZW50XG4gKi9cbmZ1bmN0aW9uIGdldE9mZnNldFBhcmVudChlbGVtZW50KSB7XG4gIGlmICghZWxlbWVudCkge1xuICAgIHJldHVybiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gIH1cblxuICB2YXIgbm9PZmZzZXRQYXJlbnQgPSBpc0lFKDEwKSA/IGRvY3VtZW50LmJvZHkgOiBudWxsO1xuXG4gIC8vIE5PVEU6IDEgRE9NIGFjY2VzcyBoZXJlXG4gIHZhciBvZmZzZXRQYXJlbnQgPSBlbGVtZW50Lm9mZnNldFBhcmVudCB8fCBudWxsO1xuICAvLyBTa2lwIGhpZGRlbiBlbGVtZW50cyB3aGljaCBkb24ndCBoYXZlIGFuIG9mZnNldFBhcmVudFxuICB3aGlsZSAob2Zmc2V0UGFyZW50ID09PSBub09mZnNldFBhcmVudCAmJiBlbGVtZW50Lm5leHRFbGVtZW50U2libGluZykge1xuICAgIG9mZnNldFBhcmVudCA9IChlbGVtZW50ID0gZWxlbWVudC5uZXh0RWxlbWVudFNpYmxpbmcpLm9mZnNldFBhcmVudDtcbiAgfVxuXG4gIHZhciBub2RlTmFtZSA9IG9mZnNldFBhcmVudCAmJiBvZmZzZXRQYXJlbnQubm9kZU5hbWU7XG5cbiAgaWYgKCFub2RlTmFtZSB8fCBub2RlTmFtZSA9PT0gJ0JPRFknIHx8IG5vZGVOYW1lID09PSAnSFRNTCcpIHtcbiAgICByZXR1cm4gZWxlbWVudCA/IGVsZW1lbnQub3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgOiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gIH1cblxuICAvLyAub2Zmc2V0UGFyZW50IHdpbGwgcmV0dXJuIHRoZSBjbG9zZXN0IFRILCBURCBvciBUQUJMRSBpbiBjYXNlXG4gIC8vIG5vIG9mZnNldFBhcmVudCBpcyBwcmVzZW50LCBJIGhhdGUgdGhpcyBqb2IuLi5cbiAgaWYgKFsnVEgnLCAnVEQnLCAnVEFCTEUnXS5pbmRleE9mKG9mZnNldFBhcmVudC5ub2RlTmFtZSkgIT09IC0xICYmIGdldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eShvZmZzZXRQYXJlbnQsICdwb3NpdGlvbicpID09PSAnc3RhdGljJykge1xuICAgIHJldHVybiBnZXRPZmZzZXRQYXJlbnQob2Zmc2V0UGFyZW50KTtcbiAgfVxuXG4gIHJldHVybiBvZmZzZXRQYXJlbnQ7XG59XG5cbmZ1bmN0aW9uIGlzT2Zmc2V0Q29udGFpbmVyKGVsZW1lbnQpIHtcbiAgdmFyIG5vZGVOYW1lID0gZWxlbWVudC5ub2RlTmFtZTtcblxuICBpZiAobm9kZU5hbWUgPT09ICdCT0RZJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gbm9kZU5hbWUgPT09ICdIVE1MJyB8fCBnZXRPZmZzZXRQYXJlbnQoZWxlbWVudC5maXJzdEVsZW1lbnRDaGlsZCkgPT09IGVsZW1lbnQ7XG59XG5cbi8qKlxuICogRmluZHMgdGhlIHJvb3Qgbm9kZSAoZG9jdW1lbnQsIHNoYWRvd0RPTSByb290KSBvZiB0aGUgZ2l2ZW4gZWxlbWVudFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtFbGVtZW50fSBub2RlXG4gKiBAcmV0dXJucyB7RWxlbWVudH0gcm9vdCBub2RlXG4gKi9cbmZ1bmN0aW9uIGdldFJvb3Qobm9kZSkge1xuICBpZiAobm9kZS5wYXJlbnROb2RlICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIGdldFJvb3Qobm9kZS5wYXJlbnROb2RlKTtcbiAgfVxuXG4gIHJldHVybiBub2RlO1xufVxuXG4vKipcbiAqIEZpbmRzIHRoZSBvZmZzZXQgcGFyZW50IGNvbW1vbiB0byB0aGUgdHdvIHByb3ZpZGVkIG5vZGVzXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnQxXG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnQyXG4gKiBAcmV0dXJucyB7RWxlbWVudH0gY29tbW9uIG9mZnNldCBwYXJlbnRcbiAqL1xuZnVuY3Rpb24gZmluZENvbW1vbk9mZnNldFBhcmVudChlbGVtZW50MSwgZWxlbWVudDIpIHtcbiAgLy8gVGhpcyBjaGVjayBpcyBuZWVkZWQgdG8gYXZvaWQgZXJyb3JzIGluIGNhc2Ugb25lIG9mIHRoZSBlbGVtZW50cyBpc24ndCBkZWZpbmVkIGZvciBhbnkgcmVhc29uXG4gIGlmICghZWxlbWVudDEgfHwgIWVsZW1lbnQxLm5vZGVUeXBlIHx8ICFlbGVtZW50MiB8fCAhZWxlbWVudDIubm9kZVR5cGUpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICB9XG5cbiAgLy8gSGVyZSB3ZSBtYWtlIHN1cmUgdG8gZ2l2ZSBhcyBcInN0YXJ0XCIgdGhlIGVsZW1lbnQgdGhhdCBjb21lcyBmaXJzdCBpbiB0aGUgRE9NXG4gIHZhciBvcmRlciA9IGVsZW1lbnQxLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKGVsZW1lbnQyKSAmIE5vZGUuRE9DVU1FTlRfUE9TSVRJT05fRk9MTE9XSU5HO1xuICB2YXIgc3RhcnQgPSBvcmRlciA/IGVsZW1lbnQxIDogZWxlbWVudDI7XG4gIHZhciBlbmQgPSBvcmRlciA/IGVsZW1lbnQyIDogZWxlbWVudDE7XG5cbiAgLy8gR2V0IGNvbW1vbiBhbmNlc3RvciBjb250YWluZXJcbiAgdmFyIHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgcmFuZ2Uuc2V0U3RhcnQoc3RhcnQsIDApO1xuICByYW5nZS5zZXRFbmQoZW5kLCAwKTtcbiAgdmFyIGNvbW1vbkFuY2VzdG9yQ29udGFpbmVyID0gcmFuZ2UuY29tbW9uQW5jZXN0b3JDb250YWluZXI7XG5cbiAgLy8gQm90aCBub2RlcyBhcmUgaW5zaWRlICNkb2N1bWVudFxuXG4gIGlmIChlbGVtZW50MSAhPT0gY29tbW9uQW5jZXN0b3JDb250YWluZXIgJiYgZWxlbWVudDIgIT09IGNvbW1vbkFuY2VzdG9yQ29udGFpbmVyIHx8IHN0YXJ0LmNvbnRhaW5zKGVuZCkpIHtcbiAgICBpZiAoaXNPZmZzZXRDb250YWluZXIoY29tbW9uQW5jZXN0b3JDb250YWluZXIpKSB7XG4gICAgICByZXR1cm4gY29tbW9uQW5jZXN0b3JDb250YWluZXI7XG4gICAgfVxuXG4gICAgcmV0dXJuIGdldE9mZnNldFBhcmVudChjb21tb25BbmNlc3RvckNvbnRhaW5lcik7XG4gIH1cblxuICAvLyBvbmUgb2YgdGhlIG5vZGVzIGlzIGluc2lkZSBzaGFkb3dET00sIGZpbmQgd2hpY2ggb25lXG4gIHZhciBlbGVtZW50MXJvb3QgPSBnZXRSb290KGVsZW1lbnQxKTtcbiAgaWYgKGVsZW1lbnQxcm9vdC5ob3N0KSB7XG4gICAgcmV0dXJuIGZpbmRDb21tb25PZmZzZXRQYXJlbnQoZWxlbWVudDFyb290Lmhvc3QsIGVsZW1lbnQyKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmluZENvbW1vbk9mZnNldFBhcmVudChlbGVtZW50MSwgZ2V0Um9vdChlbGVtZW50MikuaG9zdCk7XG4gIH1cbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBzY3JvbGwgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQgaW4gdGhlIGdpdmVuIHNpZGUgKHRvcCBhbmQgbGVmdClcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gZWxlbWVudFxuICogQGFyZ3VtZW50IHtTdHJpbmd9IHNpZGUgYHRvcGAgb3IgYGxlZnRgXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBhbW91bnQgb2Ygc2Nyb2xsZWQgcGl4ZWxzXG4gKi9cbmZ1bmN0aW9uIGdldFNjcm9sbChlbGVtZW50KSB7XG4gIHZhciBzaWRlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAndG9wJztcblxuICB2YXIgdXBwZXJTaWRlID0gc2lkZSA9PT0gJ3RvcCcgPyAnc2Nyb2xsVG9wJyA6ICdzY3JvbGxMZWZ0JztcbiAgdmFyIG5vZGVOYW1lID0gZWxlbWVudC5ub2RlTmFtZTtcblxuICBpZiAobm9kZU5hbWUgPT09ICdCT0RZJyB8fCBub2RlTmFtZSA9PT0gJ0hUTUwnKSB7XG4gICAgdmFyIGh0bWwgPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgIHZhciBzY3JvbGxpbmdFbGVtZW50ID0gZWxlbWVudC5vd25lckRvY3VtZW50LnNjcm9sbGluZ0VsZW1lbnQgfHwgaHRtbDtcbiAgICByZXR1cm4gc2Nyb2xsaW5nRWxlbWVudFt1cHBlclNpZGVdO1xuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnRbdXBwZXJTaWRlXTtcbn1cblxuLypcbiAqIFN1bSBvciBzdWJ0cmFjdCB0aGUgZWxlbWVudCBzY3JvbGwgdmFsdWVzIChsZWZ0IGFuZCB0b3ApIGZyb20gYSBnaXZlbiByZWN0IG9iamVjdFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHBhcmFtIHtPYmplY3R9IHJlY3QgLSBSZWN0IG9iamVjdCB5b3Ugd2FudCB0byBjaGFuZ2VcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgLSBUaGUgZWxlbWVudCBmcm9tIHRoZSBmdW5jdGlvbiByZWFkcyB0aGUgc2Nyb2xsIHZhbHVlc1xuICogQHBhcmFtIHtCb29sZWFufSBzdWJ0cmFjdCAtIHNldCB0byB0cnVlIGlmIHlvdSB3YW50IHRvIHN1YnRyYWN0IHRoZSBzY3JvbGwgdmFsdWVzXG4gKiBAcmV0dXJuIHtPYmplY3R9IHJlY3QgLSBUaGUgbW9kaWZpZXIgcmVjdCBvYmplY3RcbiAqL1xuZnVuY3Rpb24gaW5jbHVkZVNjcm9sbChyZWN0LCBlbGVtZW50KSB7XG4gIHZhciBzdWJ0cmFjdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogZmFsc2U7XG5cbiAgdmFyIHNjcm9sbFRvcCA9IGdldFNjcm9sbChlbGVtZW50LCAndG9wJyk7XG4gIHZhciBzY3JvbGxMZWZ0ID0gZ2V0U2Nyb2xsKGVsZW1lbnQsICdsZWZ0Jyk7XG4gIHZhciBtb2RpZmllciA9IHN1YnRyYWN0ID8gLTEgOiAxO1xuICByZWN0LnRvcCArPSBzY3JvbGxUb3AgKiBtb2RpZmllcjtcbiAgcmVjdC5ib3R0b20gKz0gc2Nyb2xsVG9wICogbW9kaWZpZXI7XG4gIHJlY3QubGVmdCArPSBzY3JvbGxMZWZ0ICogbW9kaWZpZXI7XG4gIHJlY3QucmlnaHQgKz0gc2Nyb2xsTGVmdCAqIG1vZGlmaWVyO1xuICByZXR1cm4gcmVjdDtcbn1cblxuLypcbiAqIEhlbHBlciB0byBkZXRlY3QgYm9yZGVycyBvZiBhIGdpdmVuIGVsZW1lbnRcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBwYXJhbSB7Q1NTU3R5bGVEZWNsYXJhdGlvbn0gc3R5bGVzXG4gKiBSZXN1bHQgb2YgYGdldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eWAgb24gdGhlIGdpdmVuIGVsZW1lbnRcbiAqIEBwYXJhbSB7U3RyaW5nfSBheGlzIC0gYHhgIG9yIGB5YFxuICogQHJldHVybiB7bnVtYmVyfSBib3JkZXJzIC0gVGhlIGJvcmRlcnMgc2l6ZSBvZiB0aGUgZ2l2ZW4gYXhpc1xuICovXG5cbmZ1bmN0aW9uIGdldEJvcmRlcnNTaXplKHN0eWxlcywgYXhpcykge1xuICB2YXIgc2lkZUEgPSBheGlzID09PSAneCcgPyAnTGVmdCcgOiAnVG9wJztcbiAgdmFyIHNpZGVCID0gc2lkZUEgPT09ICdMZWZ0JyA/ICdSaWdodCcgOiAnQm90dG9tJztcblxuICByZXR1cm4gcGFyc2VGbG9hdChzdHlsZXNbJ2JvcmRlcicgKyBzaWRlQSArICdXaWR0aCddLCAxMCkgKyBwYXJzZUZsb2F0KHN0eWxlc1snYm9yZGVyJyArIHNpZGVCICsgJ1dpZHRoJ10sIDEwKTtcbn1cblxuZnVuY3Rpb24gZ2V0U2l6ZShheGlzLCBib2R5LCBodG1sLCBjb21wdXRlZFN0eWxlKSB7XG4gIHJldHVybiBNYXRoLm1heChib2R5WydvZmZzZXQnICsgYXhpc10sIGJvZHlbJ3Njcm9sbCcgKyBheGlzXSwgaHRtbFsnY2xpZW50JyArIGF4aXNdLCBodG1sWydvZmZzZXQnICsgYXhpc10sIGh0bWxbJ3Njcm9sbCcgKyBheGlzXSwgaXNJRSgxMCkgPyBwYXJzZUludChodG1sWydvZmZzZXQnICsgYXhpc10pICsgcGFyc2VJbnQoY29tcHV0ZWRTdHlsZVsnbWFyZ2luJyArIChheGlzID09PSAnSGVpZ2h0JyA/ICdUb3AnIDogJ0xlZnQnKV0pICsgcGFyc2VJbnQoY29tcHV0ZWRTdHlsZVsnbWFyZ2luJyArIChheGlzID09PSAnSGVpZ2h0JyA/ICdCb3R0b20nIDogJ1JpZ2h0JyldKSA6IDApO1xufVxuXG5mdW5jdGlvbiBnZXRXaW5kb3dTaXplcyhkb2N1bWVudCkge1xuICB2YXIgYm9keSA9IGRvY3VtZW50LmJvZHk7XG4gIHZhciBodG1sID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICB2YXIgY29tcHV0ZWRTdHlsZSA9IGlzSUUoMTApICYmIGdldENvbXB1dGVkU3R5bGUoaHRtbCk7XG5cbiAgcmV0dXJuIHtcbiAgICBoZWlnaHQ6IGdldFNpemUoJ0hlaWdodCcsIGJvZHksIGh0bWwsIGNvbXB1dGVkU3R5bGUpLFxuICAgIHdpZHRoOiBnZXRTaXplKCdXaWR0aCcsIGJvZHksIGh0bWwsIGNvbXB1dGVkU3R5bGUpXG4gIH07XG59XG5cbnZhciBjbGFzc0NhbGxDaGVjayA9IGZ1bmN0aW9uIChpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59O1xuXG52YXIgY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gICAgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgICBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgICByZXR1cm4gQ29uc3RydWN0b3I7XG4gIH07XG59KCk7XG5cblxuXG5cblxudmFyIGRlZmluZVByb3BlcnR5ID0gZnVuY3Rpb24gKG9iaiwga2V5LCB2YWx1ZSkge1xuICBpZiAoa2V5IGluIG9iaikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiBvYmo7XG59O1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldO1xuXG4gICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufTtcblxuLyoqXG4gKiBHaXZlbiBlbGVtZW50IG9mZnNldHMsIGdlbmVyYXRlIGFuIG91dHB1dCBzaW1pbGFyIHRvIGdldEJvdW5kaW5nQ2xpZW50UmVjdFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IG9mZnNldHNcbiAqIEByZXR1cm5zIHtPYmplY3R9IENsaWVudFJlY3QgbGlrZSBvdXRwdXRcbiAqL1xuZnVuY3Rpb24gZ2V0Q2xpZW50UmVjdChvZmZzZXRzKSB7XG4gIHJldHVybiBfZXh0ZW5kcyh7fSwgb2Zmc2V0cywge1xuICAgIHJpZ2h0OiBvZmZzZXRzLmxlZnQgKyBvZmZzZXRzLndpZHRoLFxuICAgIGJvdHRvbTogb2Zmc2V0cy50b3AgKyBvZmZzZXRzLmhlaWdodFxuICB9KTtcbn1cblxuLyoqXG4gKiBHZXQgYm91bmRpbmcgY2xpZW50IHJlY3Qgb2YgZ2l2ZW4gZWxlbWVudFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICogQHJldHVybiB7T2JqZWN0fSBjbGllbnQgcmVjdFxuICovXG5mdW5jdGlvbiBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZWxlbWVudCkge1xuICB2YXIgcmVjdCA9IHt9O1xuXG4gIC8vIElFMTAgMTAgRklYOiBQbGVhc2UsIGRvbid0IGFzaywgdGhlIGVsZW1lbnQgaXNuJ3RcbiAgLy8gY29uc2lkZXJlZCBpbiBET00gaW4gc29tZSBjaXJjdW1zdGFuY2VzLi4uXG4gIC8vIFRoaXMgaXNuJ3QgcmVwcm9kdWNpYmxlIGluIElFMTAgY29tcGF0aWJpbGl0eSBtb2RlIG9mIElFMTFcbiAgdHJ5IHtcbiAgICBpZiAoaXNJRSgxMCkpIHtcbiAgICAgIHJlY3QgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgdmFyIHNjcm9sbFRvcCA9IGdldFNjcm9sbChlbGVtZW50LCAndG9wJyk7XG4gICAgICB2YXIgc2Nyb2xsTGVmdCA9IGdldFNjcm9sbChlbGVtZW50LCAnbGVmdCcpO1xuICAgICAgcmVjdC50b3AgKz0gc2Nyb2xsVG9wO1xuICAgICAgcmVjdC5sZWZ0ICs9IHNjcm9sbExlZnQ7XG4gICAgICByZWN0LmJvdHRvbSArPSBzY3JvbGxUb3A7XG4gICAgICByZWN0LnJpZ2h0ICs9IHNjcm9sbExlZnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlY3QgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge31cblxuICB2YXIgcmVzdWx0ID0ge1xuICAgIGxlZnQ6IHJlY3QubGVmdCxcbiAgICB0b3A6IHJlY3QudG9wLFxuICAgIHdpZHRoOiByZWN0LnJpZ2h0IC0gcmVjdC5sZWZ0LFxuICAgIGhlaWdodDogcmVjdC5ib3R0b20gLSByZWN0LnRvcFxuICB9O1xuXG4gIC8vIHN1YnRyYWN0IHNjcm9sbGJhciBzaXplIGZyb20gc2l6ZXNcbiAgdmFyIHNpemVzID0gZWxlbWVudC5ub2RlTmFtZSA9PT0gJ0hUTUwnID8gZ2V0V2luZG93U2l6ZXMoZWxlbWVudC5vd25lckRvY3VtZW50KSA6IHt9O1xuICB2YXIgd2lkdGggPSBzaXplcy53aWR0aCB8fCBlbGVtZW50LmNsaWVudFdpZHRoIHx8IHJlc3VsdC5yaWdodCAtIHJlc3VsdC5sZWZ0O1xuICB2YXIgaGVpZ2h0ID0gc2l6ZXMuaGVpZ2h0IHx8IGVsZW1lbnQuY2xpZW50SGVpZ2h0IHx8IHJlc3VsdC5ib3R0b20gLSByZXN1bHQudG9wO1xuXG4gIHZhciBob3JpelNjcm9sbGJhciA9IGVsZW1lbnQub2Zmc2V0V2lkdGggLSB3aWR0aDtcbiAgdmFyIHZlcnRTY3JvbGxiYXIgPSBlbGVtZW50Lm9mZnNldEhlaWdodCAtIGhlaWdodDtcblxuICAvLyBpZiBhbiBoeXBvdGhldGljYWwgc2Nyb2xsYmFyIGlzIGRldGVjdGVkLCB3ZSBtdXN0IGJlIHN1cmUgaXQncyBub3QgYSBgYm9yZGVyYFxuICAvLyB3ZSBtYWtlIHRoaXMgY2hlY2sgY29uZGl0aW9uYWwgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnNcbiAgaWYgKGhvcml6U2Nyb2xsYmFyIHx8IHZlcnRTY3JvbGxiYXIpIHtcbiAgICB2YXIgc3R5bGVzID0gZ2V0U3R5bGVDb21wdXRlZFByb3BlcnR5KGVsZW1lbnQpO1xuICAgIGhvcml6U2Nyb2xsYmFyIC09IGdldEJvcmRlcnNTaXplKHN0eWxlcywgJ3gnKTtcbiAgICB2ZXJ0U2Nyb2xsYmFyIC09IGdldEJvcmRlcnNTaXplKHN0eWxlcywgJ3knKTtcblxuICAgIHJlc3VsdC53aWR0aCAtPSBob3JpelNjcm9sbGJhcjtcbiAgICByZXN1bHQuaGVpZ2h0IC09IHZlcnRTY3JvbGxiYXI7XG4gIH1cblxuICByZXR1cm4gZ2V0Q2xpZW50UmVjdChyZXN1bHQpO1xufVxuXG5mdW5jdGlvbiBnZXRPZmZzZXRSZWN0UmVsYXRpdmVUb0FyYml0cmFyeU5vZGUoY2hpbGRyZW4sIHBhcmVudCkge1xuICB2YXIgZml4ZWRQb3NpdGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogZmFsc2U7XG5cbiAgdmFyIGlzSUUxMCA9IGlzSUUoMTApO1xuICB2YXIgaXNIVE1MID0gcGFyZW50Lm5vZGVOYW1lID09PSAnSFRNTCc7XG4gIHZhciBjaGlsZHJlblJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QoY2hpbGRyZW4pO1xuICB2YXIgcGFyZW50UmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChwYXJlbnQpO1xuICB2YXIgc2Nyb2xsUGFyZW50ID0gZ2V0U2Nyb2xsUGFyZW50KGNoaWxkcmVuKTtcblxuICB2YXIgc3R5bGVzID0gZ2V0U3R5bGVDb21wdXRlZFByb3BlcnR5KHBhcmVudCk7XG4gIHZhciBib3JkZXJUb3BXaWR0aCA9IHBhcnNlRmxvYXQoc3R5bGVzLmJvcmRlclRvcFdpZHRoLCAxMCk7XG4gIHZhciBib3JkZXJMZWZ0V2lkdGggPSBwYXJzZUZsb2F0KHN0eWxlcy5ib3JkZXJMZWZ0V2lkdGgsIDEwKTtcblxuICAvLyBJbiBjYXNlcyB3aGVyZSB0aGUgcGFyZW50IGlzIGZpeGVkLCB3ZSBtdXN0IGlnbm9yZSBuZWdhdGl2ZSBzY3JvbGwgaW4gb2Zmc2V0IGNhbGNcbiAgaWYgKGZpeGVkUG9zaXRpb24gJiYgaXNIVE1MKSB7XG4gICAgcGFyZW50UmVjdC50b3AgPSBNYXRoLm1heChwYXJlbnRSZWN0LnRvcCwgMCk7XG4gICAgcGFyZW50UmVjdC5sZWZ0ID0gTWF0aC5tYXgocGFyZW50UmVjdC5sZWZ0LCAwKTtcbiAgfVxuICB2YXIgb2Zmc2V0cyA9IGdldENsaWVudFJlY3Qoe1xuICAgIHRvcDogY2hpbGRyZW5SZWN0LnRvcCAtIHBhcmVudFJlY3QudG9wIC0gYm9yZGVyVG9wV2lkdGgsXG4gICAgbGVmdDogY2hpbGRyZW5SZWN0LmxlZnQgLSBwYXJlbnRSZWN0LmxlZnQgLSBib3JkZXJMZWZ0V2lkdGgsXG4gICAgd2lkdGg6IGNoaWxkcmVuUmVjdC53aWR0aCxcbiAgICBoZWlnaHQ6IGNoaWxkcmVuUmVjdC5oZWlnaHRcbiAgfSk7XG4gIG9mZnNldHMubWFyZ2luVG9wID0gMDtcbiAgb2Zmc2V0cy5tYXJnaW5MZWZ0ID0gMDtcblxuICAvLyBTdWJ0cmFjdCBtYXJnaW5zIG9mIGRvY3VtZW50RWxlbWVudCBpbiBjYXNlIGl0J3MgYmVpbmcgdXNlZCBhcyBwYXJlbnRcbiAgLy8gd2UgZG8gdGhpcyBvbmx5IG9uIEhUTUwgYmVjYXVzZSBpdCdzIHRoZSBvbmx5IGVsZW1lbnQgdGhhdCBiZWhhdmVzXG4gIC8vIGRpZmZlcmVudGx5IHdoZW4gbWFyZ2lucyBhcmUgYXBwbGllZCB0byBpdC4gVGhlIG1hcmdpbnMgYXJlIGluY2x1ZGVkIGluXG4gIC8vIHRoZSBib3ggb2YgdGhlIGRvY3VtZW50RWxlbWVudCwgaW4gdGhlIG90aGVyIGNhc2VzIG5vdC5cbiAgaWYgKCFpc0lFMTAgJiYgaXNIVE1MKSB7XG4gICAgdmFyIG1hcmdpblRvcCA9IHBhcnNlRmxvYXQoc3R5bGVzLm1hcmdpblRvcCwgMTApO1xuICAgIHZhciBtYXJnaW5MZWZ0ID0gcGFyc2VGbG9hdChzdHlsZXMubWFyZ2luTGVmdCwgMTApO1xuXG4gICAgb2Zmc2V0cy50b3AgLT0gYm9yZGVyVG9wV2lkdGggLSBtYXJnaW5Ub3A7XG4gICAgb2Zmc2V0cy5ib3R0b20gLT0gYm9yZGVyVG9wV2lkdGggLSBtYXJnaW5Ub3A7XG4gICAgb2Zmc2V0cy5sZWZ0IC09IGJvcmRlckxlZnRXaWR0aCAtIG1hcmdpbkxlZnQ7XG4gICAgb2Zmc2V0cy5yaWdodCAtPSBib3JkZXJMZWZ0V2lkdGggLSBtYXJnaW5MZWZ0O1xuXG4gICAgLy8gQXR0YWNoIG1hcmdpblRvcCBhbmQgbWFyZ2luTGVmdCBiZWNhdXNlIGluIHNvbWUgY2lyY3Vtc3RhbmNlcyB3ZSBtYXkgbmVlZCB0aGVtXG4gICAgb2Zmc2V0cy5tYXJnaW5Ub3AgPSBtYXJnaW5Ub3A7XG4gICAgb2Zmc2V0cy5tYXJnaW5MZWZ0ID0gbWFyZ2luTGVmdDtcbiAgfVxuXG4gIGlmIChpc0lFMTAgJiYgIWZpeGVkUG9zaXRpb24gPyBwYXJlbnQuY29udGFpbnMoc2Nyb2xsUGFyZW50KSA6IHBhcmVudCA9PT0gc2Nyb2xsUGFyZW50ICYmIHNjcm9sbFBhcmVudC5ub2RlTmFtZSAhPT0gJ0JPRFknKSB7XG4gICAgb2Zmc2V0cyA9IGluY2x1ZGVTY3JvbGwob2Zmc2V0cywgcGFyZW50KTtcbiAgfVxuXG4gIHJldHVybiBvZmZzZXRzO1xufVxuXG5mdW5jdGlvbiBnZXRWaWV3cG9ydE9mZnNldFJlY3RSZWxhdGl2ZVRvQXJ0Yml0cmFyeU5vZGUoZWxlbWVudCkge1xuICB2YXIgZXhjbHVkZVNjcm9sbCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XG5cbiAgdmFyIGh0bWwgPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICB2YXIgcmVsYXRpdmVPZmZzZXQgPSBnZXRPZmZzZXRSZWN0UmVsYXRpdmVUb0FyYml0cmFyeU5vZGUoZWxlbWVudCwgaHRtbCk7XG4gIHZhciB3aWR0aCA9IE1hdGgubWF4KGh0bWwuY2xpZW50V2lkdGgsIHdpbmRvdy5pbm5lcldpZHRoIHx8IDApO1xuICB2YXIgaGVpZ2h0ID0gTWF0aC5tYXgoaHRtbC5jbGllbnRIZWlnaHQsIHdpbmRvdy5pbm5lckhlaWdodCB8fCAwKTtcblxuICB2YXIgc2Nyb2xsVG9wID0gIWV4Y2x1ZGVTY3JvbGwgPyBnZXRTY3JvbGwoaHRtbCkgOiAwO1xuICB2YXIgc2Nyb2xsTGVmdCA9ICFleGNsdWRlU2Nyb2xsID8gZ2V0U2Nyb2xsKGh0bWwsICdsZWZ0JykgOiAwO1xuXG4gIHZhciBvZmZzZXQgPSB7XG4gICAgdG9wOiBzY3JvbGxUb3AgLSByZWxhdGl2ZU9mZnNldC50b3AgKyByZWxhdGl2ZU9mZnNldC5tYXJnaW5Ub3AsXG4gICAgbGVmdDogc2Nyb2xsTGVmdCAtIHJlbGF0aXZlT2Zmc2V0LmxlZnQgKyByZWxhdGl2ZU9mZnNldC5tYXJnaW5MZWZ0LFxuICAgIHdpZHRoOiB3aWR0aCxcbiAgICBoZWlnaHQ6IGhlaWdodFxuICB9O1xuXG4gIHJldHVybiBnZXRDbGllbnRSZWN0KG9mZnNldCk7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGdpdmVuIGVsZW1lbnQgaXMgZml4ZWQgb3IgaXMgaW5zaWRlIGEgZml4ZWQgcGFyZW50XG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gY3VzdG9tQ29udGFpbmVyXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gYW5zd2VyIHRvIFwiaXNGaXhlZD9cIlxuICovXG5mdW5jdGlvbiBpc0ZpeGVkKGVsZW1lbnQpIHtcbiAgdmFyIG5vZGVOYW1lID0gZWxlbWVudC5ub2RlTmFtZTtcbiAgaWYgKG5vZGVOYW1lID09PSAnQk9EWScgfHwgbm9kZU5hbWUgPT09ICdIVE1MJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoZ2V0U3R5bGVDb21wdXRlZFByb3BlcnR5KGVsZW1lbnQsICdwb3NpdGlvbicpID09PSAnZml4ZWQnKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGlzRml4ZWQoZ2V0UGFyZW50Tm9kZShlbGVtZW50KSk7XG59XG5cbi8qKlxuICogRmluZHMgdGhlIGZpcnN0IHBhcmVudCBvZiBhbiBlbGVtZW50IHRoYXQgaGFzIGEgdHJhbnNmb3JtZWQgcHJvcGVydHkgZGVmaW5lZFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcmV0dXJucyB7RWxlbWVudH0gZmlyc3QgdHJhbnNmb3JtZWQgcGFyZW50IG9yIGRvY3VtZW50RWxlbWVudFxuICovXG5cbmZ1bmN0aW9uIGdldEZpeGVkUG9zaXRpb25PZmZzZXRQYXJlbnQoZWxlbWVudCkge1xuICAvLyBUaGlzIGNoZWNrIGlzIG5lZWRlZCB0byBhdm9pZCBlcnJvcnMgaW4gY2FzZSBvbmUgb2YgdGhlIGVsZW1lbnRzIGlzbid0IGRlZmluZWQgZm9yIGFueSByZWFzb25cbiAgaWYgKCFlbGVtZW50IHx8ICFlbGVtZW50LnBhcmVudEVsZW1lbnQgfHwgaXNJRSgpKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgfVxuICB2YXIgZWwgPSBlbGVtZW50LnBhcmVudEVsZW1lbnQ7XG4gIHdoaWxlIChlbCAmJiBnZXRTdHlsZUNvbXB1dGVkUHJvcGVydHkoZWwsICd0cmFuc2Zvcm0nKSA9PT0gJ25vbmUnKSB7XG4gICAgZWwgPSBlbC5wYXJlbnRFbGVtZW50O1xuICB9XG4gIHJldHVybiBlbCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG59XG5cbi8qKlxuICogQ29tcHV0ZWQgdGhlIGJvdW5kYXJpZXMgbGltaXRzIGFuZCByZXR1cm4gdGhlbVxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcG9wcGVyXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSByZWZlcmVuY2VcbiAqIEBwYXJhbSB7bnVtYmVyfSBwYWRkaW5nXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBib3VuZGFyaWVzRWxlbWVudCAtIEVsZW1lbnQgdXNlZCB0byBkZWZpbmUgdGhlIGJvdW5kYXJpZXNcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gZml4ZWRQb3NpdGlvbiAtIElzIGluIGZpeGVkIHBvc2l0aW9uIG1vZGVcbiAqIEByZXR1cm5zIHtPYmplY3R9IENvb3JkaW5hdGVzIG9mIHRoZSBib3VuZGFyaWVzXG4gKi9cbmZ1bmN0aW9uIGdldEJvdW5kYXJpZXMocG9wcGVyLCByZWZlcmVuY2UsIHBhZGRpbmcsIGJvdW5kYXJpZXNFbGVtZW50KSB7XG4gIHZhciBmaXhlZFBvc2l0aW9uID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgYXJndW1lbnRzWzRdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNF0gOiBmYWxzZTtcblxuICAvLyBOT1RFOiAxIERPTSBhY2Nlc3MgaGVyZVxuXG4gIHZhciBib3VuZGFyaWVzID0geyB0b3A6IDAsIGxlZnQ6IDAgfTtcbiAgdmFyIG9mZnNldFBhcmVudCA9IGZpeGVkUG9zaXRpb24gPyBnZXRGaXhlZFBvc2l0aW9uT2Zmc2V0UGFyZW50KHBvcHBlcikgOiBmaW5kQ29tbW9uT2Zmc2V0UGFyZW50KHBvcHBlciwgcmVmZXJlbmNlKTtcblxuICAvLyBIYW5kbGUgdmlld3BvcnQgY2FzZVxuICBpZiAoYm91bmRhcmllc0VsZW1lbnQgPT09ICd2aWV3cG9ydCcpIHtcbiAgICBib3VuZGFyaWVzID0gZ2V0Vmlld3BvcnRPZmZzZXRSZWN0UmVsYXRpdmVUb0FydGJpdHJhcnlOb2RlKG9mZnNldFBhcmVudCwgZml4ZWRQb3NpdGlvbik7XG4gIH0gZWxzZSB7XG4gICAgLy8gSGFuZGxlIG90aGVyIGNhc2VzIGJhc2VkIG9uIERPTSBlbGVtZW50IHVzZWQgYXMgYm91bmRhcmllc1xuICAgIHZhciBib3VuZGFyaWVzTm9kZSA9IHZvaWQgMDtcbiAgICBpZiAoYm91bmRhcmllc0VsZW1lbnQgPT09ICdzY3JvbGxQYXJlbnQnKSB7XG4gICAgICBib3VuZGFyaWVzTm9kZSA9IGdldFNjcm9sbFBhcmVudChnZXRQYXJlbnROb2RlKHJlZmVyZW5jZSkpO1xuICAgICAgaWYgKGJvdW5kYXJpZXNOb2RlLm5vZGVOYW1lID09PSAnQk9EWScpIHtcbiAgICAgICAgYm91bmRhcmllc05vZGUgPSBwb3BwZXIub3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChib3VuZGFyaWVzRWxlbWVudCA9PT0gJ3dpbmRvdycpIHtcbiAgICAgIGJvdW5kYXJpZXNOb2RlID0gcG9wcGVyLm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgIH0gZWxzZSB7XG4gICAgICBib3VuZGFyaWVzTm9kZSA9IGJvdW5kYXJpZXNFbGVtZW50O1xuICAgIH1cblxuICAgIHZhciBvZmZzZXRzID0gZ2V0T2Zmc2V0UmVjdFJlbGF0aXZlVG9BcmJpdHJhcnlOb2RlKGJvdW5kYXJpZXNOb2RlLCBvZmZzZXRQYXJlbnQsIGZpeGVkUG9zaXRpb24pO1xuXG4gICAgLy8gSW4gY2FzZSBvZiBIVE1MLCB3ZSBuZWVkIGEgZGlmZmVyZW50IGNvbXB1dGF0aW9uXG4gICAgaWYgKGJvdW5kYXJpZXNOb2RlLm5vZGVOYW1lID09PSAnSFRNTCcgJiYgIWlzRml4ZWQob2Zmc2V0UGFyZW50KSkge1xuICAgICAgdmFyIF9nZXRXaW5kb3dTaXplcyA9IGdldFdpbmRvd1NpemVzKHBvcHBlci5vd25lckRvY3VtZW50KSxcbiAgICAgICAgICBoZWlnaHQgPSBfZ2V0V2luZG93U2l6ZXMuaGVpZ2h0LFxuICAgICAgICAgIHdpZHRoID0gX2dldFdpbmRvd1NpemVzLndpZHRoO1xuXG4gICAgICBib3VuZGFyaWVzLnRvcCArPSBvZmZzZXRzLnRvcCAtIG9mZnNldHMubWFyZ2luVG9wO1xuICAgICAgYm91bmRhcmllcy5ib3R0b20gPSBoZWlnaHQgKyBvZmZzZXRzLnRvcDtcbiAgICAgIGJvdW5kYXJpZXMubGVmdCArPSBvZmZzZXRzLmxlZnQgLSBvZmZzZXRzLm1hcmdpbkxlZnQ7XG4gICAgICBib3VuZGFyaWVzLnJpZ2h0ID0gd2lkdGggKyBvZmZzZXRzLmxlZnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGZvciBhbGwgdGhlIG90aGVyIERPTSBlbGVtZW50cywgdGhpcyBvbmUgaXMgZ29vZFxuICAgICAgYm91bmRhcmllcyA9IG9mZnNldHM7XG4gICAgfVxuICB9XG5cbiAgLy8gQWRkIHBhZGRpbmdzXG4gIHBhZGRpbmcgPSBwYWRkaW5nIHx8IDA7XG4gIHZhciBpc1BhZGRpbmdOdW1iZXIgPSB0eXBlb2YgcGFkZGluZyA9PT0gJ251bWJlcic7XG4gIGJvdW5kYXJpZXMubGVmdCArPSBpc1BhZGRpbmdOdW1iZXIgPyBwYWRkaW5nIDogcGFkZGluZy5sZWZ0IHx8IDA7XG4gIGJvdW5kYXJpZXMudG9wICs9IGlzUGFkZGluZ051bWJlciA/IHBhZGRpbmcgOiBwYWRkaW5nLnRvcCB8fCAwO1xuICBib3VuZGFyaWVzLnJpZ2h0IC09IGlzUGFkZGluZ051bWJlciA/IHBhZGRpbmcgOiBwYWRkaW5nLnJpZ2h0IHx8IDA7XG4gIGJvdW5kYXJpZXMuYm90dG9tIC09IGlzUGFkZGluZ051bWJlciA/IHBhZGRpbmcgOiBwYWRkaW5nLmJvdHRvbSB8fCAwO1xuXG4gIHJldHVybiBib3VuZGFyaWVzO1xufVxuXG5mdW5jdGlvbiBnZXRBcmVhKF9yZWYpIHtcbiAgdmFyIHdpZHRoID0gX3JlZi53aWR0aCxcbiAgICAgIGhlaWdodCA9IF9yZWYuaGVpZ2h0O1xuXG4gIHJldHVybiB3aWR0aCAqIGhlaWdodDtcbn1cblxuLyoqXG4gKiBVdGlsaXR5IHVzZWQgdG8gdHJhbnNmb3JtIHRoZSBgYXV0b2AgcGxhY2VtZW50IHRvIHRoZSBwbGFjZW1lbnQgd2l0aCBtb3JlXG4gKiBhdmFpbGFibGUgc3BhY2UuXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgdXBkYXRlIG1ldGhvZFxuICogQGFyZ3VtZW50IHtPYmplY3R9IG9wdGlvbnMgLSBNb2RpZmllcnMgY29uZmlndXJhdGlvbiBhbmQgb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdH0gVGhlIGRhdGEgb2JqZWN0LCBwcm9wZXJseSBtb2RpZmllZFxuICovXG5mdW5jdGlvbiBjb21wdXRlQXV0b1BsYWNlbWVudChwbGFjZW1lbnQsIHJlZlJlY3QsIHBvcHBlciwgcmVmZXJlbmNlLCBib3VuZGFyaWVzRWxlbWVudCkge1xuICB2YXIgcGFkZGluZyA9IGFyZ3VtZW50cy5sZW5ndGggPiA1ICYmIGFyZ3VtZW50c1s1XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzVdIDogMDtcblxuICBpZiAocGxhY2VtZW50LmluZGV4T2YoJ2F1dG8nKSA9PT0gLTEpIHtcbiAgICByZXR1cm4gcGxhY2VtZW50O1xuICB9XG5cbiAgdmFyIGJvdW5kYXJpZXMgPSBnZXRCb3VuZGFyaWVzKHBvcHBlciwgcmVmZXJlbmNlLCBwYWRkaW5nLCBib3VuZGFyaWVzRWxlbWVudCk7XG5cbiAgdmFyIHJlY3RzID0ge1xuICAgIHRvcDoge1xuICAgICAgd2lkdGg6IGJvdW5kYXJpZXMud2lkdGgsXG4gICAgICBoZWlnaHQ6IHJlZlJlY3QudG9wIC0gYm91bmRhcmllcy50b3BcbiAgICB9LFxuICAgIHJpZ2h0OiB7XG4gICAgICB3aWR0aDogYm91bmRhcmllcy5yaWdodCAtIHJlZlJlY3QucmlnaHQsXG4gICAgICBoZWlnaHQ6IGJvdW5kYXJpZXMuaGVpZ2h0XG4gICAgfSxcbiAgICBib3R0b206IHtcbiAgICAgIHdpZHRoOiBib3VuZGFyaWVzLndpZHRoLFxuICAgICAgaGVpZ2h0OiBib3VuZGFyaWVzLmJvdHRvbSAtIHJlZlJlY3QuYm90dG9tXG4gICAgfSxcbiAgICBsZWZ0OiB7XG4gICAgICB3aWR0aDogcmVmUmVjdC5sZWZ0IC0gYm91bmRhcmllcy5sZWZ0LFxuICAgICAgaGVpZ2h0OiBib3VuZGFyaWVzLmhlaWdodFxuICAgIH1cbiAgfTtcblxuICB2YXIgc29ydGVkQXJlYXMgPSBPYmplY3Qua2V5cyhyZWN0cykubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gX2V4dGVuZHMoe1xuICAgICAga2V5OiBrZXlcbiAgICB9LCByZWN0c1trZXldLCB7XG4gICAgICBhcmVhOiBnZXRBcmVhKHJlY3RzW2tleV0pXG4gICAgfSk7XG4gIH0pLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gYi5hcmVhIC0gYS5hcmVhO1xuICB9KTtcblxuICB2YXIgZmlsdGVyZWRBcmVhcyA9IHNvcnRlZEFyZWFzLmZpbHRlcihmdW5jdGlvbiAoX3JlZjIpIHtcbiAgICB2YXIgd2lkdGggPSBfcmVmMi53aWR0aCxcbiAgICAgICAgaGVpZ2h0ID0gX3JlZjIuaGVpZ2h0O1xuICAgIHJldHVybiB3aWR0aCA+PSBwb3BwZXIuY2xpZW50V2lkdGggJiYgaGVpZ2h0ID49IHBvcHBlci5jbGllbnRIZWlnaHQ7XG4gIH0pO1xuXG4gIHZhciBjb21wdXRlZFBsYWNlbWVudCA9IGZpbHRlcmVkQXJlYXMubGVuZ3RoID4gMCA/IGZpbHRlcmVkQXJlYXNbMF0ua2V5IDogc29ydGVkQXJlYXNbMF0ua2V5O1xuXG4gIHZhciB2YXJpYXRpb24gPSBwbGFjZW1lbnQuc3BsaXQoJy0nKVsxXTtcblxuICByZXR1cm4gY29tcHV0ZWRQbGFjZW1lbnQgKyAodmFyaWF0aW9uID8gJy0nICsgdmFyaWF0aW9uIDogJycpO1xufVxuXG4vKipcbiAqIEdldCBvZmZzZXRzIHRvIHRoZSByZWZlcmVuY2UgZWxlbWVudFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHBhcmFtIHtPYmplY3R9IHN0YXRlXG4gKiBAcGFyYW0ge0VsZW1lbnR9IHBvcHBlciAtIHRoZSBwb3BwZXIgZWxlbWVudFxuICogQHBhcmFtIHtFbGVtZW50fSByZWZlcmVuY2UgLSB0aGUgcmVmZXJlbmNlIGVsZW1lbnQgKHRoZSBwb3BwZXIgd2lsbCBiZSByZWxhdGl2ZSB0byB0aGlzKVxuICogQHBhcmFtIHtFbGVtZW50fSBmaXhlZFBvc2l0aW9uIC0gaXMgaW4gZml4ZWQgcG9zaXRpb24gbW9kZVxuICogQHJldHVybnMge09iamVjdH0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIG9mZnNldHMgd2hpY2ggd2lsbCBiZSBhcHBsaWVkIHRvIHRoZSBwb3BwZXJcbiAqL1xuZnVuY3Rpb24gZ2V0UmVmZXJlbmNlT2Zmc2V0cyhzdGF0ZSwgcG9wcGVyLCByZWZlcmVuY2UpIHtcbiAgdmFyIGZpeGVkUG9zaXRpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IG51bGw7XG5cbiAgdmFyIGNvbW1vbk9mZnNldFBhcmVudCA9IGZpeGVkUG9zaXRpb24gPyBnZXRGaXhlZFBvc2l0aW9uT2Zmc2V0UGFyZW50KHBvcHBlcikgOiBmaW5kQ29tbW9uT2Zmc2V0UGFyZW50KHBvcHBlciwgcmVmZXJlbmNlKTtcbiAgcmV0dXJuIGdldE9mZnNldFJlY3RSZWxhdGl2ZVRvQXJiaXRyYXJ5Tm9kZShyZWZlcmVuY2UsIGNvbW1vbk9mZnNldFBhcmVudCwgZml4ZWRQb3NpdGlvbik7XG59XG5cbi8qKlxuICogR2V0IHRoZSBvdXRlciBzaXplcyBvZiB0aGUgZ2l2ZW4gZWxlbWVudCAob2Zmc2V0IHNpemUgKyBtYXJnaW5zKVxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcmV0dXJucyB7T2JqZWN0fSBvYmplY3QgY29udGFpbmluZyB3aWR0aCBhbmQgaGVpZ2h0IHByb3BlcnRpZXNcbiAqL1xuZnVuY3Rpb24gZ2V0T3V0ZXJTaXplcyhlbGVtZW50KSB7XG4gIHZhciB3aW5kb3cgPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXc7XG4gIHZhciBzdHlsZXMgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcbiAgdmFyIHggPSBwYXJzZUZsb2F0KHN0eWxlcy5tYXJnaW5Ub3AgfHwgMCkgKyBwYXJzZUZsb2F0KHN0eWxlcy5tYXJnaW5Cb3R0b20gfHwgMCk7XG4gIHZhciB5ID0gcGFyc2VGbG9hdChzdHlsZXMubWFyZ2luTGVmdCB8fCAwKSArIHBhcnNlRmxvYXQoc3R5bGVzLm1hcmdpblJpZ2h0IHx8IDApO1xuICB2YXIgcmVzdWx0ID0ge1xuICAgIHdpZHRoOiBlbGVtZW50Lm9mZnNldFdpZHRoICsgeSxcbiAgICBoZWlnaHQ6IGVsZW1lbnQub2Zmc2V0SGVpZ2h0ICsgeFxuICB9O1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEdldCB0aGUgb3Bwb3NpdGUgcGxhY2VtZW50IG9mIHRoZSBnaXZlbiBvbmVcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7U3RyaW5nfSBwbGFjZW1lbnRcbiAqIEByZXR1cm5zIHtTdHJpbmd9IGZsaXBwZWQgcGxhY2VtZW50XG4gKi9cbmZ1bmN0aW9uIGdldE9wcG9zaXRlUGxhY2VtZW50KHBsYWNlbWVudCkge1xuICB2YXIgaGFzaCA9IHsgbGVmdDogJ3JpZ2h0JywgcmlnaHQ6ICdsZWZ0JywgYm90dG9tOiAndG9wJywgdG9wOiAnYm90dG9tJyB9O1xuICByZXR1cm4gcGxhY2VtZW50LnJlcGxhY2UoL2xlZnR8cmlnaHR8Ym90dG9tfHRvcC9nLCBmdW5jdGlvbiAobWF0Y2hlZCkge1xuICAgIHJldHVybiBoYXNoW21hdGNoZWRdO1xuICB9KTtcbn1cblxuLyoqXG4gKiBHZXQgb2Zmc2V0cyB0byB0aGUgcG9wcGVyXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcGFyYW0ge09iamVjdH0gcG9zaXRpb24gLSBDU1MgcG9zaXRpb24gdGhlIFBvcHBlciB3aWxsIGdldCBhcHBsaWVkXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBwb3BwZXIgLSB0aGUgcG9wcGVyIGVsZW1lbnRcbiAqIEBwYXJhbSB7T2JqZWN0fSByZWZlcmVuY2VPZmZzZXRzIC0gdGhlIHJlZmVyZW5jZSBvZmZzZXRzICh0aGUgcG9wcGVyIHdpbGwgYmUgcmVsYXRpdmUgdG8gdGhpcylcbiAqIEBwYXJhbSB7U3RyaW5nfSBwbGFjZW1lbnQgLSBvbmUgb2YgdGhlIHZhbGlkIHBsYWNlbWVudCBvcHRpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBwb3BwZXJPZmZzZXRzIC0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIG9mZnNldHMgd2hpY2ggd2lsbCBiZSBhcHBsaWVkIHRvIHRoZSBwb3BwZXJcbiAqL1xuZnVuY3Rpb24gZ2V0UG9wcGVyT2Zmc2V0cyhwb3BwZXIsIHJlZmVyZW5jZU9mZnNldHMsIHBsYWNlbWVudCkge1xuICBwbGFjZW1lbnQgPSBwbGFjZW1lbnQuc3BsaXQoJy0nKVswXTtcblxuICAvLyBHZXQgcG9wcGVyIG5vZGUgc2l6ZXNcbiAgdmFyIHBvcHBlclJlY3QgPSBnZXRPdXRlclNpemVzKHBvcHBlcik7XG5cbiAgLy8gQWRkIHBvc2l0aW9uLCB3aWR0aCBhbmQgaGVpZ2h0IHRvIG91ciBvZmZzZXRzIG9iamVjdFxuICB2YXIgcG9wcGVyT2Zmc2V0cyA9IHtcbiAgICB3aWR0aDogcG9wcGVyUmVjdC53aWR0aCxcbiAgICBoZWlnaHQ6IHBvcHBlclJlY3QuaGVpZ2h0XG4gIH07XG5cbiAgLy8gZGVwZW5kaW5nIGJ5IHRoZSBwb3BwZXIgcGxhY2VtZW50IHdlIGhhdmUgdG8gY29tcHV0ZSBpdHMgb2Zmc2V0cyBzbGlnaHRseSBkaWZmZXJlbnRseVxuICB2YXIgaXNIb3JpeiA9IFsncmlnaHQnLCAnbGVmdCddLmluZGV4T2YocGxhY2VtZW50KSAhPT0gLTE7XG4gIHZhciBtYWluU2lkZSA9IGlzSG9yaXogPyAndG9wJyA6ICdsZWZ0JztcbiAgdmFyIHNlY29uZGFyeVNpZGUgPSBpc0hvcml6ID8gJ2xlZnQnIDogJ3RvcCc7XG4gIHZhciBtZWFzdXJlbWVudCA9IGlzSG9yaXogPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG4gIHZhciBzZWNvbmRhcnlNZWFzdXJlbWVudCA9ICFpc0hvcml6ID8gJ2hlaWdodCcgOiAnd2lkdGgnO1xuXG4gIHBvcHBlck9mZnNldHNbbWFpblNpZGVdID0gcmVmZXJlbmNlT2Zmc2V0c1ttYWluU2lkZV0gKyByZWZlcmVuY2VPZmZzZXRzW21lYXN1cmVtZW50XSAvIDIgLSBwb3BwZXJSZWN0W21lYXN1cmVtZW50XSAvIDI7XG4gIGlmIChwbGFjZW1lbnQgPT09IHNlY29uZGFyeVNpZGUpIHtcbiAgICBwb3BwZXJPZmZzZXRzW3NlY29uZGFyeVNpZGVdID0gcmVmZXJlbmNlT2Zmc2V0c1tzZWNvbmRhcnlTaWRlXSAtIHBvcHBlclJlY3Rbc2Vjb25kYXJ5TWVhc3VyZW1lbnRdO1xuICB9IGVsc2Uge1xuICAgIHBvcHBlck9mZnNldHNbc2Vjb25kYXJ5U2lkZV0gPSByZWZlcmVuY2VPZmZzZXRzW2dldE9wcG9zaXRlUGxhY2VtZW50KHNlY29uZGFyeVNpZGUpXTtcbiAgfVxuXG4gIHJldHVybiBwb3BwZXJPZmZzZXRzO1xufVxuXG4vKipcbiAqIE1pbWljcyB0aGUgYGZpbmRgIG1ldGhvZCBvZiBBcnJheVxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtBcnJheX0gYXJyXG4gKiBAYXJndW1lbnQgcHJvcFxuICogQGFyZ3VtZW50IHZhbHVlXG4gKiBAcmV0dXJucyBpbmRleCBvciAtMVxuICovXG5mdW5jdGlvbiBmaW5kKGFyciwgY2hlY2spIHtcbiAgLy8gdXNlIG5hdGl2ZSBmaW5kIGlmIHN1cHBvcnRlZFxuICBpZiAoQXJyYXkucHJvdG90eXBlLmZpbmQpIHtcbiAgICByZXR1cm4gYXJyLmZpbmQoY2hlY2spO1xuICB9XG5cbiAgLy8gdXNlIGBmaWx0ZXJgIHRvIG9idGFpbiB0aGUgc2FtZSBiZWhhdmlvciBvZiBgZmluZGBcbiAgcmV0dXJuIGFyci5maWx0ZXIoY2hlY2spWzBdO1xufVxuXG4vKipcbiAqIFJldHVybiB0aGUgaW5kZXggb2YgdGhlIG1hdGNoaW5nIG9iamVjdFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtBcnJheX0gYXJyXG4gKiBAYXJndW1lbnQgcHJvcFxuICogQGFyZ3VtZW50IHZhbHVlXG4gKiBAcmV0dXJucyBpbmRleCBvciAtMVxuICovXG5mdW5jdGlvbiBmaW5kSW5kZXgoYXJyLCBwcm9wLCB2YWx1ZSkge1xuICAvLyB1c2UgbmF0aXZlIGZpbmRJbmRleCBpZiBzdXBwb3J0ZWRcbiAgaWYgKEFycmF5LnByb3RvdHlwZS5maW5kSW5kZXgpIHtcbiAgICByZXR1cm4gYXJyLmZpbmRJbmRleChmdW5jdGlvbiAoY3VyKSB7XG4gICAgICByZXR1cm4gY3VyW3Byb3BdID09PSB2YWx1ZTtcbiAgICB9KTtcbiAgfVxuXG4gIC8vIHVzZSBgZmluZGAgKyBgaW5kZXhPZmAgaWYgYGZpbmRJbmRleGAgaXNuJ3Qgc3VwcG9ydGVkXG4gIHZhciBtYXRjaCA9IGZpbmQoYXJyLCBmdW5jdGlvbiAob2JqKSB7XG4gICAgcmV0dXJuIG9ialtwcm9wXSA9PT0gdmFsdWU7XG4gIH0pO1xuICByZXR1cm4gYXJyLmluZGV4T2YobWF0Y2gpO1xufVxuXG4vKipcbiAqIExvb3AgdHJvdWdoIHRoZSBsaXN0IG9mIG1vZGlmaWVycyBhbmQgcnVuIHRoZW0gaW4gb3JkZXIsXG4gKiBlYWNoIG9mIHRoZW0gd2lsbCB0aGVuIGVkaXQgdGhlIGRhdGEgb2JqZWN0LlxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHBhcmFtIHtkYXRhT2JqZWN0fSBkYXRhXG4gKiBAcGFyYW0ge0FycmF5fSBtb2RpZmllcnNcbiAqIEBwYXJhbSB7U3RyaW5nfSBlbmRzIC0gT3B0aW9uYWwgbW9kaWZpZXIgbmFtZSB1c2VkIGFzIHN0b3BwZXJcbiAqIEByZXR1cm5zIHtkYXRhT2JqZWN0fVxuICovXG5mdW5jdGlvbiBydW5Nb2RpZmllcnMobW9kaWZpZXJzLCBkYXRhLCBlbmRzKSB7XG4gIHZhciBtb2RpZmllcnNUb1J1biA9IGVuZHMgPT09IHVuZGVmaW5lZCA/IG1vZGlmaWVycyA6IG1vZGlmaWVycy5zbGljZSgwLCBmaW5kSW5kZXgobW9kaWZpZXJzLCAnbmFtZScsIGVuZHMpKTtcblxuICBtb2RpZmllcnNUb1J1bi5mb3JFYWNoKGZ1bmN0aW9uIChtb2RpZmllcikge1xuICAgIGlmIChtb2RpZmllclsnZnVuY3Rpb24nXSkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBkb3Qtbm90YXRpb25cbiAgICAgIGNvbnNvbGUud2FybignYG1vZGlmaWVyLmZ1bmN0aW9uYCBpcyBkZXByZWNhdGVkLCB1c2UgYG1vZGlmaWVyLmZuYCEnKTtcbiAgICB9XG4gICAgdmFyIGZuID0gbW9kaWZpZXJbJ2Z1bmN0aW9uJ10gfHwgbW9kaWZpZXIuZm47IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZG90LW5vdGF0aW9uXG4gICAgaWYgKG1vZGlmaWVyLmVuYWJsZWQgJiYgaXNGdW5jdGlvbihmbikpIHtcbiAgICAgIC8vIEFkZCBwcm9wZXJ0aWVzIHRvIG9mZnNldHMgdG8gbWFrZSB0aGVtIGEgY29tcGxldGUgY2xpZW50UmVjdCBvYmplY3RcbiAgICAgIC8vIHdlIGRvIHRoaXMgYmVmb3JlIGVhY2ggbW9kaWZpZXIgdG8gbWFrZSBzdXJlIHRoZSBwcmV2aW91cyBvbmUgZG9lc24ndFxuICAgICAgLy8gbWVzcyB3aXRoIHRoZXNlIHZhbHVlc1xuICAgICAgZGF0YS5vZmZzZXRzLnBvcHBlciA9IGdldENsaWVudFJlY3QoZGF0YS5vZmZzZXRzLnBvcHBlcik7XG4gICAgICBkYXRhLm9mZnNldHMucmVmZXJlbmNlID0gZ2V0Q2xpZW50UmVjdChkYXRhLm9mZnNldHMucmVmZXJlbmNlKTtcblxuICAgICAgZGF0YSA9IGZuKGRhdGEsIG1vZGlmaWVyKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIFVwZGF0ZXMgdGhlIHBvc2l0aW9uIG9mIHRoZSBwb3BwZXIsIGNvbXB1dGluZyB0aGUgbmV3IG9mZnNldHMgYW5kIGFwcGx5aW5nXG4gKiB0aGUgbmV3IHN0eWxlLjxiciAvPlxuICogUHJlZmVyIGBzY2hlZHVsZVVwZGF0ZWAgb3ZlciBgdXBkYXRlYCBiZWNhdXNlIG9mIHBlcmZvcm1hbmNlIHJlYXNvbnMuXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyXG4gKi9cbmZ1bmN0aW9uIHVwZGF0ZSgpIHtcbiAgLy8gaWYgcG9wcGVyIGlzIGRlc3Ryb3llZCwgZG9uJ3QgcGVyZm9ybSBhbnkgZnVydGhlciB1cGRhdGVcbiAgaWYgKHRoaXMuc3RhdGUuaXNEZXN0cm95ZWQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgZGF0YSA9IHtcbiAgICBpbnN0YW5jZTogdGhpcyxcbiAgICBzdHlsZXM6IHt9LFxuICAgIGFycm93U3R5bGVzOiB7fSxcbiAgICBhdHRyaWJ1dGVzOiB7fSxcbiAgICBmbGlwcGVkOiBmYWxzZSxcbiAgICBvZmZzZXRzOiB7fVxuICB9O1xuXG4gIC8vIGNvbXB1dGUgcmVmZXJlbmNlIGVsZW1lbnQgb2Zmc2V0c1xuICBkYXRhLm9mZnNldHMucmVmZXJlbmNlID0gZ2V0UmVmZXJlbmNlT2Zmc2V0cyh0aGlzLnN0YXRlLCB0aGlzLnBvcHBlciwgdGhpcy5yZWZlcmVuY2UsIHRoaXMub3B0aW9ucy5wb3NpdGlvbkZpeGVkKTtcblxuICAvLyBjb21wdXRlIGF1dG8gcGxhY2VtZW50LCBzdG9yZSBwbGFjZW1lbnQgaW5zaWRlIHRoZSBkYXRhIG9iamVjdCxcbiAgLy8gbW9kaWZpZXJzIHdpbGwgYmUgYWJsZSB0byBlZGl0IGBwbGFjZW1lbnRgIGlmIG5lZWRlZFxuICAvLyBhbmQgcmVmZXIgdG8gb3JpZ2luYWxQbGFjZW1lbnQgdG8ga25vdyB0aGUgb3JpZ2luYWwgdmFsdWVcbiAgZGF0YS5wbGFjZW1lbnQgPSBjb21wdXRlQXV0b1BsYWNlbWVudCh0aGlzLm9wdGlvbnMucGxhY2VtZW50LCBkYXRhLm9mZnNldHMucmVmZXJlbmNlLCB0aGlzLnBvcHBlciwgdGhpcy5yZWZlcmVuY2UsIHRoaXMub3B0aW9ucy5tb2RpZmllcnMuZmxpcC5ib3VuZGFyaWVzRWxlbWVudCwgdGhpcy5vcHRpb25zLm1vZGlmaWVycy5mbGlwLnBhZGRpbmcpO1xuXG4gIC8vIHN0b3JlIHRoZSBjb21wdXRlZCBwbGFjZW1lbnQgaW5zaWRlIGBvcmlnaW5hbFBsYWNlbWVudGBcbiAgZGF0YS5vcmlnaW5hbFBsYWNlbWVudCA9IGRhdGEucGxhY2VtZW50O1xuXG4gIGRhdGEucG9zaXRpb25GaXhlZCA9IHRoaXMub3B0aW9ucy5wb3NpdGlvbkZpeGVkO1xuXG4gIC8vIGNvbXB1dGUgdGhlIHBvcHBlciBvZmZzZXRzXG4gIGRhdGEub2Zmc2V0cy5wb3BwZXIgPSBnZXRQb3BwZXJPZmZzZXRzKHRoaXMucG9wcGVyLCBkYXRhLm9mZnNldHMucmVmZXJlbmNlLCBkYXRhLnBsYWNlbWVudCk7XG5cbiAgZGF0YS5vZmZzZXRzLnBvcHBlci5wb3NpdGlvbiA9IHRoaXMub3B0aW9ucy5wb3NpdGlvbkZpeGVkID8gJ2ZpeGVkJyA6ICdhYnNvbHV0ZSc7XG5cbiAgLy8gcnVuIHRoZSBtb2RpZmllcnNcbiAgZGF0YSA9IHJ1bk1vZGlmaWVycyh0aGlzLm1vZGlmaWVycywgZGF0YSk7XG5cbiAgLy8gdGhlIGZpcnN0IGB1cGRhdGVgIHdpbGwgY2FsbCBgb25DcmVhdGVgIGNhbGxiYWNrXG4gIC8vIHRoZSBvdGhlciBvbmVzIHdpbGwgY2FsbCBgb25VcGRhdGVgIGNhbGxiYWNrXG4gIGlmICghdGhpcy5zdGF0ZS5pc0NyZWF0ZWQpIHtcbiAgICB0aGlzLnN0YXRlLmlzQ3JlYXRlZCA9IHRydWU7XG4gICAgdGhpcy5vcHRpb25zLm9uQ3JlYXRlKGRhdGEpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMub3B0aW9ucy5vblVwZGF0ZShkYXRhKTtcbiAgfVxufVxuXG4vKipcbiAqIEhlbHBlciB1c2VkIHRvIGtub3cgaWYgdGhlIGdpdmVuIG1vZGlmaWVyIGlzIGVuYWJsZWQuXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNNb2RpZmllckVuYWJsZWQobW9kaWZpZXJzLCBtb2RpZmllck5hbWUpIHtcbiAgcmV0dXJuIG1vZGlmaWVycy5zb21lKGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgdmFyIG5hbWUgPSBfcmVmLm5hbWUsXG4gICAgICAgIGVuYWJsZWQgPSBfcmVmLmVuYWJsZWQ7XG4gICAgcmV0dXJuIGVuYWJsZWQgJiYgbmFtZSA9PT0gbW9kaWZpZXJOYW1lO1xuICB9KTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHByZWZpeGVkIHN1cHBvcnRlZCBwcm9wZXJ0eSBuYW1lXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge1N0cmluZ30gcHJvcGVydHkgKGNhbWVsQ2FzZSlcbiAqIEByZXR1cm5zIHtTdHJpbmd9IHByZWZpeGVkIHByb3BlcnR5IChjYW1lbENhc2Ugb3IgUGFzY2FsQ2FzZSwgZGVwZW5kaW5nIG9uIHRoZSB2ZW5kb3IgcHJlZml4KVxuICovXG5mdW5jdGlvbiBnZXRTdXBwb3J0ZWRQcm9wZXJ0eU5hbWUocHJvcGVydHkpIHtcbiAgdmFyIHByZWZpeGVzID0gW2ZhbHNlLCAnbXMnLCAnV2Via2l0JywgJ01veicsICdPJ107XG4gIHZhciB1cHBlclByb3AgPSBwcm9wZXJ0eS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHByb3BlcnR5LnNsaWNlKDEpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJlZml4ZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcHJlZml4ID0gcHJlZml4ZXNbaV07XG4gICAgdmFyIHRvQ2hlY2sgPSBwcmVmaXggPyAnJyArIHByZWZpeCArIHVwcGVyUHJvcCA6IHByb3BlcnR5O1xuICAgIGlmICh0eXBlb2YgZG9jdW1lbnQuYm9keS5zdHlsZVt0b0NoZWNrXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiB0b0NoZWNrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBEZXN0cm95cyB0aGUgcG9wcGVyLlxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlclxuICovXG5mdW5jdGlvbiBkZXN0cm95KCkge1xuICB0aGlzLnN0YXRlLmlzRGVzdHJveWVkID0gdHJ1ZTtcblxuICAvLyB0b3VjaCBET00gb25seSBpZiBgYXBwbHlTdHlsZWAgbW9kaWZpZXIgaXMgZW5hYmxlZFxuICBpZiAoaXNNb2RpZmllckVuYWJsZWQodGhpcy5tb2RpZmllcnMsICdhcHBseVN0eWxlJykpIHtcbiAgICB0aGlzLnBvcHBlci5yZW1vdmVBdHRyaWJ1dGUoJ3gtcGxhY2VtZW50Jyk7XG4gICAgdGhpcy5wb3BwZXIuc3R5bGUucG9zaXRpb24gPSAnJztcbiAgICB0aGlzLnBvcHBlci5zdHlsZS50b3AgPSAnJztcbiAgICB0aGlzLnBvcHBlci5zdHlsZS5sZWZ0ID0gJyc7XG4gICAgdGhpcy5wb3BwZXIuc3R5bGUucmlnaHQgPSAnJztcbiAgICB0aGlzLnBvcHBlci5zdHlsZS5ib3R0b20gPSAnJztcbiAgICB0aGlzLnBvcHBlci5zdHlsZS53aWxsQ2hhbmdlID0gJyc7XG4gICAgdGhpcy5wb3BwZXIuc3R5bGVbZ2V0U3VwcG9ydGVkUHJvcGVydHlOYW1lKCd0cmFuc2Zvcm0nKV0gPSAnJztcbiAgfVxuXG4gIHRoaXMuZGlzYWJsZUV2ZW50TGlzdGVuZXJzKCk7XG5cbiAgLy8gcmVtb3ZlIHRoZSBwb3BwZXIgaWYgdXNlciBleHBsaWNpdHkgYXNrZWQgZm9yIHRoZSBkZWxldGlvbiBvbiBkZXN0cm95XG4gIC8vIGRvIG5vdCB1c2UgYHJlbW92ZWAgYmVjYXVzZSBJRTExIGRvZXNuJ3Qgc3VwcG9ydCBpdFxuICBpZiAodGhpcy5vcHRpb25zLnJlbW92ZU9uRGVzdHJveSkge1xuICAgIHRoaXMucG9wcGVyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5wb3BwZXIpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufVxuXG4vKipcbiAqIEdldCB0aGUgd2luZG93IGFzc29jaWF0ZWQgd2l0aCB0aGUgZWxlbWVudFxuICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcmV0dXJucyB7V2luZG93fVxuICovXG5mdW5jdGlvbiBnZXRXaW5kb3coZWxlbWVudCkge1xuICB2YXIgb3duZXJEb2N1bWVudCA9IGVsZW1lbnQub3duZXJEb2N1bWVudDtcbiAgcmV0dXJuIG93bmVyRG9jdW1lbnQgPyBvd25lckRvY3VtZW50LmRlZmF1bHRWaWV3IDogd2luZG93O1xufVxuXG5mdW5jdGlvbiBhdHRhY2hUb1Njcm9sbFBhcmVudHMoc2Nyb2xsUGFyZW50LCBldmVudCwgY2FsbGJhY2ssIHNjcm9sbFBhcmVudHMpIHtcbiAgdmFyIGlzQm9keSA9IHNjcm9sbFBhcmVudC5ub2RlTmFtZSA9PT0gJ0JPRFknO1xuICB2YXIgdGFyZ2V0ID0gaXNCb2R5ID8gc2Nyb2xsUGFyZW50Lm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcgOiBzY3JvbGxQYXJlbnQ7XG4gIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBjYWxsYmFjaywgeyBwYXNzaXZlOiB0cnVlIH0pO1xuXG4gIGlmICghaXNCb2R5KSB7XG4gICAgYXR0YWNoVG9TY3JvbGxQYXJlbnRzKGdldFNjcm9sbFBhcmVudCh0YXJnZXQucGFyZW50Tm9kZSksIGV2ZW50LCBjYWxsYmFjaywgc2Nyb2xsUGFyZW50cyk7XG4gIH1cbiAgc2Nyb2xsUGFyZW50cy5wdXNoKHRhcmdldCk7XG59XG5cbi8qKlxuICogU2V0dXAgbmVlZGVkIGV2ZW50IGxpc3RlbmVycyB1c2VkIHRvIHVwZGF0ZSB0aGUgcG9wcGVyIHBvc2l0aW9uXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBzZXR1cEV2ZW50TGlzdGVuZXJzKHJlZmVyZW5jZSwgb3B0aW9ucywgc3RhdGUsIHVwZGF0ZUJvdW5kKSB7XG4gIC8vIFJlc2l6ZSBldmVudCBsaXN0ZW5lciBvbiB3aW5kb3dcbiAgc3RhdGUudXBkYXRlQm91bmQgPSB1cGRhdGVCb3VuZDtcbiAgZ2V0V2luZG93KHJlZmVyZW5jZSkuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgc3RhdGUudXBkYXRlQm91bmQsIHsgcGFzc2l2ZTogdHJ1ZSB9KTtcblxuICAvLyBTY3JvbGwgZXZlbnQgbGlzdGVuZXIgb24gc2Nyb2xsIHBhcmVudHNcbiAgdmFyIHNjcm9sbEVsZW1lbnQgPSBnZXRTY3JvbGxQYXJlbnQocmVmZXJlbmNlKTtcbiAgYXR0YWNoVG9TY3JvbGxQYXJlbnRzKHNjcm9sbEVsZW1lbnQsICdzY3JvbGwnLCBzdGF0ZS51cGRhdGVCb3VuZCwgc3RhdGUuc2Nyb2xsUGFyZW50cyk7XG4gIHN0YXRlLnNjcm9sbEVsZW1lbnQgPSBzY3JvbGxFbGVtZW50O1xuICBzdGF0ZS5ldmVudHNFbmFibGVkID0gdHJ1ZTtcblxuICByZXR1cm4gc3RhdGU7XG59XG5cbi8qKlxuICogSXQgd2lsbCBhZGQgcmVzaXplL3Njcm9sbCBldmVudHMgYW5kIHN0YXJ0IHJlY2FsY3VsYXRpbmdcbiAqIHBvc2l0aW9uIG9mIHRoZSBwb3BwZXIgZWxlbWVudCB3aGVuIHRoZXkgYXJlIHRyaWdnZXJlZC5cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXJcbiAqL1xuZnVuY3Rpb24gZW5hYmxlRXZlbnRMaXN0ZW5lcnMoKSB7XG4gIGlmICghdGhpcy5zdGF0ZS5ldmVudHNFbmFibGVkKSB7XG4gICAgdGhpcy5zdGF0ZSA9IHNldHVwRXZlbnRMaXN0ZW5lcnModGhpcy5yZWZlcmVuY2UsIHRoaXMub3B0aW9ucywgdGhpcy5zdGF0ZSwgdGhpcy5zY2hlZHVsZVVwZGF0ZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZW1vdmUgZXZlbnQgbGlzdGVuZXJzIHVzZWQgdG8gdXBkYXRlIHRoZSBwb3BwZXIgcG9zaXRpb25cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZUV2ZW50TGlzdGVuZXJzKHJlZmVyZW5jZSwgc3RhdGUpIHtcbiAgLy8gUmVtb3ZlIHJlc2l6ZSBldmVudCBsaXN0ZW5lciBvbiB3aW5kb3dcbiAgZ2V0V2luZG93KHJlZmVyZW5jZSkucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgc3RhdGUudXBkYXRlQm91bmQpO1xuXG4gIC8vIFJlbW92ZSBzY3JvbGwgZXZlbnQgbGlzdGVuZXIgb24gc2Nyb2xsIHBhcmVudHNcbiAgc3RhdGUuc2Nyb2xsUGFyZW50cy5mb3JFYWNoKGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICB0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgc3RhdGUudXBkYXRlQm91bmQpO1xuICB9KTtcblxuICAvLyBSZXNldCBzdGF0ZVxuICBzdGF0ZS51cGRhdGVCb3VuZCA9IG51bGw7XG4gIHN0YXRlLnNjcm9sbFBhcmVudHMgPSBbXTtcbiAgc3RhdGUuc2Nyb2xsRWxlbWVudCA9IG51bGw7XG4gIHN0YXRlLmV2ZW50c0VuYWJsZWQgPSBmYWxzZTtcbiAgcmV0dXJuIHN0YXRlO1xufVxuXG4vKipcbiAqIEl0IHdpbGwgcmVtb3ZlIHJlc2l6ZS9zY3JvbGwgZXZlbnRzIGFuZCB3b24ndCByZWNhbGN1bGF0ZSBwb3BwZXIgcG9zaXRpb25cbiAqIHdoZW4gdGhleSBhcmUgdHJpZ2dlcmVkLiBJdCBhbHNvIHdvbid0IHRyaWdnZXIgYG9uVXBkYXRlYCBjYWxsYmFjayBhbnltb3JlLFxuICogdW5sZXNzIHlvdSBjYWxsIGB1cGRhdGVgIG1ldGhvZCBtYW51YWxseS5cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXJcbiAqL1xuZnVuY3Rpb24gZGlzYWJsZUV2ZW50TGlzdGVuZXJzKCkge1xuICBpZiAodGhpcy5zdGF0ZS5ldmVudHNFbmFibGVkKSB7XG4gICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5zY2hlZHVsZVVwZGF0ZSk7XG4gICAgdGhpcy5zdGF0ZSA9IHJlbW92ZUV2ZW50TGlzdGVuZXJzKHRoaXMucmVmZXJlbmNlLCB0aGlzLnN0YXRlKTtcbiAgfVxufVxuXG4vKipcbiAqIFRlbGxzIGlmIGEgZ2l2ZW4gaW5wdXQgaXMgYSBudW1iZXJcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBwYXJhbSB7Kn0gaW5wdXQgdG8gY2hlY2tcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzTnVtZXJpYyhuKSB7XG4gIHJldHVybiBuICE9PSAnJyAmJiAhaXNOYU4ocGFyc2VGbG9hdChuKSkgJiYgaXNGaW5pdGUobik7XG59XG5cbi8qKlxuICogU2V0IHRoZSBzdHlsZSB0byB0aGUgZ2l2ZW4gcG9wcGVyXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnQgLSBFbGVtZW50IHRvIGFwcGx5IHRoZSBzdHlsZSB0b1xuICogQGFyZ3VtZW50IHtPYmplY3R9IHN0eWxlc1xuICogT2JqZWN0IHdpdGggYSBsaXN0IG9mIHByb3BlcnRpZXMgYW5kIHZhbHVlcyB3aGljaCB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIGVsZW1lbnRcbiAqL1xuZnVuY3Rpb24gc2V0U3R5bGVzKGVsZW1lbnQsIHN0eWxlcykge1xuICBPYmplY3Qua2V5cyhzdHlsZXMpLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICB2YXIgdW5pdCA9ICcnO1xuICAgIC8vIGFkZCB1bml0IGlmIHRoZSB2YWx1ZSBpcyBudW1lcmljIGFuZCBpcyBvbmUgb2YgdGhlIGZvbGxvd2luZ1xuICAgIGlmIChbJ3dpZHRoJywgJ2hlaWdodCcsICd0b3AnLCAncmlnaHQnLCAnYm90dG9tJywgJ2xlZnQnXS5pbmRleE9mKHByb3ApICE9PSAtMSAmJiBpc051bWVyaWMoc3R5bGVzW3Byb3BdKSkge1xuICAgICAgdW5pdCA9ICdweCc7XG4gICAgfVxuICAgIGVsZW1lbnQuc3R5bGVbcHJvcF0gPSBzdHlsZXNbcHJvcF0gKyB1bml0O1xuICB9KTtcbn1cblxuLyoqXG4gKiBTZXQgdGhlIGF0dHJpYnV0ZXMgdG8gdGhlIGdpdmVuIHBvcHBlclxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50IC0gRWxlbWVudCB0byBhcHBseSB0aGUgYXR0cmlidXRlcyB0b1xuICogQGFyZ3VtZW50IHtPYmplY3R9IHN0eWxlc1xuICogT2JqZWN0IHdpdGggYSBsaXN0IG9mIHByb3BlcnRpZXMgYW5kIHZhbHVlcyB3aGljaCB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIGVsZW1lbnRcbiAqL1xuZnVuY3Rpb24gc2V0QXR0cmlidXRlcyhlbGVtZW50LCBhdHRyaWJ1dGVzKSB7XG4gIE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICB2YXIgdmFsdWUgPSBhdHRyaWJ1dGVzW3Byb3BdO1xuICAgIGlmICh2YWx1ZSAhPT0gZmFsc2UpIHtcbiAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKHByb3AsIGF0dHJpYnV0ZXNbcHJvcF0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShwcm9wKTtcbiAgICB9XG4gIH0pO1xufVxuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIE1vZGlmaWVyc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IGB1cGRhdGVgIG1ldGhvZFxuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEuc3R5bGVzIC0gTGlzdCBvZiBzdHlsZSBwcm9wZXJ0aWVzIC0gdmFsdWVzIHRvIGFwcGx5IHRvIHBvcHBlciBlbGVtZW50XG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YS5hdHRyaWJ1dGVzIC0gTGlzdCBvZiBhdHRyaWJ1dGUgcHJvcGVydGllcyAtIHZhbHVlcyB0byBhcHBseSB0byBwb3BwZXIgZWxlbWVudFxuICogQGFyZ3VtZW50IHtPYmplY3R9IG9wdGlvbnMgLSBNb2RpZmllcnMgY29uZmlndXJhdGlvbiBhbmQgb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdH0gVGhlIHNhbWUgZGF0YSBvYmplY3RcbiAqL1xuZnVuY3Rpb24gYXBwbHlTdHlsZShkYXRhKSB7XG4gIC8vIGFueSBwcm9wZXJ0eSBwcmVzZW50IGluIGBkYXRhLnN0eWxlc2Agd2lsbCBiZSBhcHBsaWVkIHRvIHRoZSBwb3BwZXIsXG4gIC8vIGluIHRoaXMgd2F5IHdlIGNhbiBtYWtlIHRoZSAzcmQgcGFydHkgbW9kaWZpZXJzIGFkZCBjdXN0b20gc3R5bGVzIHRvIGl0XG4gIC8vIEJlIGF3YXJlLCBtb2RpZmllcnMgY291bGQgb3ZlcnJpZGUgdGhlIHByb3BlcnRpZXMgZGVmaW5lZCBpbiB0aGUgcHJldmlvdXNcbiAgLy8gbGluZXMgb2YgdGhpcyBtb2RpZmllciFcbiAgc2V0U3R5bGVzKGRhdGEuaW5zdGFuY2UucG9wcGVyLCBkYXRhLnN0eWxlcyk7XG5cbiAgLy8gYW55IHByb3BlcnR5IHByZXNlbnQgaW4gYGRhdGEuYXR0cmlidXRlc2Agd2lsbCBiZSBhcHBsaWVkIHRvIHRoZSBwb3BwZXIsXG4gIC8vIHRoZXkgd2lsbCBiZSBzZXQgYXMgSFRNTCBhdHRyaWJ1dGVzIG9mIHRoZSBlbGVtZW50XG4gIHNldEF0dHJpYnV0ZXMoZGF0YS5pbnN0YW5jZS5wb3BwZXIsIGRhdGEuYXR0cmlidXRlcyk7XG5cbiAgLy8gaWYgYXJyb3dFbGVtZW50IGlzIGRlZmluZWQgYW5kIGFycm93U3R5bGVzIGhhcyBzb21lIHByb3BlcnRpZXNcbiAgaWYgKGRhdGEuYXJyb3dFbGVtZW50ICYmIE9iamVjdC5rZXlzKGRhdGEuYXJyb3dTdHlsZXMpLmxlbmd0aCkge1xuICAgIHNldFN0eWxlcyhkYXRhLmFycm93RWxlbWVudCwgZGF0YS5hcnJvd1N0eWxlcyk7XG4gIH1cblxuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBTZXQgdGhlIHgtcGxhY2VtZW50IGF0dHJpYnV0ZSBiZWZvcmUgZXZlcnl0aGluZyBlbHNlIGJlY2F1c2UgaXQgY291bGQgYmUgdXNlZFxuICogdG8gYWRkIG1hcmdpbnMgdG8gdGhlIHBvcHBlciBtYXJnaW5zIG5lZWRzIHRvIGJlIGNhbGN1bGF0ZWQgdG8gZ2V0IHRoZVxuICogY29ycmVjdCBwb3BwZXIgb2Zmc2V0cy5cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIubW9kaWZpZXJzXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSByZWZlcmVuY2UgLSBUaGUgcmVmZXJlbmNlIGVsZW1lbnQgdXNlZCB0byBwb3NpdGlvbiB0aGUgcG9wcGVyXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBwb3BwZXIgLSBUaGUgSFRNTCBlbGVtZW50IHVzZWQgYXMgcG9wcGVyXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIFBvcHBlci5qcyBvcHRpb25zXG4gKi9cbmZ1bmN0aW9uIGFwcGx5U3R5bGVPbkxvYWQocmVmZXJlbmNlLCBwb3BwZXIsIG9wdGlvbnMsIG1vZGlmaWVyT3B0aW9ucywgc3RhdGUpIHtcbiAgLy8gY29tcHV0ZSByZWZlcmVuY2UgZWxlbWVudCBvZmZzZXRzXG4gIHZhciByZWZlcmVuY2VPZmZzZXRzID0gZ2V0UmVmZXJlbmNlT2Zmc2V0cyhzdGF0ZSwgcG9wcGVyLCByZWZlcmVuY2UsIG9wdGlvbnMucG9zaXRpb25GaXhlZCk7XG5cbiAgLy8gY29tcHV0ZSBhdXRvIHBsYWNlbWVudCwgc3RvcmUgcGxhY2VtZW50IGluc2lkZSB0aGUgZGF0YSBvYmplY3QsXG4gIC8vIG1vZGlmaWVycyB3aWxsIGJlIGFibGUgdG8gZWRpdCBgcGxhY2VtZW50YCBpZiBuZWVkZWRcbiAgLy8gYW5kIHJlZmVyIHRvIG9yaWdpbmFsUGxhY2VtZW50IHRvIGtub3cgdGhlIG9yaWdpbmFsIHZhbHVlXG4gIHZhciBwbGFjZW1lbnQgPSBjb21wdXRlQXV0b1BsYWNlbWVudChvcHRpb25zLnBsYWNlbWVudCwgcmVmZXJlbmNlT2Zmc2V0cywgcG9wcGVyLCByZWZlcmVuY2UsIG9wdGlvbnMubW9kaWZpZXJzLmZsaXAuYm91bmRhcmllc0VsZW1lbnQsIG9wdGlvbnMubW9kaWZpZXJzLmZsaXAucGFkZGluZyk7XG5cbiAgcG9wcGVyLnNldEF0dHJpYnV0ZSgneC1wbGFjZW1lbnQnLCBwbGFjZW1lbnQpO1xuXG4gIC8vIEFwcGx5IGBwb3NpdGlvbmAgdG8gcG9wcGVyIGJlZm9yZSBhbnl0aGluZyBlbHNlIGJlY2F1c2VcbiAgLy8gd2l0aG91dCB0aGUgcG9zaXRpb24gYXBwbGllZCB3ZSBjYW4ndCBndWFyYW50ZWUgY29ycmVjdCBjb21wdXRhdGlvbnNcbiAgc2V0U3R5bGVzKHBvcHBlciwgeyBwb3NpdGlvbjogb3B0aW9ucy5wb3NpdGlvbkZpeGVkID8gJ2ZpeGVkJyA6ICdhYnNvbHV0ZScgfSk7XG5cbiAgcmV0dXJuIG9wdGlvbnM7XG59XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgYHVwZGF0ZWAgbWV0aG9kXG4gKiBAYXJndW1lbnQge0Jvb2xlYW59IHNob3VsZFJvdW5kIC0gSWYgdGhlIG9mZnNldHMgc2hvdWxkIGJlIHJvdW5kZWQgYXQgYWxsXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgcG9wcGVyJ3MgcG9zaXRpb24gb2Zmc2V0cyByb3VuZGVkXG4gKlxuICogVGhlIHRhbGUgb2YgcGl4ZWwtcGVyZmVjdCBwb3NpdGlvbmluZy4gSXQncyBzdGlsbCBub3QgMTAwJSBwZXJmZWN0LCBidXQgYXNcbiAqIGdvb2QgYXMgaXQgY2FuIGJlIHdpdGhpbiByZWFzb24uXG4gKiBEaXNjdXNzaW9uIGhlcmU6IGh0dHBzOi8vZ2l0aHViLmNvbS9GZXpWcmFzdGEvcG9wcGVyLmpzL3B1bGwvNzE1XG4gKlxuICogTG93IERQSSBzY3JlZW5zIGNhdXNlIGEgcG9wcGVyIHRvIGJlIGJsdXJyeSBpZiBub3QgdXNpbmcgZnVsbCBwaXhlbHMgKFNhZmFyaVxuICogYXMgd2VsbCBvbiBIaWdoIERQSSBzY3JlZW5zKS5cbiAqXG4gKiBGaXJlZm94IHByZWZlcnMgbm8gcm91bmRpbmcgZm9yIHBvc2l0aW9uaW5nIGFuZCBkb2VzIG5vdCBoYXZlIGJsdXJyaW5lc3Mgb25cbiAqIGhpZ2ggRFBJIHNjcmVlbnMuXG4gKlxuICogT25seSBob3Jpem9udGFsIHBsYWNlbWVudCBhbmQgbGVmdC9yaWdodCB2YWx1ZXMgbmVlZCB0byBiZSBjb25zaWRlcmVkLlxuICovXG5mdW5jdGlvbiBnZXRSb3VuZGVkT2Zmc2V0cyhkYXRhLCBzaG91bGRSb3VuZCkge1xuICB2YXIgX2RhdGEkb2Zmc2V0cyA9IGRhdGEub2Zmc2V0cyxcbiAgICAgIHBvcHBlciA9IF9kYXRhJG9mZnNldHMucG9wcGVyLFxuICAgICAgcmVmZXJlbmNlID0gX2RhdGEkb2Zmc2V0cy5yZWZlcmVuY2U7XG5cblxuICB2YXIgaXNWZXJ0aWNhbCA9IFsnbGVmdCcsICdyaWdodCddLmluZGV4T2YoZGF0YS5wbGFjZW1lbnQpICE9PSAtMTtcbiAgdmFyIGlzVmFyaWF0aW9uID0gZGF0YS5wbGFjZW1lbnQuaW5kZXhPZignLScpICE9PSAtMTtcbiAgdmFyIHNhbWVXaWR0aE9kZG5lc3MgPSByZWZlcmVuY2Uud2lkdGggJSAyID09PSBwb3BwZXIud2lkdGggJSAyO1xuICB2YXIgYm90aE9kZFdpZHRoID0gcmVmZXJlbmNlLndpZHRoICUgMiA9PT0gMSAmJiBwb3BwZXIud2lkdGggJSAyID09PSAxO1xuICB2YXIgbm9Sb3VuZCA9IGZ1bmN0aW9uIG5vUm91bmQodikge1xuICAgIHJldHVybiB2O1xuICB9O1xuXG4gIHZhciBob3Jpem9udGFsVG9JbnRlZ2VyID0gIXNob3VsZFJvdW5kID8gbm9Sb3VuZCA6IGlzVmVydGljYWwgfHwgaXNWYXJpYXRpb24gfHwgc2FtZVdpZHRoT2RkbmVzcyA/IE1hdGgucm91bmQgOiBNYXRoLmZsb29yO1xuICB2YXIgdmVydGljYWxUb0ludGVnZXIgPSAhc2hvdWxkUm91bmQgPyBub1JvdW5kIDogTWF0aC5yb3VuZDtcblxuICByZXR1cm4ge1xuICAgIGxlZnQ6IGhvcml6b250YWxUb0ludGVnZXIoYm90aE9kZFdpZHRoICYmICFpc1ZhcmlhdGlvbiAmJiBzaG91bGRSb3VuZCA/IHBvcHBlci5sZWZ0IC0gMSA6IHBvcHBlci5sZWZ0KSxcbiAgICB0b3A6IHZlcnRpY2FsVG9JbnRlZ2VyKHBvcHBlci50b3ApLFxuICAgIGJvdHRvbTogdmVydGljYWxUb0ludGVnZXIocG9wcGVyLmJvdHRvbSksXG4gICAgcmlnaHQ6IGhvcml6b250YWxUb0ludGVnZXIocG9wcGVyLnJpZ2h0KVxuICB9O1xufVxuXG52YXIgaXNGaXJlZm94ID0gaXNCcm93c2VyICYmIC9GaXJlZm94L2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiBNb2RpZmllcnNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSBgdXBkYXRlYCBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBkYXRhIG9iamVjdCwgcHJvcGVybHkgbW9kaWZpZWRcbiAqL1xuZnVuY3Rpb24gY29tcHV0ZVN0eWxlKGRhdGEsIG9wdGlvbnMpIHtcbiAgdmFyIHggPSBvcHRpb25zLngsXG4gICAgICB5ID0gb3B0aW9ucy55O1xuICB2YXIgcG9wcGVyID0gZGF0YS5vZmZzZXRzLnBvcHBlcjtcblxuICAvLyBSZW1vdmUgdGhpcyBsZWdhY3kgc3VwcG9ydCBpbiBQb3BwZXIuanMgdjJcblxuICB2YXIgbGVnYWN5R3B1QWNjZWxlcmF0aW9uT3B0aW9uID0gZmluZChkYXRhLmluc3RhbmNlLm1vZGlmaWVycywgZnVuY3Rpb24gKG1vZGlmaWVyKSB7XG4gICAgcmV0dXJuIG1vZGlmaWVyLm5hbWUgPT09ICdhcHBseVN0eWxlJztcbiAgfSkuZ3B1QWNjZWxlcmF0aW9uO1xuICBpZiAobGVnYWN5R3B1QWNjZWxlcmF0aW9uT3B0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICBjb25zb2xlLndhcm4oJ1dBUk5JTkc6IGBncHVBY2NlbGVyYXRpb25gIG9wdGlvbiBtb3ZlZCB0byBgY29tcHV0ZVN0eWxlYCBtb2RpZmllciBhbmQgd2lsbCBub3QgYmUgc3VwcG9ydGVkIGluIGZ1dHVyZSB2ZXJzaW9ucyBvZiBQb3BwZXIuanMhJyk7XG4gIH1cbiAgdmFyIGdwdUFjY2VsZXJhdGlvbiA9IGxlZ2FjeUdwdUFjY2VsZXJhdGlvbk9wdGlvbiAhPT0gdW5kZWZpbmVkID8gbGVnYWN5R3B1QWNjZWxlcmF0aW9uT3B0aW9uIDogb3B0aW9ucy5ncHVBY2NlbGVyYXRpb247XG5cbiAgdmFyIG9mZnNldFBhcmVudCA9IGdldE9mZnNldFBhcmVudChkYXRhLmluc3RhbmNlLnBvcHBlcik7XG4gIHZhciBvZmZzZXRQYXJlbnRSZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KG9mZnNldFBhcmVudCk7XG5cbiAgLy8gU3R5bGVzXG4gIHZhciBzdHlsZXMgPSB7XG4gICAgcG9zaXRpb246IHBvcHBlci5wb3NpdGlvblxuICB9O1xuXG4gIHZhciBvZmZzZXRzID0gZ2V0Um91bmRlZE9mZnNldHMoZGF0YSwgd2luZG93LmRldmljZVBpeGVsUmF0aW8gPCAyIHx8ICFpc0ZpcmVmb3gpO1xuXG4gIHZhciBzaWRlQSA9IHggPT09ICdib3R0b20nID8gJ3RvcCcgOiAnYm90dG9tJztcbiAgdmFyIHNpZGVCID0geSA9PT0gJ3JpZ2h0JyA/ICdsZWZ0JyA6ICdyaWdodCc7XG5cbiAgLy8gaWYgZ3B1QWNjZWxlcmF0aW9uIGlzIHNldCB0byBgdHJ1ZWAgYW5kIHRyYW5zZm9ybSBpcyBzdXBwb3J0ZWQsXG4gIC8vICB3ZSB1c2UgYHRyYW5zbGF0ZTNkYCB0byBhcHBseSB0aGUgcG9zaXRpb24gdG8gdGhlIHBvcHBlciB3ZVxuICAvLyBhdXRvbWF0aWNhbGx5IHVzZSB0aGUgc3VwcG9ydGVkIHByZWZpeGVkIHZlcnNpb24gaWYgbmVlZGVkXG4gIHZhciBwcmVmaXhlZFByb3BlcnR5ID0gZ2V0U3VwcG9ydGVkUHJvcGVydHlOYW1lKCd0cmFuc2Zvcm0nKTtcblxuICAvLyBub3csIGxldCdzIG1ha2UgYSBzdGVwIGJhY2sgYW5kIGxvb2sgYXQgdGhpcyBjb2RlIGNsb3NlbHkgKHd0Zj8pXG4gIC8vIElmIHRoZSBjb250ZW50IG9mIHRoZSBwb3BwZXIgZ3Jvd3Mgb25jZSBpdCdzIGJlZW4gcG9zaXRpb25lZCwgaXRcbiAgLy8gbWF5IGhhcHBlbiB0aGF0IHRoZSBwb3BwZXIgZ2V0cyBtaXNwbGFjZWQgYmVjYXVzZSBvZiB0aGUgbmV3IGNvbnRlbnRcbiAgLy8gb3ZlcmZsb3dpbmcgaXRzIHJlZmVyZW5jZSBlbGVtZW50XG4gIC8vIFRvIGF2b2lkIHRoaXMgcHJvYmxlbSwgd2UgcHJvdmlkZSB0d28gb3B0aW9ucyAoeCBhbmQgeSksIHdoaWNoIGFsbG93XG4gIC8vIHRoZSBjb25zdW1lciB0byBkZWZpbmUgdGhlIG9mZnNldCBvcmlnaW4uXG4gIC8vIElmIHdlIHBvc2l0aW9uIGEgcG9wcGVyIG9uIHRvcCBvZiBhIHJlZmVyZW5jZSBlbGVtZW50LCB3ZSBjYW4gc2V0XG4gIC8vIGB4YCB0byBgdG9wYCB0byBtYWtlIHRoZSBwb3BwZXIgZ3JvdyB0b3dhcmRzIGl0cyB0b3AgaW5zdGVhZCBvZlxuICAvLyBpdHMgYm90dG9tLlxuICB2YXIgbGVmdCA9IHZvaWQgMCxcbiAgICAgIHRvcCA9IHZvaWQgMDtcbiAgaWYgKHNpZGVBID09PSAnYm90dG9tJykge1xuICAgIC8vIHdoZW4gb2Zmc2V0UGFyZW50IGlzIDxodG1sPiB0aGUgcG9zaXRpb25pbmcgaXMgcmVsYXRpdmUgdG8gdGhlIGJvdHRvbSBvZiB0aGUgc2NyZWVuIChleGNsdWRpbmcgdGhlIHNjcm9sbGJhcilcbiAgICAvLyBhbmQgbm90IHRoZSBib3R0b20gb2YgdGhlIGh0bWwgZWxlbWVudFxuICAgIGlmIChvZmZzZXRQYXJlbnQubm9kZU5hbWUgPT09ICdIVE1MJykge1xuICAgICAgdG9wID0gLW9mZnNldFBhcmVudC5jbGllbnRIZWlnaHQgKyBvZmZzZXRzLmJvdHRvbTtcbiAgICB9IGVsc2Uge1xuICAgICAgdG9wID0gLW9mZnNldFBhcmVudFJlY3QuaGVpZ2h0ICsgb2Zmc2V0cy5ib3R0b207XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRvcCA9IG9mZnNldHMudG9wO1xuICB9XG4gIGlmIChzaWRlQiA9PT0gJ3JpZ2h0Jykge1xuICAgIGlmIChvZmZzZXRQYXJlbnQubm9kZU5hbWUgPT09ICdIVE1MJykge1xuICAgICAgbGVmdCA9IC1vZmZzZXRQYXJlbnQuY2xpZW50V2lkdGggKyBvZmZzZXRzLnJpZ2h0O1xuICAgIH0gZWxzZSB7XG4gICAgICBsZWZ0ID0gLW9mZnNldFBhcmVudFJlY3Qud2lkdGggKyBvZmZzZXRzLnJpZ2h0O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBsZWZ0ID0gb2Zmc2V0cy5sZWZ0O1xuICB9XG4gIGlmIChncHVBY2NlbGVyYXRpb24gJiYgcHJlZml4ZWRQcm9wZXJ0eSkge1xuICAgIHN0eWxlc1twcmVmaXhlZFByb3BlcnR5XSA9ICd0cmFuc2xhdGUzZCgnICsgbGVmdCArICdweCwgJyArIHRvcCArICdweCwgMCknO1xuICAgIHN0eWxlc1tzaWRlQV0gPSAwO1xuICAgIHN0eWxlc1tzaWRlQl0gPSAwO1xuICAgIHN0eWxlcy53aWxsQ2hhbmdlID0gJ3RyYW5zZm9ybSc7XG4gIH0gZWxzZSB7XG4gICAgLy8gb3Rod2VyaXNlLCB3ZSB1c2UgdGhlIHN0YW5kYXJkIGB0b3BgLCBgbGVmdGAsIGBib3R0b21gIGFuZCBgcmlnaHRgIHByb3BlcnRpZXNcbiAgICB2YXIgaW52ZXJ0VG9wID0gc2lkZUEgPT09ICdib3R0b20nID8gLTEgOiAxO1xuICAgIHZhciBpbnZlcnRMZWZ0ID0gc2lkZUIgPT09ICdyaWdodCcgPyAtMSA6IDE7XG4gICAgc3R5bGVzW3NpZGVBXSA9IHRvcCAqIGludmVydFRvcDtcbiAgICBzdHlsZXNbc2lkZUJdID0gbGVmdCAqIGludmVydExlZnQ7XG4gICAgc3R5bGVzLndpbGxDaGFuZ2UgPSBzaWRlQSArICcsICcgKyBzaWRlQjtcbiAgfVxuXG4gIC8vIEF0dHJpYnV0ZXNcbiAgdmFyIGF0dHJpYnV0ZXMgPSB7XG4gICAgJ3gtcGxhY2VtZW50JzogZGF0YS5wbGFjZW1lbnRcbiAgfTtcblxuICAvLyBVcGRhdGUgYGRhdGFgIGF0dHJpYnV0ZXMsIHN0eWxlcyBhbmQgYXJyb3dTdHlsZXNcbiAgZGF0YS5hdHRyaWJ1dGVzID0gX2V4dGVuZHMoe30sIGF0dHJpYnV0ZXMsIGRhdGEuYXR0cmlidXRlcyk7XG4gIGRhdGEuc3R5bGVzID0gX2V4dGVuZHMoe30sIHN0eWxlcywgZGF0YS5zdHlsZXMpO1xuICBkYXRhLmFycm93U3R5bGVzID0gX2V4dGVuZHMoe30sIGRhdGEub2Zmc2V0cy5hcnJvdywgZGF0YS5hcnJvd1N0eWxlcyk7XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogSGVscGVyIHVzZWQgdG8ga25vdyBpZiB0aGUgZ2l2ZW4gbW9kaWZpZXIgZGVwZW5kcyBmcm9tIGFub3RoZXIgb25lLjxiciAvPlxuICogSXQgY2hlY2tzIGlmIHRoZSBuZWVkZWQgbW9kaWZpZXIgaXMgbGlzdGVkIGFuZCBlbmFibGVkLlxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHBhcmFtIHtBcnJheX0gbW9kaWZpZXJzIC0gbGlzdCBvZiBtb2RpZmllcnNcbiAqIEBwYXJhbSB7U3RyaW5nfSByZXF1ZXN0aW5nTmFtZSAtIG5hbWUgb2YgcmVxdWVzdGluZyBtb2RpZmllclxuICogQHBhcmFtIHtTdHJpbmd9IHJlcXVlc3RlZE5hbWUgLSBuYW1lIG9mIHJlcXVlc3RlZCBtb2RpZmllclxuICogQHJldHVybnMge0Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzTW9kaWZpZXJSZXF1aXJlZChtb2RpZmllcnMsIHJlcXVlc3RpbmdOYW1lLCByZXF1ZXN0ZWROYW1lKSB7XG4gIHZhciByZXF1ZXN0aW5nID0gZmluZChtb2RpZmllcnMsIGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgdmFyIG5hbWUgPSBfcmVmLm5hbWU7XG4gICAgcmV0dXJuIG5hbWUgPT09IHJlcXVlc3RpbmdOYW1lO1xuICB9KTtcblxuICB2YXIgaXNSZXF1aXJlZCA9ICEhcmVxdWVzdGluZyAmJiBtb2RpZmllcnMuc29tZShmdW5jdGlvbiAobW9kaWZpZXIpIHtcbiAgICByZXR1cm4gbW9kaWZpZXIubmFtZSA9PT0gcmVxdWVzdGVkTmFtZSAmJiBtb2RpZmllci5lbmFibGVkICYmIG1vZGlmaWVyLm9yZGVyIDwgcmVxdWVzdGluZy5vcmRlcjtcbiAgfSk7XG5cbiAgaWYgKCFpc1JlcXVpcmVkKSB7XG4gICAgdmFyIF9yZXF1ZXN0aW5nID0gJ2AnICsgcmVxdWVzdGluZ05hbWUgKyAnYCc7XG4gICAgdmFyIHJlcXVlc3RlZCA9ICdgJyArIHJlcXVlc3RlZE5hbWUgKyAnYCc7XG4gICAgY29uc29sZS53YXJuKHJlcXVlc3RlZCArICcgbW9kaWZpZXIgaXMgcmVxdWlyZWQgYnkgJyArIF9yZXF1ZXN0aW5nICsgJyBtb2RpZmllciBpbiBvcmRlciB0byB3b3JrLCBiZSBzdXJlIHRvIGluY2x1ZGUgaXQgYmVmb3JlICcgKyBfcmVxdWVzdGluZyArICchJyk7XG4gIH1cbiAgcmV0dXJuIGlzUmVxdWlyZWQ7XG59XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YgTW9kaWZpZXJzXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgdXBkYXRlIG1ldGhvZFxuICogQGFyZ3VtZW50IHtPYmplY3R9IG9wdGlvbnMgLSBNb2RpZmllcnMgY29uZmlndXJhdGlvbiBhbmQgb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdH0gVGhlIGRhdGEgb2JqZWN0LCBwcm9wZXJseSBtb2RpZmllZFxuICovXG5mdW5jdGlvbiBhcnJvdyhkYXRhLCBvcHRpb25zKSB7XG4gIHZhciBfZGF0YSRvZmZzZXRzJGFycm93O1xuXG4gIC8vIGFycm93IGRlcGVuZHMgb24ga2VlcFRvZ2V0aGVyIGluIG9yZGVyIHRvIHdvcmtcbiAgaWYgKCFpc01vZGlmaWVyUmVxdWlyZWQoZGF0YS5pbnN0YW5jZS5tb2RpZmllcnMsICdhcnJvdycsICdrZWVwVG9nZXRoZXInKSkge1xuICAgIHJldHVybiBkYXRhO1xuICB9XG5cbiAgdmFyIGFycm93RWxlbWVudCA9IG9wdGlvbnMuZWxlbWVudDtcblxuICAvLyBpZiBhcnJvd0VsZW1lbnQgaXMgYSBzdHJpbmcsIHN1cHBvc2UgaXQncyBhIENTUyBzZWxlY3RvclxuICBpZiAodHlwZW9mIGFycm93RWxlbWVudCA9PT0gJ3N0cmluZycpIHtcbiAgICBhcnJvd0VsZW1lbnQgPSBkYXRhLmluc3RhbmNlLnBvcHBlci5xdWVyeVNlbGVjdG9yKGFycm93RWxlbWVudCk7XG5cbiAgICAvLyBpZiBhcnJvd0VsZW1lbnQgaXMgbm90IGZvdW5kLCBkb24ndCBydW4gdGhlIG1vZGlmaWVyXG4gICAgaWYgKCFhcnJvd0VsZW1lbnQpIHtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBpZiB0aGUgYXJyb3dFbGVtZW50IGlzbid0IGEgcXVlcnkgc2VsZWN0b3Igd2UgbXVzdCBjaGVjayB0aGF0IHRoZVxuICAgIC8vIHByb3ZpZGVkIERPTSBub2RlIGlzIGNoaWxkIG9mIGl0cyBwb3BwZXIgbm9kZVxuICAgIGlmICghZGF0YS5pbnN0YW5jZS5wb3BwZXIuY29udGFpbnMoYXJyb3dFbGVtZW50KSkge1xuICAgICAgY29uc29sZS53YXJuKCdXQVJOSU5HOiBgYXJyb3cuZWxlbWVudGAgbXVzdCBiZSBjaGlsZCBvZiBpdHMgcG9wcGVyIGVsZW1lbnQhJyk7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gIH1cblxuICB2YXIgcGxhY2VtZW50ID0gZGF0YS5wbGFjZW1lbnQuc3BsaXQoJy0nKVswXTtcbiAgdmFyIF9kYXRhJG9mZnNldHMgPSBkYXRhLm9mZnNldHMsXG4gICAgICBwb3BwZXIgPSBfZGF0YSRvZmZzZXRzLnBvcHBlcixcbiAgICAgIHJlZmVyZW5jZSA9IF9kYXRhJG9mZnNldHMucmVmZXJlbmNlO1xuXG4gIHZhciBpc1ZlcnRpY2FsID0gWydsZWZ0JywgJ3JpZ2h0J10uaW5kZXhPZihwbGFjZW1lbnQpICE9PSAtMTtcblxuICB2YXIgbGVuID0gaXNWZXJ0aWNhbCA/ICdoZWlnaHQnIDogJ3dpZHRoJztcbiAgdmFyIHNpZGVDYXBpdGFsaXplZCA9IGlzVmVydGljYWwgPyAnVG9wJyA6ICdMZWZ0JztcbiAgdmFyIHNpZGUgPSBzaWRlQ2FwaXRhbGl6ZWQudG9Mb3dlckNhc2UoKTtcbiAgdmFyIGFsdFNpZGUgPSBpc1ZlcnRpY2FsID8gJ2xlZnQnIDogJ3RvcCc7XG4gIHZhciBvcFNpZGUgPSBpc1ZlcnRpY2FsID8gJ2JvdHRvbScgOiAncmlnaHQnO1xuICB2YXIgYXJyb3dFbGVtZW50U2l6ZSA9IGdldE91dGVyU2l6ZXMoYXJyb3dFbGVtZW50KVtsZW5dO1xuXG4gIC8vXG4gIC8vIGV4dGVuZHMga2VlcFRvZ2V0aGVyIGJlaGF2aW9yIG1ha2luZyBzdXJlIHRoZSBwb3BwZXIgYW5kIGl0c1xuICAvLyByZWZlcmVuY2UgaGF2ZSBlbm91Z2ggcGl4ZWxzIGluIGNvbmp1bmN0aW9uXG4gIC8vXG5cbiAgLy8gdG9wL2xlZnQgc2lkZVxuICBpZiAocmVmZXJlbmNlW29wU2lkZV0gLSBhcnJvd0VsZW1lbnRTaXplIDwgcG9wcGVyW3NpZGVdKSB7XG4gICAgZGF0YS5vZmZzZXRzLnBvcHBlcltzaWRlXSAtPSBwb3BwZXJbc2lkZV0gLSAocmVmZXJlbmNlW29wU2lkZV0gLSBhcnJvd0VsZW1lbnRTaXplKTtcbiAgfVxuICAvLyBib3R0b20vcmlnaHQgc2lkZVxuICBpZiAocmVmZXJlbmNlW3NpZGVdICsgYXJyb3dFbGVtZW50U2l6ZSA+IHBvcHBlcltvcFNpZGVdKSB7XG4gICAgZGF0YS5vZmZzZXRzLnBvcHBlcltzaWRlXSArPSByZWZlcmVuY2Vbc2lkZV0gKyBhcnJvd0VsZW1lbnRTaXplIC0gcG9wcGVyW29wU2lkZV07XG4gIH1cbiAgZGF0YS5vZmZzZXRzLnBvcHBlciA9IGdldENsaWVudFJlY3QoZGF0YS5vZmZzZXRzLnBvcHBlcik7XG5cbiAgLy8gY29tcHV0ZSBjZW50ZXIgb2YgdGhlIHBvcHBlclxuICB2YXIgY2VudGVyID0gcmVmZXJlbmNlW3NpZGVdICsgcmVmZXJlbmNlW2xlbl0gLyAyIC0gYXJyb3dFbGVtZW50U2l6ZSAvIDI7XG5cbiAgLy8gQ29tcHV0ZSB0aGUgc2lkZVZhbHVlIHVzaW5nIHRoZSB1cGRhdGVkIHBvcHBlciBvZmZzZXRzXG4gIC8vIHRha2UgcG9wcGVyIG1hcmdpbiBpbiBhY2NvdW50IGJlY2F1c2Ugd2UgZG9uJ3QgaGF2ZSB0aGlzIGluZm8gYXZhaWxhYmxlXG4gIHZhciBjc3MgPSBnZXRTdHlsZUNvbXB1dGVkUHJvcGVydHkoZGF0YS5pbnN0YW5jZS5wb3BwZXIpO1xuICB2YXIgcG9wcGVyTWFyZ2luU2lkZSA9IHBhcnNlRmxvYXQoY3NzWydtYXJnaW4nICsgc2lkZUNhcGl0YWxpemVkXSwgMTApO1xuICB2YXIgcG9wcGVyQm9yZGVyU2lkZSA9IHBhcnNlRmxvYXQoY3NzWydib3JkZXInICsgc2lkZUNhcGl0YWxpemVkICsgJ1dpZHRoJ10sIDEwKTtcbiAgdmFyIHNpZGVWYWx1ZSA9IGNlbnRlciAtIGRhdGEub2Zmc2V0cy5wb3BwZXJbc2lkZV0gLSBwb3BwZXJNYXJnaW5TaWRlIC0gcG9wcGVyQm9yZGVyU2lkZTtcblxuICAvLyBwcmV2ZW50IGFycm93RWxlbWVudCBmcm9tIGJlaW5nIHBsYWNlZCBub3QgY29udGlndW91c2x5IHRvIGl0cyBwb3BwZXJcbiAgc2lkZVZhbHVlID0gTWF0aC5tYXgoTWF0aC5taW4ocG9wcGVyW2xlbl0gLSBhcnJvd0VsZW1lbnRTaXplLCBzaWRlVmFsdWUpLCAwKTtcblxuICBkYXRhLmFycm93RWxlbWVudCA9IGFycm93RWxlbWVudDtcbiAgZGF0YS5vZmZzZXRzLmFycm93ID0gKF9kYXRhJG9mZnNldHMkYXJyb3cgPSB7fSwgZGVmaW5lUHJvcGVydHkoX2RhdGEkb2Zmc2V0cyRhcnJvdywgc2lkZSwgTWF0aC5yb3VuZChzaWRlVmFsdWUpKSwgZGVmaW5lUHJvcGVydHkoX2RhdGEkb2Zmc2V0cyRhcnJvdywgYWx0U2lkZSwgJycpLCBfZGF0YSRvZmZzZXRzJGFycm93KTtcblxuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIG9wcG9zaXRlIHBsYWNlbWVudCB2YXJpYXRpb24gb2YgdGhlIGdpdmVuIG9uZVxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtTdHJpbmd9IHBsYWNlbWVudCB2YXJpYXRpb25cbiAqIEByZXR1cm5zIHtTdHJpbmd9IGZsaXBwZWQgcGxhY2VtZW50IHZhcmlhdGlvblxuICovXG5mdW5jdGlvbiBnZXRPcHBvc2l0ZVZhcmlhdGlvbih2YXJpYXRpb24pIHtcbiAgaWYgKHZhcmlhdGlvbiA9PT0gJ2VuZCcpIHtcbiAgICByZXR1cm4gJ3N0YXJ0JztcbiAgfSBlbHNlIGlmICh2YXJpYXRpb24gPT09ICdzdGFydCcpIHtcbiAgICByZXR1cm4gJ2VuZCc7XG4gIH1cbiAgcmV0dXJuIHZhcmlhdGlvbjtcbn1cblxuLyoqXG4gKiBMaXN0IG9mIGFjY2VwdGVkIHBsYWNlbWVudHMgdG8gdXNlIGFzIHZhbHVlcyBvZiB0aGUgYHBsYWNlbWVudGAgb3B0aW9uLjxiciAvPlxuICogVmFsaWQgcGxhY2VtZW50cyBhcmU6XG4gKiAtIGBhdXRvYFxuICogLSBgdG9wYFxuICogLSBgcmlnaHRgXG4gKiAtIGBib3R0b21gXG4gKiAtIGBsZWZ0YFxuICpcbiAqIEVhY2ggcGxhY2VtZW50IGNhbiBoYXZlIGEgdmFyaWF0aW9uIGZyb20gdGhpcyBsaXN0OlxuICogLSBgLXN0YXJ0YFxuICogLSBgLWVuZGBcbiAqXG4gKiBWYXJpYXRpb25zIGFyZSBpbnRlcnByZXRlZCBlYXNpbHkgaWYgeW91IHRoaW5rIG9mIHRoZW0gYXMgdGhlIGxlZnQgdG8gcmlnaHRcbiAqIHdyaXR0ZW4gbGFuZ3VhZ2VzLiBIb3Jpem9udGFsbHkgKGB0b3BgIGFuZCBgYm90dG9tYCksIGBzdGFydGAgaXMgbGVmdCBhbmQgYGVuZGBcbiAqIGlzIHJpZ2h0LjxiciAvPlxuICogVmVydGljYWxseSAoYGxlZnRgIGFuZCBgcmlnaHRgKSwgYHN0YXJ0YCBpcyB0b3AgYW5kIGBlbmRgIGlzIGJvdHRvbS5cbiAqXG4gKiBTb21lIHZhbGlkIGV4YW1wbGVzIGFyZTpcbiAqIC0gYHRvcC1lbmRgIChvbiB0b3Agb2YgcmVmZXJlbmNlLCByaWdodCBhbGlnbmVkKVxuICogLSBgcmlnaHQtc3RhcnRgIChvbiByaWdodCBvZiByZWZlcmVuY2UsIHRvcCBhbGlnbmVkKVxuICogLSBgYm90dG9tYCAob24gYm90dG9tLCBjZW50ZXJlZClcbiAqIC0gYGF1dG8tZW5kYCAob24gdGhlIHNpZGUgd2l0aCBtb3JlIHNwYWNlIGF2YWlsYWJsZSwgYWxpZ25tZW50IGRlcGVuZHMgYnkgcGxhY2VtZW50KVxuICpcbiAqIEBzdGF0aWNcbiAqIEB0eXBlIHtBcnJheX1cbiAqIEBlbnVtIHtTdHJpbmd9XG4gKiBAcmVhZG9ubHlcbiAqIEBtZXRob2QgcGxhY2VtZW50c1xuICogQG1lbWJlcm9mIFBvcHBlclxuICovXG52YXIgcGxhY2VtZW50cyA9IFsnYXV0by1zdGFydCcsICdhdXRvJywgJ2F1dG8tZW5kJywgJ3RvcC1zdGFydCcsICd0b3AnLCAndG9wLWVuZCcsICdyaWdodC1zdGFydCcsICdyaWdodCcsICdyaWdodC1lbmQnLCAnYm90dG9tLWVuZCcsICdib3R0b20nLCAnYm90dG9tLXN0YXJ0JywgJ2xlZnQtZW5kJywgJ2xlZnQnLCAnbGVmdC1zdGFydCddO1xuXG4vLyBHZXQgcmlkIG9mIGBhdXRvYCBgYXV0by1zdGFydGAgYW5kIGBhdXRvLWVuZGBcbnZhciB2YWxpZFBsYWNlbWVudHMgPSBwbGFjZW1lbnRzLnNsaWNlKDMpO1xuXG4vKipcbiAqIEdpdmVuIGFuIGluaXRpYWwgcGxhY2VtZW50LCByZXR1cm5zIGFsbCB0aGUgc3Vic2VxdWVudCBwbGFjZW1lbnRzXG4gKiBjbG9ja3dpc2UgKG9yIGNvdW50ZXItY2xvY2t3aXNlKS5cbiAqXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge1N0cmluZ30gcGxhY2VtZW50IC0gQSB2YWxpZCBwbGFjZW1lbnQgKGl0IGFjY2VwdHMgdmFyaWF0aW9ucylcbiAqIEBhcmd1bWVudCB7Qm9vbGVhbn0gY291bnRlciAtIFNldCB0byB0cnVlIHRvIHdhbGsgdGhlIHBsYWNlbWVudHMgY291bnRlcmNsb2Nrd2lzZVxuICogQHJldHVybnMge0FycmF5fSBwbGFjZW1lbnRzIGluY2x1ZGluZyB0aGVpciB2YXJpYXRpb25zXG4gKi9cbmZ1bmN0aW9uIGNsb2Nrd2lzZShwbGFjZW1lbnQpIHtcbiAgdmFyIGNvdW50ZXIgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuXG4gIHZhciBpbmRleCA9IHZhbGlkUGxhY2VtZW50cy5pbmRleE9mKHBsYWNlbWVudCk7XG4gIHZhciBhcnIgPSB2YWxpZFBsYWNlbWVudHMuc2xpY2UoaW5kZXggKyAxKS5jb25jYXQodmFsaWRQbGFjZW1lbnRzLnNsaWNlKDAsIGluZGV4KSk7XG4gIHJldHVybiBjb3VudGVyID8gYXJyLnJldmVyc2UoKSA6IGFycjtcbn1cblxudmFyIEJFSEFWSU9SUyA9IHtcbiAgRkxJUDogJ2ZsaXAnLFxuICBDTE9DS1dJU0U6ICdjbG9ja3dpc2UnLFxuICBDT1VOVEVSQ0xPQ0tXSVNFOiAnY291bnRlcmNsb2Nrd2lzZSdcbn07XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YgTW9kaWZpZXJzXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgdXBkYXRlIG1ldGhvZFxuICogQGFyZ3VtZW50IHtPYmplY3R9IG9wdGlvbnMgLSBNb2RpZmllcnMgY29uZmlndXJhdGlvbiBhbmQgb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdH0gVGhlIGRhdGEgb2JqZWN0LCBwcm9wZXJseSBtb2RpZmllZFxuICovXG5mdW5jdGlvbiBmbGlwKGRhdGEsIG9wdGlvbnMpIHtcbiAgLy8gaWYgYGlubmVyYCBtb2RpZmllciBpcyBlbmFibGVkLCB3ZSBjYW4ndCB1c2UgdGhlIGBmbGlwYCBtb2RpZmllclxuICBpZiAoaXNNb2RpZmllckVuYWJsZWQoZGF0YS5pbnN0YW5jZS5tb2RpZmllcnMsICdpbm5lcicpKSB7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cblxuICBpZiAoZGF0YS5mbGlwcGVkICYmIGRhdGEucGxhY2VtZW50ID09PSBkYXRhLm9yaWdpbmFsUGxhY2VtZW50KSB7XG4gICAgLy8gc2VlbXMgbGlrZSBmbGlwIGlzIHRyeWluZyB0byBsb29wLCBwcm9iYWJseSB0aGVyZSdzIG5vdCBlbm91Z2ggc3BhY2Ugb24gYW55IG9mIHRoZSBmbGlwcGFibGUgc2lkZXNcbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuXG4gIHZhciBib3VuZGFyaWVzID0gZ2V0Qm91bmRhcmllcyhkYXRhLmluc3RhbmNlLnBvcHBlciwgZGF0YS5pbnN0YW5jZS5yZWZlcmVuY2UsIG9wdGlvbnMucGFkZGluZywgb3B0aW9ucy5ib3VuZGFyaWVzRWxlbWVudCwgZGF0YS5wb3NpdGlvbkZpeGVkKTtcblxuICB2YXIgcGxhY2VtZW50ID0gZGF0YS5wbGFjZW1lbnQuc3BsaXQoJy0nKVswXTtcbiAgdmFyIHBsYWNlbWVudE9wcG9zaXRlID0gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQocGxhY2VtZW50KTtcbiAgdmFyIHZhcmlhdGlvbiA9IGRhdGEucGxhY2VtZW50LnNwbGl0KCctJylbMV0gfHwgJyc7XG5cbiAgdmFyIGZsaXBPcmRlciA9IFtdO1xuXG4gIHN3aXRjaCAob3B0aW9ucy5iZWhhdmlvcikge1xuICAgIGNhc2UgQkVIQVZJT1JTLkZMSVA6XG4gICAgICBmbGlwT3JkZXIgPSBbcGxhY2VtZW50LCBwbGFjZW1lbnRPcHBvc2l0ZV07XG4gICAgICBicmVhaztcbiAgICBjYXNlIEJFSEFWSU9SUy5DTE9DS1dJU0U6XG4gICAgICBmbGlwT3JkZXIgPSBjbG9ja3dpc2UocGxhY2VtZW50KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgQkVIQVZJT1JTLkNPVU5URVJDTE9DS1dJU0U6XG4gICAgICBmbGlwT3JkZXIgPSBjbG9ja3dpc2UocGxhY2VtZW50LCB0cnVlKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBmbGlwT3JkZXIgPSBvcHRpb25zLmJlaGF2aW9yO1xuICB9XG5cbiAgZmxpcE9yZGVyLmZvckVhY2goZnVuY3Rpb24gKHN0ZXAsIGluZGV4KSB7XG4gICAgaWYgKHBsYWNlbWVudCAhPT0gc3RlcCB8fCBmbGlwT3JkZXIubGVuZ3RoID09PSBpbmRleCArIDEpIHtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cblxuICAgIHBsYWNlbWVudCA9IGRhdGEucGxhY2VtZW50LnNwbGl0KCctJylbMF07XG4gICAgcGxhY2VtZW50T3Bwb3NpdGUgPSBnZXRPcHBvc2l0ZVBsYWNlbWVudChwbGFjZW1lbnQpO1xuXG4gICAgdmFyIHBvcHBlck9mZnNldHMgPSBkYXRhLm9mZnNldHMucG9wcGVyO1xuICAgIHZhciByZWZPZmZzZXRzID0gZGF0YS5vZmZzZXRzLnJlZmVyZW5jZTtcblxuICAgIC8vIHVzaW5nIGZsb29yIGJlY2F1c2UgdGhlIHJlZmVyZW5jZSBvZmZzZXRzIG1heSBjb250YWluIGRlY2ltYWxzIHdlIGFyZSBub3QgZ29pbmcgdG8gY29uc2lkZXIgaGVyZVxuICAgIHZhciBmbG9vciA9IE1hdGguZmxvb3I7XG4gICAgdmFyIG92ZXJsYXBzUmVmID0gcGxhY2VtZW50ID09PSAnbGVmdCcgJiYgZmxvb3IocG9wcGVyT2Zmc2V0cy5yaWdodCkgPiBmbG9vcihyZWZPZmZzZXRzLmxlZnQpIHx8IHBsYWNlbWVudCA9PT0gJ3JpZ2h0JyAmJiBmbG9vcihwb3BwZXJPZmZzZXRzLmxlZnQpIDwgZmxvb3IocmVmT2Zmc2V0cy5yaWdodCkgfHwgcGxhY2VtZW50ID09PSAndG9wJyAmJiBmbG9vcihwb3BwZXJPZmZzZXRzLmJvdHRvbSkgPiBmbG9vcihyZWZPZmZzZXRzLnRvcCkgfHwgcGxhY2VtZW50ID09PSAnYm90dG9tJyAmJiBmbG9vcihwb3BwZXJPZmZzZXRzLnRvcCkgPCBmbG9vcihyZWZPZmZzZXRzLmJvdHRvbSk7XG5cbiAgICB2YXIgb3ZlcmZsb3dzTGVmdCA9IGZsb29yKHBvcHBlck9mZnNldHMubGVmdCkgPCBmbG9vcihib3VuZGFyaWVzLmxlZnQpO1xuICAgIHZhciBvdmVyZmxvd3NSaWdodCA9IGZsb29yKHBvcHBlck9mZnNldHMucmlnaHQpID4gZmxvb3IoYm91bmRhcmllcy5yaWdodCk7XG4gICAgdmFyIG92ZXJmbG93c1RvcCA9IGZsb29yKHBvcHBlck9mZnNldHMudG9wKSA8IGZsb29yKGJvdW5kYXJpZXMudG9wKTtcbiAgICB2YXIgb3ZlcmZsb3dzQm90dG9tID0gZmxvb3IocG9wcGVyT2Zmc2V0cy5ib3R0b20pID4gZmxvb3IoYm91bmRhcmllcy5ib3R0b20pO1xuXG4gICAgdmFyIG92ZXJmbG93c0JvdW5kYXJpZXMgPSBwbGFjZW1lbnQgPT09ICdsZWZ0JyAmJiBvdmVyZmxvd3NMZWZ0IHx8IHBsYWNlbWVudCA9PT0gJ3JpZ2h0JyAmJiBvdmVyZmxvd3NSaWdodCB8fCBwbGFjZW1lbnQgPT09ICd0b3AnICYmIG92ZXJmbG93c1RvcCB8fCBwbGFjZW1lbnQgPT09ICdib3R0b20nICYmIG92ZXJmbG93c0JvdHRvbTtcblxuICAgIC8vIGZsaXAgdGhlIHZhcmlhdGlvbiBpZiByZXF1aXJlZFxuICAgIHZhciBpc1ZlcnRpY2FsID0gWyd0b3AnLCAnYm90dG9tJ10uaW5kZXhPZihwbGFjZW1lbnQpICE9PSAtMTtcbiAgICB2YXIgZmxpcHBlZFZhcmlhdGlvbiA9ICEhb3B0aW9ucy5mbGlwVmFyaWF0aW9ucyAmJiAoaXNWZXJ0aWNhbCAmJiB2YXJpYXRpb24gPT09ICdzdGFydCcgJiYgb3ZlcmZsb3dzTGVmdCB8fCBpc1ZlcnRpY2FsICYmIHZhcmlhdGlvbiA9PT0gJ2VuZCcgJiYgb3ZlcmZsb3dzUmlnaHQgfHwgIWlzVmVydGljYWwgJiYgdmFyaWF0aW9uID09PSAnc3RhcnQnICYmIG92ZXJmbG93c1RvcCB8fCAhaXNWZXJ0aWNhbCAmJiB2YXJpYXRpb24gPT09ICdlbmQnICYmIG92ZXJmbG93c0JvdHRvbSk7XG5cbiAgICBpZiAob3ZlcmxhcHNSZWYgfHwgb3ZlcmZsb3dzQm91bmRhcmllcyB8fCBmbGlwcGVkVmFyaWF0aW9uKSB7XG4gICAgICAvLyB0aGlzIGJvb2xlYW4gdG8gZGV0ZWN0IGFueSBmbGlwIGxvb3BcbiAgICAgIGRhdGEuZmxpcHBlZCA9IHRydWU7XG5cbiAgICAgIGlmIChvdmVybGFwc1JlZiB8fCBvdmVyZmxvd3NCb3VuZGFyaWVzKSB7XG4gICAgICAgIHBsYWNlbWVudCA9IGZsaXBPcmRlcltpbmRleCArIDFdO1xuICAgICAgfVxuXG4gICAgICBpZiAoZmxpcHBlZFZhcmlhdGlvbikge1xuICAgICAgICB2YXJpYXRpb24gPSBnZXRPcHBvc2l0ZVZhcmlhdGlvbih2YXJpYXRpb24pO1xuICAgICAgfVxuXG4gICAgICBkYXRhLnBsYWNlbWVudCA9IHBsYWNlbWVudCArICh2YXJpYXRpb24gPyAnLScgKyB2YXJpYXRpb24gOiAnJyk7XG5cbiAgICAgIC8vIHRoaXMgb2JqZWN0IGNvbnRhaW5zIGBwb3NpdGlvbmAsIHdlIHdhbnQgdG8gcHJlc2VydmUgaXQgYWxvbmcgd2l0aFxuICAgICAgLy8gYW55IGFkZGl0aW9uYWwgcHJvcGVydHkgd2UgbWF5IGFkZCBpbiB0aGUgZnV0dXJlXG4gICAgICBkYXRhLm9mZnNldHMucG9wcGVyID0gX2V4dGVuZHMoe30sIGRhdGEub2Zmc2V0cy5wb3BwZXIsIGdldFBvcHBlck9mZnNldHMoZGF0YS5pbnN0YW5jZS5wb3BwZXIsIGRhdGEub2Zmc2V0cy5yZWZlcmVuY2UsIGRhdGEucGxhY2VtZW50KSk7XG5cbiAgICAgIGRhdGEgPSBydW5Nb2RpZmllcnMoZGF0YS5pbnN0YW5jZS5tb2RpZmllcnMsIGRhdGEsICdmbGlwJyk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YgTW9kaWZpZXJzXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgdXBkYXRlIG1ldGhvZFxuICogQGFyZ3VtZW50IHtPYmplY3R9IG9wdGlvbnMgLSBNb2RpZmllcnMgY29uZmlndXJhdGlvbiBhbmQgb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdH0gVGhlIGRhdGEgb2JqZWN0LCBwcm9wZXJseSBtb2RpZmllZFxuICovXG5mdW5jdGlvbiBrZWVwVG9nZXRoZXIoZGF0YSkge1xuICB2YXIgX2RhdGEkb2Zmc2V0cyA9IGRhdGEub2Zmc2V0cyxcbiAgICAgIHBvcHBlciA9IF9kYXRhJG9mZnNldHMucG9wcGVyLFxuICAgICAgcmVmZXJlbmNlID0gX2RhdGEkb2Zmc2V0cy5yZWZlcmVuY2U7XG5cbiAgdmFyIHBsYWNlbWVudCA9IGRhdGEucGxhY2VtZW50LnNwbGl0KCctJylbMF07XG4gIHZhciBmbG9vciA9IE1hdGguZmxvb3I7XG4gIHZhciBpc1ZlcnRpY2FsID0gWyd0b3AnLCAnYm90dG9tJ10uaW5kZXhPZihwbGFjZW1lbnQpICE9PSAtMTtcbiAgdmFyIHNpZGUgPSBpc1ZlcnRpY2FsID8gJ3JpZ2h0JyA6ICdib3R0b20nO1xuICB2YXIgb3BTaWRlID0gaXNWZXJ0aWNhbCA/ICdsZWZ0JyA6ICd0b3AnO1xuICB2YXIgbWVhc3VyZW1lbnQgPSBpc1ZlcnRpY2FsID8gJ3dpZHRoJyA6ICdoZWlnaHQnO1xuXG4gIGlmIChwb3BwZXJbc2lkZV0gPCBmbG9vcihyZWZlcmVuY2Vbb3BTaWRlXSkpIHtcbiAgICBkYXRhLm9mZnNldHMucG9wcGVyW29wU2lkZV0gPSBmbG9vcihyZWZlcmVuY2Vbb3BTaWRlXSkgLSBwb3BwZXJbbWVhc3VyZW1lbnRdO1xuICB9XG4gIGlmIChwb3BwZXJbb3BTaWRlXSA+IGZsb29yKHJlZmVyZW5jZVtzaWRlXSkpIHtcbiAgICBkYXRhLm9mZnNldHMucG9wcGVyW29wU2lkZV0gPSBmbG9vcihyZWZlcmVuY2Vbc2lkZV0pO1xuICB9XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogQ29udmVydHMgYSBzdHJpbmcgY29udGFpbmluZyB2YWx1ZSArIHVuaXQgaW50byBhIHB4IHZhbHVlIG51bWJlclxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2Yge21vZGlmaWVyc35vZmZzZXR9XG4gKiBAcHJpdmF0ZVxuICogQGFyZ3VtZW50IHtTdHJpbmd9IHN0ciAtIFZhbHVlICsgdW5pdCBzdHJpbmdcbiAqIEBhcmd1bWVudCB7U3RyaW5nfSBtZWFzdXJlbWVudCAtIGBoZWlnaHRgIG9yIGB3aWR0aGBcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBwb3BwZXJPZmZzZXRzXG4gKiBAYXJndW1lbnQge09iamVjdH0gcmVmZXJlbmNlT2Zmc2V0c1xuICogQHJldHVybnMge051bWJlcnxTdHJpbmd9XG4gKiBWYWx1ZSBpbiBwaXhlbHMsIG9yIG9yaWdpbmFsIHN0cmluZyBpZiBubyB2YWx1ZXMgd2VyZSBleHRyYWN0ZWRcbiAqL1xuZnVuY3Rpb24gdG9WYWx1ZShzdHIsIG1lYXN1cmVtZW50LCBwb3BwZXJPZmZzZXRzLCByZWZlcmVuY2VPZmZzZXRzKSB7XG4gIC8vIHNlcGFyYXRlIHZhbHVlIGZyb20gdW5pdFxuICB2YXIgc3BsaXQgPSBzdHIubWF0Y2goLygoPzpcXC18XFwrKT9cXGQqXFwuP1xcZCopKC4qKS8pO1xuICB2YXIgdmFsdWUgPSArc3BsaXRbMV07XG4gIHZhciB1bml0ID0gc3BsaXRbMl07XG5cbiAgLy8gSWYgaXQncyBub3QgYSBudW1iZXIgaXQncyBhbiBvcGVyYXRvciwgSSBndWVzc1xuICBpZiAoIXZhbHVlKSB7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxuXG4gIGlmICh1bml0LmluZGV4T2YoJyUnKSA9PT0gMCkge1xuICAgIHZhciBlbGVtZW50ID0gdm9pZCAwO1xuICAgIHN3aXRjaCAodW5pdCkge1xuICAgICAgY2FzZSAnJXAnOlxuICAgICAgICBlbGVtZW50ID0gcG9wcGVyT2Zmc2V0cztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICclJzpcbiAgICAgIGNhc2UgJyVyJzpcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGVsZW1lbnQgPSByZWZlcmVuY2VPZmZzZXRzO1xuICAgIH1cblxuICAgIHZhciByZWN0ID0gZ2V0Q2xpZW50UmVjdChlbGVtZW50KTtcbiAgICByZXR1cm4gcmVjdFttZWFzdXJlbWVudF0gLyAxMDAgKiB2YWx1ZTtcbiAgfSBlbHNlIGlmICh1bml0ID09PSAndmgnIHx8IHVuaXQgPT09ICd2dycpIHtcbiAgICAvLyBpZiBpcyBhIHZoIG9yIHZ3LCB3ZSBjYWxjdWxhdGUgdGhlIHNpemUgYmFzZWQgb24gdGhlIHZpZXdwb3J0XG4gICAgdmFyIHNpemUgPSB2b2lkIDA7XG4gICAgaWYgKHVuaXQgPT09ICd2aCcpIHtcbiAgICAgIHNpemUgPSBNYXRoLm1heChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0LCB3aW5kb3cuaW5uZXJIZWlnaHQgfHwgMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNpemUgPSBNYXRoLm1heChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGgsIHdpbmRvdy5pbm5lcldpZHRoIHx8IDApO1xuICAgIH1cbiAgICByZXR1cm4gc2l6ZSAvIDEwMCAqIHZhbHVlO1xuICB9IGVsc2Uge1xuICAgIC8vIGlmIGlzIGFuIGV4cGxpY2l0IHBpeGVsIHVuaXQsIHdlIGdldCByaWQgb2YgdGhlIHVuaXQgYW5kIGtlZXAgdGhlIHZhbHVlXG4gICAgLy8gaWYgaXMgYW4gaW1wbGljaXQgdW5pdCwgaXQncyBweCwgYW5kIHdlIHJldHVybiBqdXN0IHRoZSB2YWx1ZVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxufVxuXG4vKipcbiAqIFBhcnNlIGFuIGBvZmZzZXRgIHN0cmluZyB0byBleHRyYXBvbGF0ZSBgeGAgYW5kIGB5YCBudW1lcmljIG9mZnNldHMuXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiB7bW9kaWZpZXJzfm9mZnNldH1cbiAqIEBwcml2YXRlXG4gKiBAYXJndW1lbnQge1N0cmluZ30gb2Zmc2V0XG4gKiBAYXJndW1lbnQge09iamVjdH0gcG9wcGVyT2Zmc2V0c1xuICogQGFyZ3VtZW50IHtPYmplY3R9IHJlZmVyZW5jZU9mZnNldHNcbiAqIEBhcmd1bWVudCB7U3RyaW5nfSBiYXNlUGxhY2VtZW50XG4gKiBAcmV0dXJucyB7QXJyYXl9IGEgdHdvIGNlbGxzIGFycmF5IHdpdGggeCBhbmQgeSBvZmZzZXRzIGluIG51bWJlcnNcbiAqL1xuZnVuY3Rpb24gcGFyc2VPZmZzZXQob2Zmc2V0LCBwb3BwZXJPZmZzZXRzLCByZWZlcmVuY2VPZmZzZXRzLCBiYXNlUGxhY2VtZW50KSB7XG4gIHZhciBvZmZzZXRzID0gWzAsIDBdO1xuXG4gIC8vIFVzZSBoZWlnaHQgaWYgcGxhY2VtZW50IGlzIGxlZnQgb3IgcmlnaHQgYW5kIGluZGV4IGlzIDAgb3RoZXJ3aXNlIHVzZSB3aWR0aFxuICAvLyBpbiB0aGlzIHdheSB0aGUgZmlyc3Qgb2Zmc2V0IHdpbGwgdXNlIGFuIGF4aXMgYW5kIHRoZSBzZWNvbmQgb25lXG4gIC8vIHdpbGwgdXNlIHRoZSBvdGhlciBvbmVcbiAgdmFyIHVzZUhlaWdodCA9IFsncmlnaHQnLCAnbGVmdCddLmluZGV4T2YoYmFzZVBsYWNlbWVudCkgIT09IC0xO1xuXG4gIC8vIFNwbGl0IHRoZSBvZmZzZXQgc3RyaW5nIHRvIG9idGFpbiBhIGxpc3Qgb2YgdmFsdWVzIGFuZCBvcGVyYW5kc1xuICAvLyBUaGUgcmVnZXggYWRkcmVzc2VzIHZhbHVlcyB3aXRoIHRoZSBwbHVzIG9yIG1pbnVzIHNpZ24gaW4gZnJvbnQgKCsxMCwgLTIwLCBldGMpXG4gIHZhciBmcmFnbWVudHMgPSBvZmZzZXQuc3BsaXQoLyhcXCt8XFwtKS8pLm1hcChmdW5jdGlvbiAoZnJhZykge1xuICAgIHJldHVybiBmcmFnLnRyaW0oKTtcbiAgfSk7XG5cbiAgLy8gRGV0ZWN0IGlmIHRoZSBvZmZzZXQgc3RyaW5nIGNvbnRhaW5zIGEgcGFpciBvZiB2YWx1ZXMgb3IgYSBzaW5nbGUgb25lXG4gIC8vIHRoZXkgY291bGQgYmUgc2VwYXJhdGVkIGJ5IGNvbW1hIG9yIHNwYWNlXG4gIHZhciBkaXZpZGVyID0gZnJhZ21lbnRzLmluZGV4T2YoZmluZChmcmFnbWVudHMsIGZ1bmN0aW9uIChmcmFnKSB7XG4gICAgcmV0dXJuIGZyYWcuc2VhcmNoKC8sfFxccy8pICE9PSAtMTtcbiAgfSkpO1xuXG4gIGlmIChmcmFnbWVudHNbZGl2aWRlcl0gJiYgZnJhZ21lbnRzW2RpdmlkZXJdLmluZGV4T2YoJywnKSA9PT0gLTEpIHtcbiAgICBjb25zb2xlLndhcm4oJ09mZnNldHMgc2VwYXJhdGVkIGJ5IHdoaXRlIHNwYWNlKHMpIGFyZSBkZXByZWNhdGVkLCB1c2UgYSBjb21tYSAoLCkgaW5zdGVhZC4nKTtcbiAgfVxuXG4gIC8vIElmIGRpdmlkZXIgaXMgZm91bmQsIHdlIGRpdmlkZSB0aGUgbGlzdCBvZiB2YWx1ZXMgYW5kIG9wZXJhbmRzIHRvIGRpdmlkZVxuICAvLyB0aGVtIGJ5IG9mc2V0IFggYW5kIFkuXG4gIHZhciBzcGxpdFJlZ2V4ID0gL1xccyosXFxzKnxcXHMrLztcbiAgdmFyIG9wcyA9IGRpdmlkZXIgIT09IC0xID8gW2ZyYWdtZW50cy5zbGljZSgwLCBkaXZpZGVyKS5jb25jYXQoW2ZyYWdtZW50c1tkaXZpZGVyXS5zcGxpdChzcGxpdFJlZ2V4KVswXV0pLCBbZnJhZ21lbnRzW2RpdmlkZXJdLnNwbGl0KHNwbGl0UmVnZXgpWzFdXS5jb25jYXQoZnJhZ21lbnRzLnNsaWNlKGRpdmlkZXIgKyAxKSldIDogW2ZyYWdtZW50c107XG5cbiAgLy8gQ29udmVydCB0aGUgdmFsdWVzIHdpdGggdW5pdHMgdG8gYWJzb2x1dGUgcGl4ZWxzIHRvIGFsbG93IG91ciBjb21wdXRhdGlvbnNcbiAgb3BzID0gb3BzLm1hcChmdW5jdGlvbiAob3AsIGluZGV4KSB7XG4gICAgLy8gTW9zdCBvZiB0aGUgdW5pdHMgcmVseSBvbiB0aGUgb3JpZW50YXRpb24gb2YgdGhlIHBvcHBlclxuICAgIHZhciBtZWFzdXJlbWVudCA9IChpbmRleCA9PT0gMSA/ICF1c2VIZWlnaHQgOiB1c2VIZWlnaHQpID8gJ2hlaWdodCcgOiAnd2lkdGgnO1xuICAgIHZhciBtZXJnZVdpdGhQcmV2aW91cyA9IGZhbHNlO1xuICAgIHJldHVybiBvcFxuICAgIC8vIFRoaXMgYWdncmVnYXRlcyBhbnkgYCtgIG9yIGAtYCBzaWduIHRoYXQgYXJlbid0IGNvbnNpZGVyZWQgb3BlcmF0b3JzXG4gICAgLy8gZS5nLjogMTAgKyArNSA9PiBbMTAsICssICs1XVxuICAgIC5yZWR1Y2UoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIGlmIChhW2EubGVuZ3RoIC0gMV0gPT09ICcnICYmIFsnKycsICctJ10uaW5kZXhPZihiKSAhPT0gLTEpIHtcbiAgICAgICAgYVthLmxlbmd0aCAtIDFdID0gYjtcbiAgICAgICAgbWVyZ2VXaXRoUHJldmlvdXMgPSB0cnVlO1xuICAgICAgICByZXR1cm4gYTtcbiAgICAgIH0gZWxzZSBpZiAobWVyZ2VXaXRoUHJldmlvdXMpIHtcbiAgICAgICAgYVthLmxlbmd0aCAtIDFdICs9IGI7XG4gICAgICAgIG1lcmdlV2l0aFByZXZpb3VzID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBhO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGEuY29uY2F0KGIpO1xuICAgICAgfVxuICAgIH0sIFtdKVxuICAgIC8vIEhlcmUgd2UgY29udmVydCB0aGUgc3RyaW5nIHZhbHVlcyBpbnRvIG51bWJlciB2YWx1ZXMgKGluIHB4KVxuICAgIC5tYXAoZnVuY3Rpb24gKHN0cikge1xuICAgICAgcmV0dXJuIHRvVmFsdWUoc3RyLCBtZWFzdXJlbWVudCwgcG9wcGVyT2Zmc2V0cywgcmVmZXJlbmNlT2Zmc2V0cyk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIC8vIExvb3AgdHJvdWdoIHRoZSBvZmZzZXRzIGFycmF5cyBhbmQgZXhlY3V0ZSB0aGUgb3BlcmF0aW9uc1xuICBvcHMuZm9yRWFjaChmdW5jdGlvbiAob3AsIGluZGV4KSB7XG4gICAgb3AuZm9yRWFjaChmdW5jdGlvbiAoZnJhZywgaW5kZXgyKSB7XG4gICAgICBpZiAoaXNOdW1lcmljKGZyYWcpKSB7XG4gICAgICAgIG9mZnNldHNbaW5kZXhdICs9IGZyYWcgKiAob3BbaW5kZXgyIC0gMV0gPT09ICctJyA/IC0xIDogMSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gb2Zmc2V0cztcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiBNb2RpZmllcnNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSB1cGRhdGUgbWV0aG9kXG4gKiBAYXJndW1lbnQge09iamVjdH0gb3B0aW9ucyAtIE1vZGlmaWVycyBjb25maWd1cmF0aW9uIGFuZCBvcHRpb25zXG4gKiBAYXJndW1lbnQge051bWJlcnxTdHJpbmd9IG9wdGlvbnMub2Zmc2V0PTBcbiAqIFRoZSBvZmZzZXQgdmFsdWUgYXMgZGVzY3JpYmVkIGluIHRoZSBtb2RpZmllciBkZXNjcmlwdGlvblxuICogQHJldHVybnMge09iamVjdH0gVGhlIGRhdGEgb2JqZWN0LCBwcm9wZXJseSBtb2RpZmllZFxuICovXG5mdW5jdGlvbiBvZmZzZXQoZGF0YSwgX3JlZikge1xuICB2YXIgb2Zmc2V0ID0gX3JlZi5vZmZzZXQ7XG4gIHZhciBwbGFjZW1lbnQgPSBkYXRhLnBsYWNlbWVudCxcbiAgICAgIF9kYXRhJG9mZnNldHMgPSBkYXRhLm9mZnNldHMsXG4gICAgICBwb3BwZXIgPSBfZGF0YSRvZmZzZXRzLnBvcHBlcixcbiAgICAgIHJlZmVyZW5jZSA9IF9kYXRhJG9mZnNldHMucmVmZXJlbmNlO1xuXG4gIHZhciBiYXNlUGxhY2VtZW50ID0gcGxhY2VtZW50LnNwbGl0KCctJylbMF07XG5cbiAgdmFyIG9mZnNldHMgPSB2b2lkIDA7XG4gIGlmIChpc051bWVyaWMoK29mZnNldCkpIHtcbiAgICBvZmZzZXRzID0gWytvZmZzZXQsIDBdO1xuICB9IGVsc2Uge1xuICAgIG9mZnNldHMgPSBwYXJzZU9mZnNldChvZmZzZXQsIHBvcHBlciwgcmVmZXJlbmNlLCBiYXNlUGxhY2VtZW50KTtcbiAgfVxuXG4gIGlmIChiYXNlUGxhY2VtZW50ID09PSAnbGVmdCcpIHtcbiAgICBwb3BwZXIudG9wICs9IG9mZnNldHNbMF07XG4gICAgcG9wcGVyLmxlZnQgLT0gb2Zmc2V0c1sxXTtcbiAgfSBlbHNlIGlmIChiYXNlUGxhY2VtZW50ID09PSAncmlnaHQnKSB7XG4gICAgcG9wcGVyLnRvcCArPSBvZmZzZXRzWzBdO1xuICAgIHBvcHBlci5sZWZ0ICs9IG9mZnNldHNbMV07XG4gIH0gZWxzZSBpZiAoYmFzZVBsYWNlbWVudCA9PT0gJ3RvcCcpIHtcbiAgICBwb3BwZXIubGVmdCArPSBvZmZzZXRzWzBdO1xuICAgIHBvcHBlci50b3AgLT0gb2Zmc2V0c1sxXTtcbiAgfSBlbHNlIGlmIChiYXNlUGxhY2VtZW50ID09PSAnYm90dG9tJykge1xuICAgIHBvcHBlci5sZWZ0ICs9IG9mZnNldHNbMF07XG4gICAgcG9wcGVyLnRvcCArPSBvZmZzZXRzWzFdO1xuICB9XG5cbiAgZGF0YS5wb3BwZXIgPSBwb3BwZXI7XG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIE1vZGlmaWVyc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IGB1cGRhdGVgIG1ldGhvZFxuICogQGFyZ3VtZW50IHtPYmplY3R9IG9wdGlvbnMgLSBNb2RpZmllcnMgY29uZmlndXJhdGlvbiBhbmQgb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdH0gVGhlIGRhdGEgb2JqZWN0LCBwcm9wZXJseSBtb2RpZmllZFxuICovXG5mdW5jdGlvbiBwcmV2ZW50T3ZlcmZsb3coZGF0YSwgb3B0aW9ucykge1xuICB2YXIgYm91bmRhcmllc0VsZW1lbnQgPSBvcHRpb25zLmJvdW5kYXJpZXNFbGVtZW50IHx8IGdldE9mZnNldFBhcmVudChkYXRhLmluc3RhbmNlLnBvcHBlcik7XG5cbiAgLy8gSWYgb2Zmc2V0UGFyZW50IGlzIHRoZSByZWZlcmVuY2UgZWxlbWVudCwgd2UgcmVhbGx5IHdhbnQgdG9cbiAgLy8gZ28gb25lIHN0ZXAgdXAgYW5kIHVzZSB0aGUgbmV4dCBvZmZzZXRQYXJlbnQgYXMgcmVmZXJlbmNlIHRvXG4gIC8vIGF2b2lkIHRvIG1ha2UgdGhpcyBtb2RpZmllciBjb21wbGV0ZWx5IHVzZWxlc3MgYW5kIGxvb2sgbGlrZSBicm9rZW5cbiAgaWYgKGRhdGEuaW5zdGFuY2UucmVmZXJlbmNlID09PSBib3VuZGFyaWVzRWxlbWVudCkge1xuICAgIGJvdW5kYXJpZXNFbGVtZW50ID0gZ2V0T2Zmc2V0UGFyZW50KGJvdW5kYXJpZXNFbGVtZW50KTtcbiAgfVxuXG4gIC8vIE5PVEU6IERPTSBhY2Nlc3MgaGVyZVxuICAvLyByZXNldHMgdGhlIHBvcHBlcidzIHBvc2l0aW9uIHNvIHRoYXQgdGhlIGRvY3VtZW50IHNpemUgY2FuIGJlIGNhbGN1bGF0ZWQgZXhjbHVkaW5nXG4gIC8vIHRoZSBzaXplIG9mIHRoZSBwb3BwZXIgZWxlbWVudCBpdHNlbGZcbiAgdmFyIHRyYW5zZm9ybVByb3AgPSBnZXRTdXBwb3J0ZWRQcm9wZXJ0eU5hbWUoJ3RyYW5zZm9ybScpO1xuICB2YXIgcG9wcGVyU3R5bGVzID0gZGF0YS5pbnN0YW5jZS5wb3BwZXIuc3R5bGU7IC8vIGFzc2lnbm1lbnQgdG8gaGVscCBtaW5pZmljYXRpb25cbiAgdmFyIHRvcCA9IHBvcHBlclN0eWxlcy50b3AsXG4gICAgICBsZWZ0ID0gcG9wcGVyU3R5bGVzLmxlZnQsXG4gICAgICB0cmFuc2Zvcm0gPSBwb3BwZXJTdHlsZXNbdHJhbnNmb3JtUHJvcF07XG5cbiAgcG9wcGVyU3R5bGVzLnRvcCA9ICcnO1xuICBwb3BwZXJTdHlsZXMubGVmdCA9ICcnO1xuICBwb3BwZXJTdHlsZXNbdHJhbnNmb3JtUHJvcF0gPSAnJztcblxuICB2YXIgYm91bmRhcmllcyA9IGdldEJvdW5kYXJpZXMoZGF0YS5pbnN0YW5jZS5wb3BwZXIsIGRhdGEuaW5zdGFuY2UucmVmZXJlbmNlLCBvcHRpb25zLnBhZGRpbmcsIGJvdW5kYXJpZXNFbGVtZW50LCBkYXRhLnBvc2l0aW9uRml4ZWQpO1xuXG4gIC8vIE5PVEU6IERPTSBhY2Nlc3MgaGVyZVxuICAvLyByZXN0b3JlcyB0aGUgb3JpZ2luYWwgc3R5bGUgcHJvcGVydGllcyBhZnRlciB0aGUgb2Zmc2V0cyBoYXZlIGJlZW4gY29tcHV0ZWRcbiAgcG9wcGVyU3R5bGVzLnRvcCA9IHRvcDtcbiAgcG9wcGVyU3R5bGVzLmxlZnQgPSBsZWZ0O1xuICBwb3BwZXJTdHlsZXNbdHJhbnNmb3JtUHJvcF0gPSB0cmFuc2Zvcm07XG5cbiAgb3B0aW9ucy5ib3VuZGFyaWVzID0gYm91bmRhcmllcztcblxuICB2YXIgb3JkZXIgPSBvcHRpb25zLnByaW9yaXR5O1xuICB2YXIgcG9wcGVyID0gZGF0YS5vZmZzZXRzLnBvcHBlcjtcblxuICB2YXIgY2hlY2sgPSB7XG4gICAgcHJpbWFyeTogZnVuY3Rpb24gcHJpbWFyeShwbGFjZW1lbnQpIHtcbiAgICAgIHZhciB2YWx1ZSA9IHBvcHBlcltwbGFjZW1lbnRdO1xuICAgICAgaWYgKHBvcHBlcltwbGFjZW1lbnRdIDwgYm91bmRhcmllc1twbGFjZW1lbnRdICYmICFvcHRpb25zLmVzY2FwZVdpdGhSZWZlcmVuY2UpIHtcbiAgICAgICAgdmFsdWUgPSBNYXRoLm1heChwb3BwZXJbcGxhY2VtZW50XSwgYm91bmRhcmllc1twbGFjZW1lbnRdKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkZWZpbmVQcm9wZXJ0eSh7fSwgcGxhY2VtZW50LCB2YWx1ZSk7XG4gICAgfSxcbiAgICBzZWNvbmRhcnk6IGZ1bmN0aW9uIHNlY29uZGFyeShwbGFjZW1lbnQpIHtcbiAgICAgIHZhciBtYWluU2lkZSA9IHBsYWNlbWVudCA9PT0gJ3JpZ2h0JyA/ICdsZWZ0JyA6ICd0b3AnO1xuICAgICAgdmFyIHZhbHVlID0gcG9wcGVyW21haW5TaWRlXTtcbiAgICAgIGlmIChwb3BwZXJbcGxhY2VtZW50XSA+IGJvdW5kYXJpZXNbcGxhY2VtZW50XSAmJiAhb3B0aW9ucy5lc2NhcGVXaXRoUmVmZXJlbmNlKSB7XG4gICAgICAgIHZhbHVlID0gTWF0aC5taW4ocG9wcGVyW21haW5TaWRlXSwgYm91bmRhcmllc1twbGFjZW1lbnRdIC0gKHBsYWNlbWVudCA9PT0gJ3JpZ2h0JyA/IHBvcHBlci53aWR0aCA6IHBvcHBlci5oZWlnaHQpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkZWZpbmVQcm9wZXJ0eSh7fSwgbWFpblNpZGUsIHZhbHVlKTtcbiAgICB9XG4gIH07XG5cbiAgb3JkZXIuZm9yRWFjaChmdW5jdGlvbiAocGxhY2VtZW50KSB7XG4gICAgdmFyIHNpZGUgPSBbJ2xlZnQnLCAndG9wJ10uaW5kZXhPZihwbGFjZW1lbnQpICE9PSAtMSA/ICdwcmltYXJ5JyA6ICdzZWNvbmRhcnknO1xuICAgIHBvcHBlciA9IF9leHRlbmRzKHt9LCBwb3BwZXIsIGNoZWNrW3NpZGVdKHBsYWNlbWVudCkpO1xuICB9KTtcblxuICBkYXRhLm9mZnNldHMucG9wcGVyID0gcG9wcGVyO1xuXG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIE1vZGlmaWVyc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IGB1cGRhdGVgIG1ldGhvZFxuICogQGFyZ3VtZW50IHtPYmplY3R9IG9wdGlvbnMgLSBNb2RpZmllcnMgY29uZmlndXJhdGlvbiBhbmQgb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdH0gVGhlIGRhdGEgb2JqZWN0LCBwcm9wZXJseSBtb2RpZmllZFxuICovXG5mdW5jdGlvbiBzaGlmdChkYXRhKSB7XG4gIHZhciBwbGFjZW1lbnQgPSBkYXRhLnBsYWNlbWVudDtcbiAgdmFyIGJhc2VQbGFjZW1lbnQgPSBwbGFjZW1lbnQuc3BsaXQoJy0nKVswXTtcbiAgdmFyIHNoaWZ0dmFyaWF0aW9uID0gcGxhY2VtZW50LnNwbGl0KCctJylbMV07XG5cbiAgLy8gaWYgc2hpZnQgc2hpZnR2YXJpYXRpb24gaXMgc3BlY2lmaWVkLCBydW4gdGhlIG1vZGlmaWVyXG4gIGlmIChzaGlmdHZhcmlhdGlvbikge1xuICAgIHZhciBfZGF0YSRvZmZzZXRzID0gZGF0YS5vZmZzZXRzLFxuICAgICAgICByZWZlcmVuY2UgPSBfZGF0YSRvZmZzZXRzLnJlZmVyZW5jZSxcbiAgICAgICAgcG9wcGVyID0gX2RhdGEkb2Zmc2V0cy5wb3BwZXI7XG5cbiAgICB2YXIgaXNWZXJ0aWNhbCA9IFsnYm90dG9tJywgJ3RvcCddLmluZGV4T2YoYmFzZVBsYWNlbWVudCkgIT09IC0xO1xuICAgIHZhciBzaWRlID0gaXNWZXJ0aWNhbCA/ICdsZWZ0JyA6ICd0b3AnO1xuICAgIHZhciBtZWFzdXJlbWVudCA9IGlzVmVydGljYWwgPyAnd2lkdGgnIDogJ2hlaWdodCc7XG5cbiAgICB2YXIgc2hpZnRPZmZzZXRzID0ge1xuICAgICAgc3RhcnQ6IGRlZmluZVByb3BlcnR5KHt9LCBzaWRlLCByZWZlcmVuY2Vbc2lkZV0pLFxuICAgICAgZW5kOiBkZWZpbmVQcm9wZXJ0eSh7fSwgc2lkZSwgcmVmZXJlbmNlW3NpZGVdICsgcmVmZXJlbmNlW21lYXN1cmVtZW50XSAtIHBvcHBlclttZWFzdXJlbWVudF0pXG4gICAgfTtcblxuICAgIGRhdGEub2Zmc2V0cy5wb3BwZXIgPSBfZXh0ZW5kcyh7fSwgcG9wcGVyLCBzaGlmdE9mZnNldHNbc2hpZnR2YXJpYXRpb25dKTtcbiAgfVxuXG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIE1vZGlmaWVyc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IHVwZGF0ZSBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBkYXRhIG9iamVjdCwgcHJvcGVybHkgbW9kaWZpZWRcbiAqL1xuZnVuY3Rpb24gaGlkZShkYXRhKSB7XG4gIGlmICghaXNNb2RpZmllclJlcXVpcmVkKGRhdGEuaW5zdGFuY2UubW9kaWZpZXJzLCAnaGlkZScsICdwcmV2ZW50T3ZlcmZsb3cnKSkge1xuICAgIHJldHVybiBkYXRhO1xuICB9XG5cbiAgdmFyIHJlZlJlY3QgPSBkYXRhLm9mZnNldHMucmVmZXJlbmNlO1xuICB2YXIgYm91bmQgPSBmaW5kKGRhdGEuaW5zdGFuY2UubW9kaWZpZXJzLCBmdW5jdGlvbiAobW9kaWZpZXIpIHtcbiAgICByZXR1cm4gbW9kaWZpZXIubmFtZSA9PT0gJ3ByZXZlbnRPdmVyZmxvdyc7XG4gIH0pLmJvdW5kYXJpZXM7XG5cbiAgaWYgKHJlZlJlY3QuYm90dG9tIDwgYm91bmQudG9wIHx8IHJlZlJlY3QubGVmdCA+IGJvdW5kLnJpZ2h0IHx8IHJlZlJlY3QudG9wID4gYm91bmQuYm90dG9tIHx8IHJlZlJlY3QucmlnaHQgPCBib3VuZC5sZWZ0KSB7XG4gICAgLy8gQXZvaWQgdW5uZWNlc3NhcnkgRE9NIGFjY2VzcyBpZiB2aXNpYmlsaXR5IGhhc24ndCBjaGFuZ2VkXG4gICAgaWYgKGRhdGEuaGlkZSA9PT0gdHJ1ZSkge1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuXG4gICAgZGF0YS5oaWRlID0gdHJ1ZTtcbiAgICBkYXRhLmF0dHJpYnV0ZXNbJ3gtb3V0LW9mLWJvdW5kYXJpZXMnXSA9ICcnO1xuICB9IGVsc2Uge1xuICAgIC8vIEF2b2lkIHVubmVjZXNzYXJ5IERPTSBhY2Nlc3MgaWYgdmlzaWJpbGl0eSBoYXNuJ3QgY2hhbmdlZFxuICAgIGlmIChkYXRhLmhpZGUgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG5cbiAgICBkYXRhLmhpZGUgPSBmYWxzZTtcbiAgICBkYXRhLmF0dHJpYnV0ZXNbJ3gtb3V0LW9mLWJvdW5kYXJpZXMnXSA9IGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YgTW9kaWZpZXJzXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgYHVwZGF0ZWAgbWV0aG9kXG4gKiBAYXJndW1lbnQge09iamVjdH0gb3B0aW9ucyAtIE1vZGlmaWVycyBjb25maWd1cmF0aW9uIGFuZCBvcHRpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgZGF0YSBvYmplY3QsIHByb3Blcmx5IG1vZGlmaWVkXG4gKi9cbmZ1bmN0aW9uIGlubmVyKGRhdGEpIHtcbiAgdmFyIHBsYWNlbWVudCA9IGRhdGEucGxhY2VtZW50O1xuICB2YXIgYmFzZVBsYWNlbWVudCA9IHBsYWNlbWVudC5zcGxpdCgnLScpWzBdO1xuICB2YXIgX2RhdGEkb2Zmc2V0cyA9IGRhdGEub2Zmc2V0cyxcbiAgICAgIHBvcHBlciA9IF9kYXRhJG9mZnNldHMucG9wcGVyLFxuICAgICAgcmVmZXJlbmNlID0gX2RhdGEkb2Zmc2V0cy5yZWZlcmVuY2U7XG5cbiAgdmFyIGlzSG9yaXogPSBbJ2xlZnQnLCAncmlnaHQnXS5pbmRleE9mKGJhc2VQbGFjZW1lbnQpICE9PSAtMTtcblxuICB2YXIgc3VidHJhY3RMZW5ndGggPSBbJ3RvcCcsICdsZWZ0J10uaW5kZXhPZihiYXNlUGxhY2VtZW50KSA9PT0gLTE7XG5cbiAgcG9wcGVyW2lzSG9yaXogPyAnbGVmdCcgOiAndG9wJ10gPSByZWZlcmVuY2VbYmFzZVBsYWNlbWVudF0gLSAoc3VidHJhY3RMZW5ndGggPyBwb3BwZXJbaXNIb3JpeiA/ICd3aWR0aCcgOiAnaGVpZ2h0J10gOiAwKTtcblxuICBkYXRhLnBsYWNlbWVudCA9IGdldE9wcG9zaXRlUGxhY2VtZW50KHBsYWNlbWVudCk7XG4gIGRhdGEub2Zmc2V0cy5wb3BwZXIgPSBnZXRDbGllbnRSZWN0KHBvcHBlcik7XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogTW9kaWZpZXIgZnVuY3Rpb24sIGVhY2ggbW9kaWZpZXIgY2FuIGhhdmUgYSBmdW5jdGlvbiBvZiB0aGlzIHR5cGUgYXNzaWduZWRcbiAqIHRvIGl0cyBgZm5gIHByb3BlcnR5LjxiciAvPlxuICogVGhlc2UgZnVuY3Rpb25zIHdpbGwgYmUgY2FsbGVkIG9uIGVhY2ggdXBkYXRlLCB0aGlzIG1lYW5zIHRoYXQgeW91IG11c3RcbiAqIG1ha2Ugc3VyZSB0aGV5IGFyZSBwZXJmb3JtYW50IGVub3VnaCB0byBhdm9pZCBwZXJmb3JtYW5jZSBib3R0bGVuZWNrcy5cbiAqXG4gKiBAZnVuY3Rpb24gTW9kaWZpZXJGblxuICogQGFyZ3VtZW50IHtkYXRhT2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSBgdXBkYXRlYCBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtkYXRhT2JqZWN0fSBUaGUgZGF0YSBvYmplY3QsIHByb3Blcmx5IG1vZGlmaWVkXG4gKi9cblxuLyoqXG4gKiBNb2RpZmllcnMgYXJlIHBsdWdpbnMgdXNlZCB0byBhbHRlciB0aGUgYmVoYXZpb3Igb2YgeW91ciBwb3BwZXJzLjxiciAvPlxuICogUG9wcGVyLmpzIHVzZXMgYSBzZXQgb2YgOSBtb2RpZmllcnMgdG8gcHJvdmlkZSBhbGwgdGhlIGJhc2ljIGZ1bmN0aW9uYWxpdGllc1xuICogbmVlZGVkIGJ5IHRoZSBsaWJyYXJ5LlxuICpcbiAqIFVzdWFsbHkgeW91IGRvbid0IHdhbnQgdG8gb3ZlcnJpZGUgdGhlIGBvcmRlcmAsIGBmbmAgYW5kIGBvbkxvYWRgIHByb3BzLlxuICogQWxsIHRoZSBvdGhlciBwcm9wZXJ0aWVzIGFyZSBjb25maWd1cmF0aW9ucyB0aGF0IGNvdWxkIGJlIHR3ZWFrZWQuXG4gKiBAbmFtZXNwYWNlIG1vZGlmaWVyc1xuICovXG52YXIgbW9kaWZpZXJzID0ge1xuICAvKipcbiAgICogTW9kaWZpZXIgdXNlZCB0byBzaGlmdCB0aGUgcG9wcGVyIG9uIHRoZSBzdGFydCBvciBlbmQgb2YgaXRzIHJlZmVyZW5jZVxuICAgKiBlbGVtZW50LjxiciAvPlxuICAgKiBJdCB3aWxsIHJlYWQgdGhlIHZhcmlhdGlvbiBvZiB0aGUgYHBsYWNlbWVudGAgcHJvcGVydHkuPGJyIC8+XG4gICAqIEl0IGNhbiBiZSBvbmUgZWl0aGVyIGAtZW5kYCBvciBgLXN0YXJ0YC5cbiAgICogQG1lbWJlcm9mIG1vZGlmaWVyc1xuICAgKiBAaW5uZXJcbiAgICovXG4gIHNoaWZ0OiB7XG4gICAgLyoqIEBwcm9wIHtudW1iZXJ9IG9yZGVyPTEwMCAtIEluZGV4IHVzZWQgdG8gZGVmaW5lIHRoZSBvcmRlciBvZiBleGVjdXRpb24gKi9cbiAgICBvcmRlcjogMTAwLFxuICAgIC8qKiBAcHJvcCB7Qm9vbGVhbn0gZW5hYmxlZD10cnVlIC0gV2hldGhlciB0aGUgbW9kaWZpZXIgaXMgZW5hYmxlZCBvciBub3QgKi9cbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIC8qKiBAcHJvcCB7TW9kaWZpZXJGbn0gKi9cbiAgICBmbjogc2hpZnRcbiAgfSxcblxuICAvKipcbiAgICogVGhlIGBvZmZzZXRgIG1vZGlmaWVyIGNhbiBzaGlmdCB5b3VyIHBvcHBlciBvbiBib3RoIGl0cyBheGlzLlxuICAgKlxuICAgKiBJdCBhY2NlcHRzIHRoZSBmb2xsb3dpbmcgdW5pdHM6XG4gICAqIC0gYHB4YCBvciB1bml0LWxlc3MsIGludGVycHJldGVkIGFzIHBpeGVsc1xuICAgKiAtIGAlYCBvciBgJXJgLCBwZXJjZW50YWdlIHJlbGF0aXZlIHRvIHRoZSBsZW5ndGggb2YgdGhlIHJlZmVyZW5jZSBlbGVtZW50XG4gICAqIC0gYCVwYCwgcGVyY2VudGFnZSByZWxhdGl2ZSB0byB0aGUgbGVuZ3RoIG9mIHRoZSBwb3BwZXIgZWxlbWVudFxuICAgKiAtIGB2d2AsIENTUyB2aWV3cG9ydCB3aWR0aCB1bml0XG4gICAqIC0gYHZoYCwgQ1NTIHZpZXdwb3J0IGhlaWdodCB1bml0XG4gICAqXG4gICAqIEZvciBsZW5ndGggaXMgaW50ZW5kZWQgdGhlIG1haW4gYXhpcyByZWxhdGl2ZSB0byB0aGUgcGxhY2VtZW50IG9mIHRoZSBwb3BwZXIuPGJyIC8+XG4gICAqIFRoaXMgbWVhbnMgdGhhdCBpZiB0aGUgcGxhY2VtZW50IGlzIGB0b3BgIG9yIGBib3R0b21gLCB0aGUgbGVuZ3RoIHdpbGwgYmUgdGhlXG4gICAqIGB3aWR0aGAuIEluIGNhc2Ugb2YgYGxlZnRgIG9yIGByaWdodGAsIGl0IHdpbGwgYmUgdGhlIGBoZWlnaHRgLlxuICAgKlxuICAgKiBZb3UgY2FuIHByb3ZpZGUgYSBzaW5nbGUgdmFsdWUgKGFzIGBOdW1iZXJgIG9yIGBTdHJpbmdgKSwgb3IgYSBwYWlyIG9mIHZhbHVlc1xuICAgKiBhcyBgU3RyaW5nYCBkaXZpZGVkIGJ5IGEgY29tbWEgb3Igb25lIChvciBtb3JlKSB3aGl0ZSBzcGFjZXMuPGJyIC8+XG4gICAqIFRoZSBsYXR0ZXIgaXMgYSBkZXByZWNhdGVkIG1ldGhvZCBiZWNhdXNlIGl0IGxlYWRzIHRvIGNvbmZ1c2lvbiBhbmQgd2lsbCBiZVxuICAgKiByZW1vdmVkIGluIHYyLjxiciAvPlxuICAgKiBBZGRpdGlvbmFsbHksIGl0IGFjY2VwdHMgYWRkaXRpb25zIGFuZCBzdWJ0cmFjdGlvbnMgYmV0d2VlbiBkaWZmZXJlbnQgdW5pdHMuXG4gICAqIE5vdGUgdGhhdCBtdWx0aXBsaWNhdGlvbnMgYW5kIGRpdmlzaW9ucyBhcmVuJ3Qgc3VwcG9ydGVkLlxuICAgKlxuICAgKiBWYWxpZCBleGFtcGxlcyBhcmU6XG4gICAqIGBgYFxuICAgKiAxMFxuICAgKiAnMTAlJ1xuICAgKiAnMTAsIDEwJ1xuICAgKiAnMTAlLCAxMCdcbiAgICogJzEwICsgMTAlJ1xuICAgKiAnMTAgLSA1dmggKyAzJSdcbiAgICogJy0xMHB4ICsgNXZoLCA1cHggLSA2JSdcbiAgICogYGBgXG4gICAqID4gKipOQioqOiBJZiB5b3UgZGVzaXJlIHRvIGFwcGx5IG9mZnNldHMgdG8geW91ciBwb3BwZXJzIGluIGEgd2F5IHRoYXQgbWF5IG1ha2UgdGhlbSBvdmVybGFwXG4gICAqID4gd2l0aCB0aGVpciByZWZlcmVuY2UgZWxlbWVudCwgdW5mb3J0dW5hdGVseSwgeW91IHdpbGwgaGF2ZSB0byBkaXNhYmxlIHRoZSBgZmxpcGAgbW9kaWZpZXIuXG4gICAqID4gWW91IGNhbiByZWFkIG1vcmUgb24gdGhpcyBhdCB0aGlzIFtpc3N1ZV0oaHR0cHM6Ly9naXRodWIuY29tL0ZlelZyYXN0YS9wb3BwZXIuanMvaXNzdWVzLzM3MykuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBtb2RpZmllcnNcbiAgICogQGlubmVyXG4gICAqL1xuICBvZmZzZXQ6IHtcbiAgICAvKiogQHByb3Age251bWJlcn0gb3JkZXI9MjAwIC0gSW5kZXggdXNlZCB0byBkZWZpbmUgdGhlIG9yZGVyIG9mIGV4ZWN1dGlvbiAqL1xuICAgIG9yZGVyOiAyMDAsXG4gICAgLyoqIEBwcm9wIHtCb29sZWFufSBlbmFibGVkPXRydWUgLSBXaGV0aGVyIHRoZSBtb2RpZmllciBpcyBlbmFibGVkIG9yIG5vdCAqL1xuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgLyoqIEBwcm9wIHtNb2RpZmllckZufSAqL1xuICAgIGZuOiBvZmZzZXQsXG4gICAgLyoqIEBwcm9wIHtOdW1iZXJ8U3RyaW5nfSBvZmZzZXQ9MFxuICAgICAqIFRoZSBvZmZzZXQgdmFsdWUgYXMgZGVzY3JpYmVkIGluIHRoZSBtb2RpZmllciBkZXNjcmlwdGlvblxuICAgICAqL1xuICAgIG9mZnNldDogMFxuICB9LFxuXG4gIC8qKlxuICAgKiBNb2RpZmllciB1c2VkIHRvIHByZXZlbnQgdGhlIHBvcHBlciBmcm9tIGJlaW5nIHBvc2l0aW9uZWQgb3V0c2lkZSB0aGUgYm91bmRhcnkuXG4gICAqXG4gICAqIEEgc2NlbmFyaW8gZXhpc3RzIHdoZXJlIHRoZSByZWZlcmVuY2UgaXRzZWxmIGlzIG5vdCB3aXRoaW4gdGhlIGJvdW5kYXJpZXMuPGJyIC8+XG4gICAqIFdlIGNhbiBzYXkgaXQgaGFzIFwiZXNjYXBlZCB0aGUgYm91bmRhcmllc1wiIOKAlCBvciBqdXN0IFwiZXNjYXBlZFwiLjxiciAvPlxuICAgKiBJbiB0aGlzIGNhc2Ugd2UgbmVlZCB0byBkZWNpZGUgd2hldGhlciB0aGUgcG9wcGVyIHNob3VsZCBlaXRoZXI6XG4gICAqXG4gICAqIC0gZGV0YWNoIGZyb20gdGhlIHJlZmVyZW5jZSBhbmQgcmVtYWluIFwidHJhcHBlZFwiIGluIHRoZSBib3VuZGFyaWVzLCBvclxuICAgKiAtIGlmIGl0IHNob3VsZCBpZ25vcmUgdGhlIGJvdW5kYXJ5IGFuZCBcImVzY2FwZSB3aXRoIGl0cyByZWZlcmVuY2VcIlxuICAgKlxuICAgKiBXaGVuIGBlc2NhcGVXaXRoUmVmZXJlbmNlYCBpcyBzZXQgdG9gdHJ1ZWAgYW5kIHJlZmVyZW5jZSBpcyBjb21wbGV0ZWx5XG4gICAqIG91dHNpZGUgaXRzIGJvdW5kYXJpZXMsIHRoZSBwb3BwZXIgd2lsbCBvdmVyZmxvdyAob3IgY29tcGxldGVseSBsZWF2ZSlcbiAgICogdGhlIGJvdW5kYXJpZXMgaW4gb3JkZXIgdG8gcmVtYWluIGF0dGFjaGVkIHRvIHRoZSBlZGdlIG9mIHRoZSByZWZlcmVuY2UuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBtb2RpZmllcnNcbiAgICogQGlubmVyXG4gICAqL1xuICBwcmV2ZW50T3ZlcmZsb3c6IHtcbiAgICAvKiogQHByb3Age251bWJlcn0gb3JkZXI9MzAwIC0gSW5kZXggdXNlZCB0byBkZWZpbmUgdGhlIG9yZGVyIG9mIGV4ZWN1dGlvbiAqL1xuICAgIG9yZGVyOiAzMDAsXG4gICAgLyoqIEBwcm9wIHtCb29sZWFufSBlbmFibGVkPXRydWUgLSBXaGV0aGVyIHRoZSBtb2RpZmllciBpcyBlbmFibGVkIG9yIG5vdCAqL1xuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgLyoqIEBwcm9wIHtNb2RpZmllckZufSAqL1xuICAgIGZuOiBwcmV2ZW50T3ZlcmZsb3csXG4gICAgLyoqXG4gICAgICogQHByb3Age0FycmF5fSBbcHJpb3JpdHk9WydsZWZ0JywncmlnaHQnLCd0b3AnLCdib3R0b20nXV1cbiAgICAgKiBQb3BwZXIgd2lsbCB0cnkgdG8gcHJldmVudCBvdmVyZmxvdyBmb2xsb3dpbmcgdGhlc2UgcHJpb3JpdGllcyBieSBkZWZhdWx0LFxuICAgICAqIHRoZW4sIGl0IGNvdWxkIG92ZXJmbG93IG9uIHRoZSBsZWZ0IGFuZCBvbiB0b3Agb2YgdGhlIGBib3VuZGFyaWVzRWxlbWVudGBcbiAgICAgKi9cbiAgICBwcmlvcml0eTogWydsZWZ0JywgJ3JpZ2h0JywgJ3RvcCcsICdib3R0b20nXSxcbiAgICAvKipcbiAgICAgKiBAcHJvcCB7bnVtYmVyfSBwYWRkaW5nPTVcbiAgICAgKiBBbW91bnQgb2YgcGl4ZWwgdXNlZCB0byBkZWZpbmUgYSBtaW5pbXVtIGRpc3RhbmNlIGJldHdlZW4gdGhlIGJvdW5kYXJpZXNcbiAgICAgKiBhbmQgdGhlIHBvcHBlci4gVGhpcyBtYWtlcyBzdXJlIHRoZSBwb3BwZXIgYWx3YXlzIGhhcyBhIGxpdHRsZSBwYWRkaW5nXG4gICAgICogYmV0d2VlbiB0aGUgZWRnZXMgb2YgaXRzIGNvbnRhaW5lclxuICAgICAqL1xuICAgIHBhZGRpbmc6IDUsXG4gICAgLyoqXG4gICAgICogQHByb3Age1N0cmluZ3xIVE1MRWxlbWVudH0gYm91bmRhcmllc0VsZW1lbnQ9J3Njcm9sbFBhcmVudCdcbiAgICAgKiBCb3VuZGFyaWVzIHVzZWQgYnkgdGhlIG1vZGlmaWVyLiBDYW4gYmUgYHNjcm9sbFBhcmVudGAsIGB3aW5kb3dgLFxuICAgICAqIGB2aWV3cG9ydGAgb3IgYW55IERPTSBlbGVtZW50LlxuICAgICAqL1xuICAgIGJvdW5kYXJpZXNFbGVtZW50OiAnc2Nyb2xsUGFyZW50J1xuICB9LFxuXG4gIC8qKlxuICAgKiBNb2RpZmllciB1c2VkIHRvIG1ha2Ugc3VyZSB0aGUgcmVmZXJlbmNlIGFuZCBpdHMgcG9wcGVyIHN0YXkgbmVhciBlYWNoIG90aGVyXG4gICAqIHdpdGhvdXQgbGVhdmluZyBhbnkgZ2FwIGJldHdlZW4gdGhlIHR3by4gRXNwZWNpYWxseSB1c2VmdWwgd2hlbiB0aGUgYXJyb3cgaXNcbiAgICogZW5hYmxlZCBhbmQgeW91IHdhbnQgdG8gZW5zdXJlIHRoYXQgaXQgcG9pbnRzIHRvIGl0cyByZWZlcmVuY2UgZWxlbWVudC5cbiAgICogSXQgY2FyZXMgb25seSBhYm91dCB0aGUgZmlyc3QgYXhpcy4gWW91IGNhbiBzdGlsbCBoYXZlIHBvcHBlcnMgd2l0aCBtYXJnaW5cbiAgICogYmV0d2VlbiB0aGUgcG9wcGVyIGFuZCBpdHMgcmVmZXJlbmNlIGVsZW1lbnQuXG4gICAqIEBtZW1iZXJvZiBtb2RpZmllcnNcbiAgICogQGlubmVyXG4gICAqL1xuICBrZWVwVG9nZXRoZXI6IHtcbiAgICAvKiogQHByb3Age251bWJlcn0gb3JkZXI9NDAwIC0gSW5kZXggdXNlZCB0byBkZWZpbmUgdGhlIG9yZGVyIG9mIGV4ZWN1dGlvbiAqL1xuICAgIG9yZGVyOiA0MDAsXG4gICAgLyoqIEBwcm9wIHtCb29sZWFufSBlbmFibGVkPXRydWUgLSBXaGV0aGVyIHRoZSBtb2RpZmllciBpcyBlbmFibGVkIG9yIG5vdCAqL1xuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgLyoqIEBwcm9wIHtNb2RpZmllckZufSAqL1xuICAgIGZuOiBrZWVwVG9nZXRoZXJcbiAgfSxcblxuICAvKipcbiAgICogVGhpcyBtb2RpZmllciBpcyB1c2VkIHRvIG1vdmUgdGhlIGBhcnJvd0VsZW1lbnRgIG9mIHRoZSBwb3BwZXIgdG8gbWFrZVxuICAgKiBzdXJlIGl0IGlzIHBvc2l0aW9uZWQgYmV0d2VlbiB0aGUgcmVmZXJlbmNlIGVsZW1lbnQgYW5kIGl0cyBwb3BwZXIgZWxlbWVudC5cbiAgICogSXQgd2lsbCByZWFkIHRoZSBvdXRlciBzaXplIG9mIHRoZSBgYXJyb3dFbGVtZW50YCBub2RlIHRvIGRldGVjdCBob3cgbWFueVxuICAgKiBwaXhlbHMgb2YgY29uanVuY3Rpb24gYXJlIG5lZWRlZC5cbiAgICpcbiAgICogSXQgaGFzIG5vIGVmZmVjdCBpZiBubyBgYXJyb3dFbGVtZW50YCBpcyBwcm92aWRlZC5cbiAgICogQG1lbWJlcm9mIG1vZGlmaWVyc1xuICAgKiBAaW5uZXJcbiAgICovXG4gIGFycm93OiB7XG4gICAgLyoqIEBwcm9wIHtudW1iZXJ9IG9yZGVyPTUwMCAtIEluZGV4IHVzZWQgdG8gZGVmaW5lIHRoZSBvcmRlciBvZiBleGVjdXRpb24gKi9cbiAgICBvcmRlcjogNTAwLFxuICAgIC8qKiBAcHJvcCB7Qm9vbGVhbn0gZW5hYmxlZD10cnVlIC0gV2hldGhlciB0aGUgbW9kaWZpZXIgaXMgZW5hYmxlZCBvciBub3QgKi9cbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIC8qKiBAcHJvcCB7TW9kaWZpZXJGbn0gKi9cbiAgICBmbjogYXJyb3csXG4gICAgLyoqIEBwcm9wIHtTdHJpbmd8SFRNTEVsZW1lbnR9IGVsZW1lbnQ9J1t4LWFycm93XScgLSBTZWxlY3RvciBvciBub2RlIHVzZWQgYXMgYXJyb3cgKi9cbiAgICBlbGVtZW50OiAnW3gtYXJyb3ddJ1xuICB9LFxuXG4gIC8qKlxuICAgKiBNb2RpZmllciB1c2VkIHRvIGZsaXAgdGhlIHBvcHBlcidzIHBsYWNlbWVudCB3aGVuIGl0IHN0YXJ0cyB0byBvdmVybGFwIGl0c1xuICAgKiByZWZlcmVuY2UgZWxlbWVudC5cbiAgICpcbiAgICogUmVxdWlyZXMgdGhlIGBwcmV2ZW50T3ZlcmZsb3dgIG1vZGlmaWVyIGJlZm9yZSBpdCBpbiBvcmRlciB0byB3b3JrLlxuICAgKlxuICAgKiAqKk5PVEU6KiogdGhpcyBtb2RpZmllciB3aWxsIGludGVycnVwdCB0aGUgY3VycmVudCB1cGRhdGUgY3ljbGUgYW5kIHdpbGxcbiAgICogcmVzdGFydCBpdCBpZiBpdCBkZXRlY3RzIHRoZSBuZWVkIHRvIGZsaXAgdGhlIHBsYWNlbWVudC5cbiAgICogQG1lbWJlcm9mIG1vZGlmaWVyc1xuICAgKiBAaW5uZXJcbiAgICovXG4gIGZsaXA6IHtcbiAgICAvKiogQHByb3Age251bWJlcn0gb3JkZXI9NjAwIC0gSW5kZXggdXNlZCB0byBkZWZpbmUgdGhlIG9yZGVyIG9mIGV4ZWN1dGlvbiAqL1xuICAgIG9yZGVyOiA2MDAsXG4gICAgLyoqIEBwcm9wIHtCb29sZWFufSBlbmFibGVkPXRydWUgLSBXaGV0aGVyIHRoZSBtb2RpZmllciBpcyBlbmFibGVkIG9yIG5vdCAqL1xuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgLyoqIEBwcm9wIHtNb2RpZmllckZufSAqL1xuICAgIGZuOiBmbGlwLFxuICAgIC8qKlxuICAgICAqIEBwcm9wIHtTdHJpbmd8QXJyYXl9IGJlaGF2aW9yPSdmbGlwJ1xuICAgICAqIFRoZSBiZWhhdmlvciB1c2VkIHRvIGNoYW5nZSB0aGUgcG9wcGVyJ3MgcGxhY2VtZW50LiBJdCBjYW4gYmUgb25lIG9mXG4gICAgICogYGZsaXBgLCBgY2xvY2t3aXNlYCwgYGNvdW50ZXJjbG9ja3dpc2VgIG9yIGFuIGFycmF5IHdpdGggYSBsaXN0IG9mIHZhbGlkXG4gICAgICogcGxhY2VtZW50cyAod2l0aCBvcHRpb25hbCB2YXJpYXRpb25zKVxuICAgICAqL1xuICAgIGJlaGF2aW9yOiAnZmxpcCcsXG4gICAgLyoqXG4gICAgICogQHByb3Age251bWJlcn0gcGFkZGluZz01XG4gICAgICogVGhlIHBvcHBlciB3aWxsIGZsaXAgaWYgaXQgaGl0cyB0aGUgZWRnZXMgb2YgdGhlIGBib3VuZGFyaWVzRWxlbWVudGBcbiAgICAgKi9cbiAgICBwYWRkaW5nOiA1LFxuICAgIC8qKlxuICAgICAqIEBwcm9wIHtTdHJpbmd8SFRNTEVsZW1lbnR9IGJvdW5kYXJpZXNFbGVtZW50PSd2aWV3cG9ydCdcbiAgICAgKiBUaGUgZWxlbWVudCB3aGljaCB3aWxsIGRlZmluZSB0aGUgYm91bmRhcmllcyBvZiB0aGUgcG9wcGVyIHBvc2l0aW9uLlxuICAgICAqIFRoZSBwb3BwZXIgd2lsbCBuZXZlciBiZSBwbGFjZWQgb3V0c2lkZSBvZiB0aGUgZGVmaW5lZCBib3VuZGFyaWVzXG4gICAgICogKGV4Y2VwdCBpZiBga2VlcFRvZ2V0aGVyYCBpcyBlbmFibGVkKVxuICAgICAqL1xuICAgIGJvdW5kYXJpZXNFbGVtZW50OiAndmlld3BvcnQnXG4gIH0sXG5cbiAgLyoqXG4gICAqIE1vZGlmaWVyIHVzZWQgdG8gbWFrZSB0aGUgcG9wcGVyIGZsb3cgdG93YXJkIHRoZSBpbm5lciBvZiB0aGUgcmVmZXJlbmNlIGVsZW1lbnQuXG4gICAqIEJ5IGRlZmF1bHQsIHdoZW4gdGhpcyBtb2RpZmllciBpcyBkaXNhYmxlZCwgdGhlIHBvcHBlciB3aWxsIGJlIHBsYWNlZCBvdXRzaWRlXG4gICAqIHRoZSByZWZlcmVuY2UgZWxlbWVudC5cbiAgICogQG1lbWJlcm9mIG1vZGlmaWVyc1xuICAgKiBAaW5uZXJcbiAgICovXG4gIGlubmVyOiB7XG4gICAgLyoqIEBwcm9wIHtudW1iZXJ9IG9yZGVyPTcwMCAtIEluZGV4IHVzZWQgdG8gZGVmaW5lIHRoZSBvcmRlciBvZiBleGVjdXRpb24gKi9cbiAgICBvcmRlcjogNzAwLFxuICAgIC8qKiBAcHJvcCB7Qm9vbGVhbn0gZW5hYmxlZD1mYWxzZSAtIFdoZXRoZXIgdGhlIG1vZGlmaWVyIGlzIGVuYWJsZWQgb3Igbm90ICovXG4gICAgZW5hYmxlZDogZmFsc2UsXG4gICAgLyoqIEBwcm9wIHtNb2RpZmllckZufSAqL1xuICAgIGZuOiBpbm5lclxuICB9LFxuXG4gIC8qKlxuICAgKiBNb2RpZmllciB1c2VkIHRvIGhpZGUgdGhlIHBvcHBlciB3aGVuIGl0cyByZWZlcmVuY2UgZWxlbWVudCBpcyBvdXRzaWRlIG9mIHRoZVxuICAgKiBwb3BwZXIgYm91bmRhcmllcy4gSXQgd2lsbCBzZXQgYSBgeC1vdXQtb2YtYm91bmRhcmllc2AgYXR0cmlidXRlIHdoaWNoIGNhblxuICAgKiBiZSB1c2VkIHRvIGhpZGUgd2l0aCBhIENTUyBzZWxlY3RvciB0aGUgcG9wcGVyIHdoZW4gaXRzIHJlZmVyZW5jZSBpc1xuICAgKiBvdXQgb2YgYm91bmRhcmllcy5cbiAgICpcbiAgICogUmVxdWlyZXMgdGhlIGBwcmV2ZW50T3ZlcmZsb3dgIG1vZGlmaWVyIGJlZm9yZSBpdCBpbiBvcmRlciB0byB3b3JrLlxuICAgKiBAbWVtYmVyb2YgbW9kaWZpZXJzXG4gICAqIEBpbm5lclxuICAgKi9cbiAgaGlkZToge1xuICAgIC8qKiBAcHJvcCB7bnVtYmVyfSBvcmRlcj04MDAgLSBJbmRleCB1c2VkIHRvIGRlZmluZSB0aGUgb3JkZXIgb2YgZXhlY3V0aW9uICovXG4gICAgb3JkZXI6IDgwMCxcbiAgICAvKiogQHByb3Age0Jvb2xlYW59IGVuYWJsZWQ9dHJ1ZSAtIFdoZXRoZXIgdGhlIG1vZGlmaWVyIGlzIGVuYWJsZWQgb3Igbm90ICovXG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAvKiogQHByb3Age01vZGlmaWVyRm59ICovXG4gICAgZm46IGhpZGVcbiAgfSxcblxuICAvKipcbiAgICogQ29tcHV0ZXMgdGhlIHN0eWxlIHRoYXQgd2lsbCBiZSBhcHBsaWVkIHRvIHRoZSBwb3BwZXIgZWxlbWVudCB0byBnZXRzXG4gICAqIHByb3Blcmx5IHBvc2l0aW9uZWQuXG4gICAqXG4gICAqIE5vdGUgdGhhdCB0aGlzIG1vZGlmaWVyIHdpbGwgbm90IHRvdWNoIHRoZSBET00sIGl0IGp1c3QgcHJlcGFyZXMgdGhlIHN0eWxlc1xuICAgKiBzbyB0aGF0IGBhcHBseVN0eWxlYCBtb2RpZmllciBjYW4gYXBwbHkgaXQuIFRoaXMgc2VwYXJhdGlvbiBpcyB1c2VmdWxcbiAgICogaW4gY2FzZSB5b3UgbmVlZCB0byByZXBsYWNlIGBhcHBseVN0eWxlYCB3aXRoIGEgY3VzdG9tIGltcGxlbWVudGF0aW9uLlxuICAgKlxuICAgKiBUaGlzIG1vZGlmaWVyIGhhcyBgODUwYCBhcyBgb3JkZXJgIHZhbHVlIHRvIG1haW50YWluIGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcbiAgICogd2l0aCBwcmV2aW91cyB2ZXJzaW9ucyBvZiBQb3BwZXIuanMuIEV4cGVjdCB0aGUgbW9kaWZpZXJzIG9yZGVyaW5nIG1ldGhvZFxuICAgKiB0byBjaGFuZ2UgaW4gZnV0dXJlIG1ham9yIHZlcnNpb25zIG9mIHRoZSBsaWJyYXJ5LlxuICAgKlxuICAgKiBAbWVtYmVyb2YgbW9kaWZpZXJzXG4gICAqIEBpbm5lclxuICAgKi9cbiAgY29tcHV0ZVN0eWxlOiB7XG4gICAgLyoqIEBwcm9wIHtudW1iZXJ9IG9yZGVyPTg1MCAtIEluZGV4IHVzZWQgdG8gZGVmaW5lIHRoZSBvcmRlciBvZiBleGVjdXRpb24gKi9cbiAgICBvcmRlcjogODUwLFxuICAgIC8qKiBAcHJvcCB7Qm9vbGVhbn0gZW5hYmxlZD10cnVlIC0gV2hldGhlciB0aGUgbW9kaWZpZXIgaXMgZW5hYmxlZCBvciBub3QgKi9cbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIC8qKiBAcHJvcCB7TW9kaWZpZXJGbn0gKi9cbiAgICBmbjogY29tcHV0ZVN0eWxlLFxuICAgIC8qKlxuICAgICAqIEBwcm9wIHtCb29sZWFufSBncHVBY2NlbGVyYXRpb249dHJ1ZVxuICAgICAqIElmIHRydWUsIGl0IHVzZXMgdGhlIENTUyAzRCB0cmFuc2Zvcm1hdGlvbiB0byBwb3NpdGlvbiB0aGUgcG9wcGVyLlxuICAgICAqIE90aGVyd2lzZSwgaXQgd2lsbCB1c2UgdGhlIGB0b3BgIGFuZCBgbGVmdGAgcHJvcGVydGllc1xuICAgICAqL1xuICAgIGdwdUFjY2VsZXJhdGlvbjogdHJ1ZSxcbiAgICAvKipcbiAgICAgKiBAcHJvcCB7c3RyaW5nfSBbeD0nYm90dG9tJ11cbiAgICAgKiBXaGVyZSB0byBhbmNob3IgdGhlIFggYXhpcyAoYGJvdHRvbWAgb3IgYHRvcGApLiBBS0EgWCBvZmZzZXQgb3JpZ2luLlxuICAgICAqIENoYW5nZSB0aGlzIGlmIHlvdXIgcG9wcGVyIHNob3VsZCBncm93IGluIGEgZGlyZWN0aW9uIGRpZmZlcmVudCBmcm9tIGBib3R0b21gXG4gICAgICovXG4gICAgeDogJ2JvdHRvbScsXG4gICAgLyoqXG4gICAgICogQHByb3Age3N0cmluZ30gW3g9J2xlZnQnXVxuICAgICAqIFdoZXJlIHRvIGFuY2hvciB0aGUgWSBheGlzIChgbGVmdGAgb3IgYHJpZ2h0YCkuIEFLQSBZIG9mZnNldCBvcmlnaW4uXG4gICAgICogQ2hhbmdlIHRoaXMgaWYgeW91ciBwb3BwZXIgc2hvdWxkIGdyb3cgaW4gYSBkaXJlY3Rpb24gZGlmZmVyZW50IGZyb20gYHJpZ2h0YFxuICAgICAqL1xuICAgIHk6ICdyaWdodCdcbiAgfSxcblxuICAvKipcbiAgICogQXBwbGllcyB0aGUgY29tcHV0ZWQgc3R5bGVzIHRvIHRoZSBwb3BwZXIgZWxlbWVudC5cbiAgICpcbiAgICogQWxsIHRoZSBET00gbWFuaXB1bGF0aW9ucyBhcmUgbGltaXRlZCB0byB0aGlzIG1vZGlmaWVyLiBUaGlzIGlzIHVzZWZ1bCBpbiBjYXNlXG4gICAqIHlvdSB3YW50IHRvIGludGVncmF0ZSBQb3BwZXIuanMgaW5zaWRlIGEgZnJhbWV3b3JrIG9yIHZpZXcgbGlicmFyeSBhbmQgeW91XG4gICAqIHdhbnQgdG8gZGVsZWdhdGUgYWxsIHRoZSBET00gbWFuaXB1bGF0aW9ucyB0byBpdC5cbiAgICpcbiAgICogTm90ZSB0aGF0IGlmIHlvdSBkaXNhYmxlIHRoaXMgbW9kaWZpZXIsIHlvdSBtdXN0IG1ha2Ugc3VyZSB0aGUgcG9wcGVyIGVsZW1lbnRcbiAgICogaGFzIGl0cyBwb3NpdGlvbiBzZXQgdG8gYGFic29sdXRlYCBiZWZvcmUgUG9wcGVyLmpzIGNhbiBkbyBpdHMgd29yayFcbiAgICpcbiAgICogSnVzdCBkaXNhYmxlIHRoaXMgbW9kaWZpZXIgYW5kIGRlZmluZSB5b3VyIG93biB0byBhY2hpZXZlIHRoZSBkZXNpcmVkIGVmZmVjdC5cbiAgICpcbiAgICogQG1lbWJlcm9mIG1vZGlmaWVyc1xuICAgKiBAaW5uZXJcbiAgICovXG4gIGFwcGx5U3R5bGU6IHtcbiAgICAvKiogQHByb3Age251bWJlcn0gb3JkZXI9OTAwIC0gSW5kZXggdXNlZCB0byBkZWZpbmUgdGhlIG9yZGVyIG9mIGV4ZWN1dGlvbiAqL1xuICAgIG9yZGVyOiA5MDAsXG4gICAgLyoqIEBwcm9wIHtCb29sZWFufSBlbmFibGVkPXRydWUgLSBXaGV0aGVyIHRoZSBtb2RpZmllciBpcyBlbmFibGVkIG9yIG5vdCAqL1xuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgLyoqIEBwcm9wIHtNb2RpZmllckZufSAqL1xuICAgIGZuOiBhcHBseVN0eWxlLFxuICAgIC8qKiBAcHJvcCB7RnVuY3Rpb259ICovXG4gICAgb25Mb2FkOiBhcHBseVN0eWxlT25Mb2FkLFxuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMS4xMC4wLCB0aGUgcHJvcGVydHkgbW92ZWQgdG8gYGNvbXB1dGVTdHlsZWAgbW9kaWZpZXJcbiAgICAgKiBAcHJvcCB7Qm9vbGVhbn0gZ3B1QWNjZWxlcmF0aW9uPXRydWVcbiAgICAgKiBJZiB0cnVlLCBpdCB1c2VzIHRoZSBDU1MgM0QgdHJhbnNmb3JtYXRpb24gdG8gcG9zaXRpb24gdGhlIHBvcHBlci5cbiAgICAgKiBPdGhlcndpc2UsIGl0IHdpbGwgdXNlIHRoZSBgdG9wYCBhbmQgYGxlZnRgIHByb3BlcnRpZXNcbiAgICAgKi9cbiAgICBncHVBY2NlbGVyYXRpb246IHVuZGVmaW5lZFxuICB9XG59O1xuXG4vKipcbiAqIFRoZSBgZGF0YU9iamVjdGAgaXMgYW4gb2JqZWN0IGNvbnRhaW5pbmcgYWxsIHRoZSBpbmZvcm1hdGlvbiB1c2VkIGJ5IFBvcHBlci5qcy5cbiAqIFRoaXMgb2JqZWN0IGlzIHBhc3NlZCB0byBtb2RpZmllcnMgYW5kIHRvIHRoZSBgb25DcmVhdGVgIGFuZCBgb25VcGRhdGVgIGNhbGxiYWNrcy5cbiAqIEBuYW1lIGRhdGFPYmplY3RcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBkYXRhLmluc3RhbmNlIFRoZSBQb3BwZXIuanMgaW5zdGFuY2VcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBkYXRhLnBsYWNlbWVudCBQbGFjZW1lbnQgYXBwbGllZCB0byBwb3BwZXJcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBkYXRhLm9yaWdpbmFsUGxhY2VtZW50IFBsYWNlbWVudCBvcmlnaW5hbGx5IGRlZmluZWQgb24gaW5pdFxuICogQHByb3BlcnR5IHtCb29sZWFufSBkYXRhLmZsaXBwZWQgVHJ1ZSBpZiBwb3BwZXIgaGFzIGJlZW4gZmxpcHBlZCBieSBmbGlwIG1vZGlmaWVyXG4gKiBAcHJvcGVydHkge0Jvb2xlYW59IGRhdGEuaGlkZSBUcnVlIGlmIHRoZSByZWZlcmVuY2UgZWxlbWVudCBpcyBvdXQgb2YgYm91bmRhcmllcywgdXNlZnVsIHRvIGtub3cgd2hlbiB0byBoaWRlIHRoZSBwb3BwZXJcbiAqIEBwcm9wZXJ0eSB7SFRNTEVsZW1lbnR9IGRhdGEuYXJyb3dFbGVtZW50IE5vZGUgdXNlZCBhcyBhcnJvdyBieSBhcnJvdyBtb2RpZmllclxuICogQHByb3BlcnR5IHtPYmplY3R9IGRhdGEuc3R5bGVzIEFueSBDU1MgcHJvcGVydHkgZGVmaW5lZCBoZXJlIHdpbGwgYmUgYXBwbGllZCB0byB0aGUgcG9wcGVyLiBJdCBleHBlY3RzIHRoZSBKYXZhU2NyaXB0IG5vbWVuY2xhdHVyZSAoZWcuIGBtYXJnaW5Cb3R0b21gKVxuICogQHByb3BlcnR5IHtPYmplY3R9IGRhdGEuYXJyb3dTdHlsZXMgQW55IENTUyBwcm9wZXJ0eSBkZWZpbmVkIGhlcmUgd2lsbCBiZSBhcHBsaWVkIHRvIHRoZSBwb3BwZXIgYXJyb3cuIEl0IGV4cGVjdHMgdGhlIEphdmFTY3JpcHQgbm9tZW5jbGF0dXJlIChlZy4gYG1hcmdpbkJvdHRvbWApXG4gKiBAcHJvcGVydHkge09iamVjdH0gZGF0YS5ib3VuZGFyaWVzIE9mZnNldHMgb2YgdGhlIHBvcHBlciBib3VuZGFyaWVzXG4gKiBAcHJvcGVydHkge09iamVjdH0gZGF0YS5vZmZzZXRzIFRoZSBtZWFzdXJlbWVudHMgb2YgcG9wcGVyLCByZWZlcmVuY2UgYW5kIGFycm93IGVsZW1lbnRzXG4gKiBAcHJvcGVydHkge09iamVjdH0gZGF0YS5vZmZzZXRzLnBvcHBlciBgdG9wYCwgYGxlZnRgLCBgd2lkdGhgLCBgaGVpZ2h0YCB2YWx1ZXNcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBkYXRhLm9mZnNldHMucmVmZXJlbmNlIGB0b3BgLCBgbGVmdGAsIGB3aWR0aGAsIGBoZWlnaHRgIHZhbHVlc1xuICogQHByb3BlcnR5IHtPYmplY3R9IGRhdGEub2Zmc2V0cy5hcnJvd10gYHRvcGAgYW5kIGBsZWZ0YCBvZmZzZXRzLCBvbmx5IG9uZSBvZiB0aGVtIHdpbGwgYmUgZGlmZmVyZW50IGZyb20gMFxuICovXG5cbi8qKlxuICogRGVmYXVsdCBvcHRpb25zIHByb3ZpZGVkIHRvIFBvcHBlci5qcyBjb25zdHJ1Y3Rvci48YnIgLz5cbiAqIFRoZXNlIGNhbiBiZSBvdmVycmlkZGVuIHVzaW5nIHRoZSBgb3B0aW9uc2AgYXJndW1lbnQgb2YgUG9wcGVyLmpzLjxiciAvPlxuICogVG8gb3ZlcnJpZGUgYW4gb3B0aW9uLCBzaW1wbHkgcGFzcyBhbiBvYmplY3Qgd2l0aCB0aGUgc2FtZVxuICogc3RydWN0dXJlIG9mIHRoZSBgb3B0aW9uc2Agb2JqZWN0LCBhcyB0aGUgM3JkIGFyZ3VtZW50LiBGb3IgZXhhbXBsZTpcbiAqIGBgYFxuICogbmV3IFBvcHBlcihyZWYsIHBvcCwge1xuICogICBtb2RpZmllcnM6IHtcbiAqICAgICBwcmV2ZW50T3ZlcmZsb3c6IHsgZW5hYmxlZDogZmFsc2UgfVxuICogICB9XG4gKiB9KVxuICogYGBgXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQHN0YXRpY1xuICogQG1lbWJlcm9mIFBvcHBlclxuICovXG52YXIgRGVmYXVsdHMgPSB7XG4gIC8qKlxuICAgKiBQb3BwZXIncyBwbGFjZW1lbnQuXG4gICAqIEBwcm9wIHtQb3BwZXIucGxhY2VtZW50c30gcGxhY2VtZW50PSdib3R0b20nXG4gICAqL1xuICBwbGFjZW1lbnQ6ICdib3R0b20nLFxuXG4gIC8qKlxuICAgKiBTZXQgdGhpcyB0byB0cnVlIGlmIHlvdSB3YW50IHBvcHBlciB0byBwb3NpdGlvbiBpdCBzZWxmIGluICdmaXhlZCcgbW9kZVxuICAgKiBAcHJvcCB7Qm9vbGVhbn0gcG9zaXRpb25GaXhlZD1mYWxzZVxuICAgKi9cbiAgcG9zaXRpb25GaXhlZDogZmFsc2UsXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgZXZlbnRzIChyZXNpemUsIHNjcm9sbCkgYXJlIGluaXRpYWxseSBlbmFibGVkLlxuICAgKiBAcHJvcCB7Qm9vbGVhbn0gZXZlbnRzRW5hYmxlZD10cnVlXG4gICAqL1xuICBldmVudHNFbmFibGVkOiB0cnVlLFxuXG4gIC8qKlxuICAgKiBTZXQgdG8gdHJ1ZSBpZiB5b3Ugd2FudCB0byBhdXRvbWF0aWNhbGx5IHJlbW92ZSB0aGUgcG9wcGVyIHdoZW5cbiAgICogeW91IGNhbGwgdGhlIGBkZXN0cm95YCBtZXRob2QuXG4gICAqIEBwcm9wIHtCb29sZWFufSByZW1vdmVPbkRlc3Ryb3k9ZmFsc2VcbiAgICovXG4gIHJlbW92ZU9uRGVzdHJveTogZmFsc2UsXG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIGNhbGxlZCB3aGVuIHRoZSBwb3BwZXIgaXMgY3JlYXRlZC48YnIgLz5cbiAgICogQnkgZGVmYXVsdCwgaXQgaXMgc2V0IHRvIG5vLW9wLjxiciAvPlxuICAgKiBBY2Nlc3MgUG9wcGVyLmpzIGluc3RhbmNlIHdpdGggYGRhdGEuaW5zdGFuY2VgLlxuICAgKiBAcHJvcCB7b25DcmVhdGV9XG4gICAqL1xuICBvbkNyZWF0ZTogZnVuY3Rpb24gb25DcmVhdGUoKSB7fSxcblxuICAvKipcbiAgICogQ2FsbGJhY2sgY2FsbGVkIHdoZW4gdGhlIHBvcHBlciBpcyB1cGRhdGVkLiBUaGlzIGNhbGxiYWNrIGlzIG5vdCBjYWxsZWRcbiAgICogb24gdGhlIGluaXRpYWxpemF0aW9uL2NyZWF0aW9uIG9mIHRoZSBwb3BwZXIsIGJ1dCBvbmx5IG9uIHN1YnNlcXVlbnRcbiAgICogdXBkYXRlcy48YnIgLz5cbiAgICogQnkgZGVmYXVsdCwgaXQgaXMgc2V0IHRvIG5vLW9wLjxiciAvPlxuICAgKiBBY2Nlc3MgUG9wcGVyLmpzIGluc3RhbmNlIHdpdGggYGRhdGEuaW5zdGFuY2VgLlxuICAgKiBAcHJvcCB7b25VcGRhdGV9XG4gICAqL1xuICBvblVwZGF0ZTogZnVuY3Rpb24gb25VcGRhdGUoKSB7fSxcblxuICAvKipcbiAgICogTGlzdCBvZiBtb2RpZmllcnMgdXNlZCB0byBtb2RpZnkgdGhlIG9mZnNldHMgYmVmb3JlIHRoZXkgYXJlIGFwcGxpZWQgdG8gdGhlIHBvcHBlci5cbiAgICogVGhleSBwcm92aWRlIG1vc3Qgb2YgdGhlIGZ1bmN0aW9uYWxpdGllcyBvZiBQb3BwZXIuanMuXG4gICAqIEBwcm9wIHttb2RpZmllcnN9XG4gICAqL1xuICBtb2RpZmllcnM6IG1vZGlmaWVyc1xufTtcblxuLyoqXG4gKiBAY2FsbGJhY2sgb25DcmVhdGVcbiAqIEBwYXJhbSB7ZGF0YU9iamVjdH0gZGF0YVxuICovXG5cbi8qKlxuICogQGNhbGxiYWNrIG9uVXBkYXRlXG4gKiBAcGFyYW0ge2RhdGFPYmplY3R9IGRhdGFcbiAqL1xuXG4vLyBVdGlsc1xuLy8gTWV0aG9kc1xudmFyIFBvcHBlciA9IGZ1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgUG9wcGVyLmpzIGluc3RhbmNlLlxuICAgKiBAY2xhc3MgUG9wcGVyXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR8cmVmZXJlbmNlT2JqZWN0fSByZWZlcmVuY2UgLSBUaGUgcmVmZXJlbmNlIGVsZW1lbnQgdXNlZCB0byBwb3NpdGlvbiB0aGUgcG9wcGVyXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHBvcHBlciAtIFRoZSBIVE1MIGVsZW1lbnQgdXNlZCBhcyB0aGUgcG9wcGVyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gWW91ciBjdXN0b20gb3B0aW9ucyB0byBvdmVycmlkZSB0aGUgb25lcyBkZWZpbmVkIGluIFtEZWZhdWx0c10oI2RlZmF1bHRzKVxuICAgKiBAcmV0dXJuIHtPYmplY3R9IGluc3RhbmNlIC0gVGhlIGdlbmVyYXRlZCBQb3BwZXIuanMgaW5zdGFuY2VcbiAgICovXG4gIGZ1bmN0aW9uIFBvcHBlcihyZWZlcmVuY2UsIHBvcHBlcikge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgUG9wcGVyKTtcblxuICAgIHRoaXMuc2NoZWR1bGVVcGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKF90aGlzLnVwZGF0ZSk7XG4gICAgfTtcblxuICAgIC8vIG1ha2UgdXBkYXRlKCkgZGVib3VuY2VkLCBzbyB0aGF0IGl0IG9ubHkgcnVucyBhdCBtb3N0IG9uY2UtcGVyLXRpY2tcbiAgICB0aGlzLnVwZGF0ZSA9IGRlYm91bmNlKHRoaXMudXBkYXRlLmJpbmQodGhpcykpO1xuXG4gICAgLy8gd2l0aCB7fSB3ZSBjcmVhdGUgYSBuZXcgb2JqZWN0IHdpdGggdGhlIG9wdGlvbnMgaW5zaWRlIGl0XG4gICAgdGhpcy5vcHRpb25zID0gX2V4dGVuZHMoe30sIFBvcHBlci5EZWZhdWx0cywgb3B0aW9ucyk7XG5cbiAgICAvLyBpbml0IHN0YXRlXG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIGlzRGVzdHJveWVkOiBmYWxzZSxcbiAgICAgIGlzQ3JlYXRlZDogZmFsc2UsXG4gICAgICBzY3JvbGxQYXJlbnRzOiBbXVxuICAgIH07XG5cbiAgICAvLyBnZXQgcmVmZXJlbmNlIGFuZCBwb3BwZXIgZWxlbWVudHMgKGFsbG93IGpRdWVyeSB3cmFwcGVycylcbiAgICB0aGlzLnJlZmVyZW5jZSA9IHJlZmVyZW5jZSAmJiByZWZlcmVuY2UuanF1ZXJ5ID8gcmVmZXJlbmNlWzBdIDogcmVmZXJlbmNlO1xuICAgIHRoaXMucG9wcGVyID0gcG9wcGVyICYmIHBvcHBlci5qcXVlcnkgPyBwb3BwZXJbMF0gOiBwb3BwZXI7XG5cbiAgICAvLyBEZWVwIG1lcmdlIG1vZGlmaWVycyBvcHRpb25zXG4gICAgdGhpcy5vcHRpb25zLm1vZGlmaWVycyA9IHt9O1xuICAgIE9iamVjdC5rZXlzKF9leHRlbmRzKHt9LCBQb3BwZXIuRGVmYXVsdHMubW9kaWZpZXJzLCBvcHRpb25zLm1vZGlmaWVycykpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIF90aGlzLm9wdGlvbnMubW9kaWZpZXJzW25hbWVdID0gX2V4dGVuZHMoe30sIFBvcHBlci5EZWZhdWx0cy5tb2RpZmllcnNbbmFtZV0gfHwge30sIG9wdGlvbnMubW9kaWZpZXJzID8gb3B0aW9ucy5tb2RpZmllcnNbbmFtZV0gOiB7fSk7XG4gICAgfSk7XG5cbiAgICAvLyBSZWZhY3RvcmluZyBtb2RpZmllcnMnIGxpc3QgKE9iamVjdCA9PiBBcnJheSlcbiAgICB0aGlzLm1vZGlmaWVycyA9IE9iamVjdC5rZXlzKHRoaXMub3B0aW9ucy5tb2RpZmllcnMpLm1hcChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgcmV0dXJuIF9leHRlbmRzKHtcbiAgICAgICAgbmFtZTogbmFtZVxuICAgICAgfSwgX3RoaXMub3B0aW9ucy5tb2RpZmllcnNbbmFtZV0pO1xuICAgIH0pXG4gICAgLy8gc29ydCB0aGUgbW9kaWZpZXJzIGJ5IG9yZGVyXG4gICAgLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHJldHVybiBhLm9yZGVyIC0gYi5vcmRlcjtcbiAgICB9KTtcblxuICAgIC8vIG1vZGlmaWVycyBoYXZlIHRoZSBhYmlsaXR5IHRvIGV4ZWN1dGUgYXJiaXRyYXJ5IGNvZGUgd2hlbiBQb3BwZXIuanMgZ2V0IGluaXRlZFxuICAgIC8vIHN1Y2ggY29kZSBpcyBleGVjdXRlZCBpbiB0aGUgc2FtZSBvcmRlciBvZiBpdHMgbW9kaWZpZXJcbiAgICAvLyB0aGV5IGNvdWxkIGFkZCBuZXcgcHJvcGVydGllcyB0byB0aGVpciBvcHRpb25zIGNvbmZpZ3VyYXRpb25cbiAgICAvLyBCRSBBV0FSRTogZG9uJ3QgYWRkIG9wdGlvbnMgdG8gYG9wdGlvbnMubW9kaWZpZXJzLm5hbWVgIGJ1dCB0byBgbW9kaWZpZXJPcHRpb25zYCFcbiAgICB0aGlzLm1vZGlmaWVycy5mb3JFYWNoKGZ1bmN0aW9uIChtb2RpZmllck9wdGlvbnMpIHtcbiAgICAgIGlmIChtb2RpZmllck9wdGlvbnMuZW5hYmxlZCAmJiBpc0Z1bmN0aW9uKG1vZGlmaWVyT3B0aW9ucy5vbkxvYWQpKSB7XG4gICAgICAgIG1vZGlmaWVyT3B0aW9ucy5vbkxvYWQoX3RoaXMucmVmZXJlbmNlLCBfdGhpcy5wb3BwZXIsIF90aGlzLm9wdGlvbnMsIG1vZGlmaWVyT3B0aW9ucywgX3RoaXMuc3RhdGUpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gZmlyZSB0aGUgZmlyc3QgdXBkYXRlIHRvIHBvc2l0aW9uIHRoZSBwb3BwZXIgaW4gdGhlIHJpZ2h0IHBsYWNlXG4gICAgdGhpcy51cGRhdGUoKTtcblxuICAgIHZhciBldmVudHNFbmFibGVkID0gdGhpcy5vcHRpb25zLmV2ZW50c0VuYWJsZWQ7XG4gICAgaWYgKGV2ZW50c0VuYWJsZWQpIHtcbiAgICAgIC8vIHNldHVwIGV2ZW50IGxpc3RlbmVycywgdGhleSB3aWxsIHRha2UgY2FyZSBvZiB1cGRhdGUgdGhlIHBvc2l0aW9uIGluIHNwZWNpZmljIHNpdHVhdGlvbnNcbiAgICAgIHRoaXMuZW5hYmxlRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICB9XG5cbiAgICB0aGlzLnN0YXRlLmV2ZW50c0VuYWJsZWQgPSBldmVudHNFbmFibGVkO1xuICB9XG5cbiAgLy8gV2UgY2FuJ3QgdXNlIGNsYXNzIHByb3BlcnRpZXMgYmVjYXVzZSB0aGV5IGRvbid0IGdldCBsaXN0ZWQgaW4gdGhlXG4gIC8vIGNsYXNzIHByb3RvdHlwZSBhbmQgYnJlYWsgc3R1ZmYgbGlrZSBTaW5vbiBzdHVic1xuXG5cbiAgY3JlYXRlQ2xhc3MoUG9wcGVyLCBbe1xuICAgIGtleTogJ3VwZGF0ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZSQkMSgpIHtcbiAgICAgIHJldHVybiB1cGRhdGUuY2FsbCh0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdkZXN0cm95JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveSQkMSgpIHtcbiAgICAgIHJldHVybiBkZXN0cm95LmNhbGwodGhpcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZW5hYmxlRXZlbnRMaXN0ZW5lcnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbmFibGVFdmVudExpc3RlbmVycyQkMSgpIHtcbiAgICAgIHJldHVybiBlbmFibGVFdmVudExpc3RlbmVycy5jYWxsKHRoaXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2Rpc2FibGVFdmVudExpc3RlbmVycycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRpc2FibGVFdmVudExpc3RlbmVycyQkMSgpIHtcbiAgICAgIHJldHVybiBkaXNhYmxlRXZlbnRMaXN0ZW5lcnMuY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTY2hlZHVsZXMgYW4gdXBkYXRlLiBJdCB3aWxsIHJ1biBvbiB0aGUgbmV4dCBVSSB1cGRhdGUgYXZhaWxhYmxlLlxuICAgICAqIEBtZXRob2Qgc2NoZWR1bGVVcGRhdGVcbiAgICAgKiBAbWVtYmVyb2YgUG9wcGVyXG4gICAgICovXG5cblxuICAgIC8qKlxuICAgICAqIENvbGxlY3Rpb24gb2YgdXRpbGl0aWVzIHVzZWZ1bCB3aGVuIHdyaXRpbmcgY3VzdG9tIG1vZGlmaWVycy5cbiAgICAgKiBTdGFydGluZyBmcm9tIHZlcnNpb24gMS43LCB0aGlzIG1ldGhvZCBpcyBhdmFpbGFibGUgb25seSBpZiB5b3VcbiAgICAgKiBpbmNsdWRlIGBwb3BwZXItdXRpbHMuanNgIGJlZm9yZSBgcG9wcGVyLmpzYC5cbiAgICAgKlxuICAgICAqICoqREVQUkVDQVRJT04qKjogVGhpcyB3YXkgdG8gYWNjZXNzIFBvcHBlclV0aWxzIGlzIGRlcHJlY2F0ZWRcbiAgICAgKiBhbmQgd2lsbCBiZSByZW1vdmVkIGluIHYyISBVc2UgdGhlIFBvcHBlclV0aWxzIG1vZHVsZSBkaXJlY3RseSBpbnN0ZWFkLlxuICAgICAqIER1ZSB0byB0aGUgaGlnaCBpbnN0YWJpbGl0eSBvZiB0aGUgbWV0aG9kcyBjb250YWluZWQgaW4gVXRpbHMsIHdlIGNhbid0XG4gICAgICogZ3VhcmFudGVlIHRoZW0gdG8gZm9sbG93IHNlbXZlci4gVXNlIHRoZW0gYXQgeW91ciBvd24gcmlzayFcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMS44XG4gICAgICogQG1lbWJlciBVdGlsc1xuICAgICAqIEBtZW1iZXJvZiBQb3BwZXJcbiAgICAgKi9cblxuICB9XSk7XG4gIHJldHVybiBQb3BwZXI7XG59KCk7XG5cbi8qKlxuICogVGhlIGByZWZlcmVuY2VPYmplY3RgIGlzIGFuIG9iamVjdCB0aGF0IHByb3ZpZGVzIGFuIGludGVyZmFjZSBjb21wYXRpYmxlIHdpdGggUG9wcGVyLmpzXG4gKiBhbmQgbGV0cyB5b3UgdXNlIGl0IGFzIHJlcGxhY2VtZW50IG9mIGEgcmVhbCBET00gbm9kZS48YnIgLz5cbiAqIFlvdSBjYW4gdXNlIHRoaXMgbWV0aG9kIHRvIHBvc2l0aW9uIGEgcG9wcGVyIHJlbGF0aXZlbHkgdG8gYSBzZXQgb2YgY29vcmRpbmF0ZXNcbiAqIGluIGNhc2UgeW91IGRvbid0IGhhdmUgYSBET00gbm9kZSB0byB1c2UgYXMgcmVmZXJlbmNlLlxuICpcbiAqIGBgYFxuICogbmV3IFBvcHBlcihyZWZlcmVuY2VPYmplY3QsIHBvcHBlck5vZGUpO1xuICogYGBgXG4gKlxuICogTkI6IFRoaXMgZmVhdHVyZSBpc24ndCBzdXBwb3J0ZWQgaW4gSW50ZXJuZXQgRXhwbG9yZXIgMTAuXG4gKiBAbmFtZSByZWZlcmVuY2VPYmplY3RcbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IGRhdGEuZ2V0Qm91bmRpbmdDbGllbnRSZWN0XG4gKiBBIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIHNldCBvZiBjb29yZGluYXRlcyBjb21wYXRpYmxlIHdpdGggdGhlIG5hdGl2ZSBgZ2V0Qm91bmRpbmdDbGllbnRSZWN0YCBtZXRob2QuXG4gKiBAcHJvcGVydHkge251bWJlcn0gZGF0YS5jbGllbnRXaWR0aFxuICogQW4gRVM2IGdldHRlciB0aGF0IHdpbGwgcmV0dXJuIHRoZSB3aWR0aCBvZiB0aGUgdmlydHVhbCByZWZlcmVuY2UgZWxlbWVudC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBkYXRhLmNsaWVudEhlaWdodFxuICogQW4gRVM2IGdldHRlciB0aGF0IHdpbGwgcmV0dXJuIHRoZSBoZWlnaHQgb2YgdGhlIHZpcnR1YWwgcmVmZXJlbmNlIGVsZW1lbnQuXG4gKi9cblxuXG5Qb3BwZXIuVXRpbHMgPSAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiBnbG9iYWwpLlBvcHBlclV0aWxzO1xuUG9wcGVyLnBsYWNlbWVudHMgPSBwbGFjZW1lbnRzO1xuUG9wcGVyLkRlZmF1bHRzID0gRGVmYXVsdHM7XG5cbmV4cG9ydCBkZWZhdWx0IFBvcHBlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBvcHBlci5qcy5tYXBcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///9\n")},function(module,exports,__webpack_require__){"use strict";eval('\n\nvar _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };\n\nvar g;\n\n// This works in non-strict mode\ng = function () {\n\treturn this;\n}();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function("return this")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif ((typeof window === "undefined" ? "undefined" : _typeof(window)) === "object") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it\'s\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzP2NkMDAiXSwibmFtZXMiOlsiZyIsIkZ1bmN0aW9uIiwiZSIsIndpbmRvdyIsIm1vZHVsZSIsImV4cG9ydHMiXSwibWFwcGluZ3MiOiI7Ozs7QUFBQSxJQUFJQSxDQUFKOztBQUVBO0FBQ0FBLElBQUssWUFBVztBQUNmLFFBQU8sSUFBUDtBQUNBLENBRkcsRUFBSjs7QUFJQSxJQUFJO0FBQ0g7QUFDQUEsS0FBSUEsS0FBSyxJQUFJQyxRQUFKLENBQWEsYUFBYixHQUFUO0FBQ0EsQ0FIRCxDQUdFLE9BQU9DLENBQVAsRUFBVTtBQUNYO0FBQ0EsS0FBSSxRQUFPQyxNQUFQLHlDQUFPQSxNQUFQLE9BQWtCLFFBQXRCLEVBQWdDSCxJQUFJRyxNQUFKO0FBQ2hDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQUMsT0FBT0MsT0FBUCxHQUFpQkwsQ0FBakIiLCJmaWxlIjoiMTAuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZztcblxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcbmcgPSAoZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzO1xufSkoKTtcblxudHJ5IHtcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXG5cdGcgPSBnIHx8IG5ldyBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCk7XG59IGNhdGNoIChlKSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXG5cdGlmICh0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKSBnID0gd2luZG93O1xufVxuXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGc7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///10\n')}]);