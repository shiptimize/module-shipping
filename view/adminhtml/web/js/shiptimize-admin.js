/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ 866:
/***/ ((__unused_webpack_module, __unused_webpack___webpack_exports__, __webpack_require__) => {

eval("\n;// CONCATENATED MODULE: ./node_modules/popper.js/dist/esm/popper.js\n/**!\n * @fileOverview Kickass library to create and place poppers near their reference elements.\n * @version 1.16.1\n * @license\n * Copyright (c) 2016 Federico Zivolo and contributors\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\nvar isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined' && typeof navigator !== 'undefined';\nvar timeoutDuration = function () {\n  var longerTimeoutBrowsers = ['Edge', 'Trident', 'Firefox'];\n  for (var i = 0; i < longerTimeoutBrowsers.length; i += 1) {\n    if (isBrowser && navigator.userAgent.indexOf(longerTimeoutBrowsers[i]) >= 0) {\n      return 1;\n    }\n  }\n  return 0;\n}();\nfunction microtaskDebounce(fn) {\n  var called = false;\n  return function () {\n    if (called) {\n      return;\n    }\n    called = true;\n    window.Promise.resolve().then(function () {\n      called = false;\n      fn();\n    });\n  };\n}\nfunction taskDebounce(fn) {\n  var scheduled = false;\n  return function () {\n    if (!scheduled) {\n      scheduled = true;\n      setTimeout(function () {\n        scheduled = false;\n        fn();\n      }, timeoutDuration);\n    }\n  };\n}\nvar supportsMicroTasks = isBrowser && window.Promise;\n\n/**\n* Create a debounced version of a method, that's asynchronously deferred\n* but called in the minimum time possible.\n*\n* @method\n* @memberof Popper.Utils\n* @argument {Function} fn\n* @returns {Function}\n*/\nvar debounce = supportsMicroTasks ? microtaskDebounce : taskDebounce;\n\n/**\n * Check if the given variable is a function\n * @method\n * @memberof Popper.Utils\n * @argument {Any} functionToCheck - variable to check\n * @returns {Boolean} answer to: is a function?\n */\nfunction isFunction(functionToCheck) {\n  var getType = {};\n  return functionToCheck && getType.toString.call(functionToCheck) === '[object Function]';\n}\n\n/**\n * Get CSS computed property of the given element\n * @method\n * @memberof Popper.Utils\n * @argument {Eement} element\n * @argument {String} property\n */\nfunction getStyleComputedProperty(element, property) {\n  if (element.nodeType !== 1) {\n    return [];\n  }\n  // NOTE: 1 DOM access here\n  var window = element.ownerDocument.defaultView;\n  var css = window.getComputedStyle(element, null);\n  return property ? css[property] : css;\n}\n\n/**\n * Returns the parentNode or the host of the element\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @returns {Element} parent\n */\nfunction getParentNode(element) {\n  if (element.nodeName === 'HTML') {\n    return element;\n  }\n  return element.parentNode || element.host;\n}\n\n/**\n * Returns the scrolling parent of the given element\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @returns {Element} scroll parent\n */\nfunction getScrollParent(element) {\n  // Return body, `getScroll` will take care to get the correct `scrollTop` from it\n  if (!element) {\n    return document.body;\n  }\n  switch (element.nodeName) {\n    case 'HTML':\n    case 'BODY':\n      return element.ownerDocument.body;\n    case '#document':\n      return element.body;\n  }\n\n  // Firefox want us to check `-x` and `-y` variations as well\n\n  var _getStyleComputedProp = getStyleComputedProperty(element),\n    overflow = _getStyleComputedProp.overflow,\n    overflowX = _getStyleComputedProp.overflowX,\n    overflowY = _getStyleComputedProp.overflowY;\n  if (/(auto|scroll|overlay)/.test(overflow + overflowY + overflowX)) {\n    return element;\n  }\n  return getScrollParent(getParentNode(element));\n}\n\n/**\n * Returns the reference node of the reference object, or the reference object itself.\n * @method\n * @memberof Popper.Utils\n * @param {Element|Object} reference - the reference element (the popper will be relative to this)\n * @returns {Element} parent\n */\nfunction getReferenceNode(reference) {\n  return reference && reference.referenceNode ? reference.referenceNode : reference;\n}\nvar isIE11 = isBrowser && !!(window.MSInputMethodContext && document.documentMode);\nvar isIE10 = isBrowser && /MSIE 10/.test(navigator.userAgent);\n\n/**\n * Determines if the browser is Internet Explorer\n * @method\n * @memberof Popper.Utils\n * @param {Number} version to check\n * @returns {Boolean} isIE\n */\nfunction isIE(version) {\n  if (version === 11) {\n    return isIE11;\n  }\n  if (version === 10) {\n    return isIE10;\n  }\n  return isIE11 || isIE10;\n}\n\n/**\n * Returns the offset parent of the given element\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @returns {Element} offset parent\n */\nfunction getOffsetParent(element) {\n  if (!element) {\n    return document.documentElement;\n  }\n  var noOffsetParent = isIE(10) ? document.body : null;\n\n  // NOTE: 1 DOM access here\n  var offsetParent = element.offsetParent || null;\n  // Skip hidden elements which don't have an offsetParent\n  while (offsetParent === noOffsetParent && element.nextElementSibling) {\n    offsetParent = (element = element.nextElementSibling).offsetParent;\n  }\n  var nodeName = offsetParent && offsetParent.nodeName;\n  if (!nodeName || nodeName === 'BODY' || nodeName === 'HTML') {\n    return element ? element.ownerDocument.documentElement : document.documentElement;\n  }\n\n  // .offsetParent will return the closest TH, TD or TABLE in case\n  // no offsetParent is present, I hate this job...\n  if (['TH', 'TD', 'TABLE'].indexOf(offsetParent.nodeName) !== -1 && getStyleComputedProperty(offsetParent, 'position') === 'static') {\n    return getOffsetParent(offsetParent);\n  }\n  return offsetParent;\n}\nfunction isOffsetContainer(element) {\n  var nodeName = element.nodeName;\n  if (nodeName === 'BODY') {\n    return false;\n  }\n  return nodeName === 'HTML' || getOffsetParent(element.firstElementChild) === element;\n}\n\n/**\n * Finds the root node (document, shadowDOM root) of the given element\n * @method\n * @memberof Popper.Utils\n * @argument {Element} node\n * @returns {Element} root node\n */\nfunction getRoot(node) {\n  if (node.parentNode !== null) {\n    return getRoot(node.parentNode);\n  }\n  return node;\n}\n\n/**\n * Finds the offset parent common to the two provided nodes\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element1\n * @argument {Element} element2\n * @returns {Element} common offset parent\n */\nfunction findCommonOffsetParent(element1, element2) {\n  // This check is needed to avoid errors in case one of the elements isn't defined for any reason\n  if (!element1 || !element1.nodeType || !element2 || !element2.nodeType) {\n    return document.documentElement;\n  }\n\n  // Here we make sure to give as \"start\" the element that comes first in the DOM\n  var order = element1.compareDocumentPosition(element2) & Node.DOCUMENT_POSITION_FOLLOWING;\n  var start = order ? element1 : element2;\n  var end = order ? element2 : element1;\n\n  // Get common ancestor container\n  var range = document.createRange();\n  range.setStart(start, 0);\n  range.setEnd(end, 0);\n  var commonAncestorContainer = range.commonAncestorContainer;\n\n  // Both nodes are inside #document\n\n  if (element1 !== commonAncestorContainer && element2 !== commonAncestorContainer || start.contains(end)) {\n    if (isOffsetContainer(commonAncestorContainer)) {\n      return commonAncestorContainer;\n    }\n    return getOffsetParent(commonAncestorContainer);\n  }\n\n  // one of the nodes is inside shadowDOM, find which one\n  var element1root = getRoot(element1);\n  if (element1root.host) {\n    return findCommonOffsetParent(element1root.host, element2);\n  } else {\n    return findCommonOffsetParent(element1, getRoot(element2).host);\n  }\n}\n\n/**\n * Gets the scroll value of the given element in the given side (top and left)\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @argument {String} side `top` or `left`\n * @returns {number} amount of scrolled pixels\n */\nfunction getScroll(element) {\n  var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'top';\n  var upperSide = side === 'top' ? 'scrollTop' : 'scrollLeft';\n  var nodeName = element.nodeName;\n  if (nodeName === 'BODY' || nodeName === 'HTML') {\n    var html = element.ownerDocument.documentElement;\n    var scrollingElement = element.ownerDocument.scrollingElement || html;\n    return scrollingElement[upperSide];\n  }\n  return element[upperSide];\n}\n\n/*\n * Sum or subtract the element scroll values (left and top) from a given rect object\n * @method\n * @memberof Popper.Utils\n * @param {Object} rect - Rect object you want to change\n * @param {HTMLElement} element - The element from the function reads the scroll values\n * @param {Boolean} subtract - set to true if you want to subtract the scroll values\n * @return {Object} rect - The modifier rect object\n */\nfunction includeScroll(rect, element) {\n  var subtract = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  var scrollTop = getScroll(element, 'top');\n  var scrollLeft = getScroll(element, 'left');\n  var modifier = subtract ? -1 : 1;\n  rect.top += scrollTop * modifier;\n  rect.bottom += scrollTop * modifier;\n  rect.left += scrollLeft * modifier;\n  rect.right += scrollLeft * modifier;\n  return rect;\n}\n\n/*\n * Helper to detect borders of a given element\n * @method\n * @memberof Popper.Utils\n * @param {CSSStyleDeclaration} styles\n * Result of `getStyleComputedProperty` on the given element\n * @param {String} axis - `x` or `y`\n * @return {number} borders - The borders size of the given axis\n */\n\nfunction getBordersSize(styles, axis) {\n  var sideA = axis === 'x' ? 'Left' : 'Top';\n  var sideB = sideA === 'Left' ? 'Right' : 'Bottom';\n  return parseFloat(styles['border' + sideA + 'Width']) + parseFloat(styles['border' + sideB + 'Width']);\n}\nfunction getSize(axis, body, html, computedStyle) {\n  return Math.max(body['offset' + axis], body['scroll' + axis], html['client' + axis], html['offset' + axis], html['scroll' + axis], isIE(10) ? parseInt(html['offset' + axis]) + parseInt(computedStyle['margin' + (axis === 'Height' ? 'Top' : 'Left')]) + parseInt(computedStyle['margin' + (axis === 'Height' ? 'Bottom' : 'Right')]) : 0);\n}\nfunction getWindowSizes(document) {\n  var body = document.body;\n  var html = document.documentElement;\n  var computedStyle = isIE(10) && getComputedStyle(html);\n  return {\n    height: getSize('Height', body, html, computedStyle),\n    width: getSize('Width', body, html, computedStyle)\n  };\n}\nvar classCallCheck = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\nvar createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\nvar defineProperty = function (obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n};\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n  return target;\n};\n\n/**\n * Given element offsets, generate an output similar to getBoundingClientRect\n * @method\n * @memberof Popper.Utils\n * @argument {Object} offsets\n * @returns {Object} ClientRect like output\n */\nfunction getClientRect(offsets) {\n  return _extends({}, offsets, {\n    right: offsets.left + offsets.width,\n    bottom: offsets.top + offsets.height\n  });\n}\n\n/**\n * Get bounding client rect of given element\n * @method\n * @memberof Popper.Utils\n * @param {HTMLElement} element\n * @return {Object} client rect\n */\nfunction getBoundingClientRect(element) {\n  var rect = {};\n\n  // IE10 10 FIX: Please, don't ask, the element isn't\n  // considered in DOM in some circumstances...\n  // This isn't reproducible in IE10 compatibility mode of IE11\n  try {\n    if (isIE(10)) {\n      rect = element.getBoundingClientRect();\n      var scrollTop = getScroll(element, 'top');\n      var scrollLeft = getScroll(element, 'left');\n      rect.top += scrollTop;\n      rect.left += scrollLeft;\n      rect.bottom += scrollTop;\n      rect.right += scrollLeft;\n    } else {\n      rect = element.getBoundingClientRect();\n    }\n  } catch (e) {}\n  var result = {\n    left: rect.left,\n    top: rect.top,\n    width: rect.right - rect.left,\n    height: rect.bottom - rect.top\n  };\n\n  // subtract scrollbar size from sizes\n  var sizes = element.nodeName === 'HTML' ? getWindowSizes(element.ownerDocument) : {};\n  var width = sizes.width || element.clientWidth || result.width;\n  var height = sizes.height || element.clientHeight || result.height;\n  var horizScrollbar = element.offsetWidth - width;\n  var vertScrollbar = element.offsetHeight - height;\n\n  // if an hypothetical scrollbar is detected, we must be sure it's not a `border`\n  // we make this check conditional for performance reasons\n  if (horizScrollbar || vertScrollbar) {\n    var styles = getStyleComputedProperty(element);\n    horizScrollbar -= getBordersSize(styles, 'x');\n    vertScrollbar -= getBordersSize(styles, 'y');\n    result.width -= horizScrollbar;\n    result.height -= vertScrollbar;\n  }\n  return getClientRect(result);\n}\nfunction getOffsetRectRelativeToArbitraryNode(children, parent) {\n  var fixedPosition = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  var isIE10 = isIE(10);\n  var isHTML = parent.nodeName === 'HTML';\n  var childrenRect = getBoundingClientRect(children);\n  var parentRect = getBoundingClientRect(parent);\n  var scrollParent = getScrollParent(children);\n  var styles = getStyleComputedProperty(parent);\n  var borderTopWidth = parseFloat(styles.borderTopWidth);\n  var borderLeftWidth = parseFloat(styles.borderLeftWidth);\n\n  // In cases where the parent is fixed, we must ignore negative scroll in offset calc\n  if (fixedPosition && isHTML) {\n    parentRect.top = Math.max(parentRect.top, 0);\n    parentRect.left = Math.max(parentRect.left, 0);\n  }\n  var offsets = getClientRect({\n    top: childrenRect.top - parentRect.top - borderTopWidth,\n    left: childrenRect.left - parentRect.left - borderLeftWidth,\n    width: childrenRect.width,\n    height: childrenRect.height\n  });\n  offsets.marginTop = 0;\n  offsets.marginLeft = 0;\n\n  // Subtract margins of documentElement in case it's being used as parent\n  // we do this only on HTML because it's the only element that behaves\n  // differently when margins are applied to it. The margins are included in\n  // the box of the documentElement, in the other cases not.\n  if (!isIE10 && isHTML) {\n    var marginTop = parseFloat(styles.marginTop);\n    var marginLeft = parseFloat(styles.marginLeft);\n    offsets.top -= borderTopWidth - marginTop;\n    offsets.bottom -= borderTopWidth - marginTop;\n    offsets.left -= borderLeftWidth - marginLeft;\n    offsets.right -= borderLeftWidth - marginLeft;\n\n    // Attach marginTop and marginLeft because in some circumstances we may need them\n    offsets.marginTop = marginTop;\n    offsets.marginLeft = marginLeft;\n  }\n  if (isIE10 && !fixedPosition ? parent.contains(scrollParent) : parent === scrollParent && scrollParent.nodeName !== 'BODY') {\n    offsets = includeScroll(offsets, parent);\n  }\n  return offsets;\n}\nfunction getViewportOffsetRectRelativeToArtbitraryNode(element) {\n  var excludeScroll = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  var html = element.ownerDocument.documentElement;\n  var relativeOffset = getOffsetRectRelativeToArbitraryNode(element, html);\n  var width = Math.max(html.clientWidth, window.innerWidth || 0);\n  var height = Math.max(html.clientHeight, window.innerHeight || 0);\n  var scrollTop = !excludeScroll ? getScroll(html) : 0;\n  var scrollLeft = !excludeScroll ? getScroll(html, 'left') : 0;\n  var offset = {\n    top: scrollTop - relativeOffset.top + relativeOffset.marginTop,\n    left: scrollLeft - relativeOffset.left + relativeOffset.marginLeft,\n    width: width,\n    height: height\n  };\n  return getClientRect(offset);\n}\n\n/**\n * Check if the given element is fixed or is inside a fixed parent\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @argument {Element} customContainer\n * @returns {Boolean} answer to \"isFixed?\"\n */\nfunction isFixed(element) {\n  var nodeName = element.nodeName;\n  if (nodeName === 'BODY' || nodeName === 'HTML') {\n    return false;\n  }\n  if (getStyleComputedProperty(element, 'position') === 'fixed') {\n    return true;\n  }\n  var parentNode = getParentNode(element);\n  if (!parentNode) {\n    return false;\n  }\n  return isFixed(parentNode);\n}\n\n/**\n * Finds the first parent of an element that has a transformed property defined\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @returns {Element} first transformed parent or documentElement\n */\n\nfunction getFixedPositionOffsetParent(element) {\n  // This check is needed to avoid errors in case one of the elements isn't defined for any reason\n  if (!element || !element.parentElement || isIE()) {\n    return document.documentElement;\n  }\n  var el = element.parentElement;\n  while (el && getStyleComputedProperty(el, 'transform') === 'none') {\n    el = el.parentElement;\n  }\n  return el || document.documentElement;\n}\n\n/**\n * Computed the boundaries limits and return them\n * @method\n * @memberof Popper.Utils\n * @param {HTMLElement} popper\n * @param {HTMLElement} reference\n * @param {number} padding\n * @param {HTMLElement} boundariesElement - Element used to define the boundaries\n * @param {Boolean} fixedPosition - Is in fixed position mode\n * @returns {Object} Coordinates of the boundaries\n */\nfunction getBoundaries(popper, reference, padding, boundariesElement) {\n  var fixedPosition = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n\n  // NOTE: 1 DOM access here\n\n  var boundaries = {\n    top: 0,\n    left: 0\n  };\n  var offsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, getReferenceNode(reference));\n\n  // Handle viewport case\n  if (boundariesElement === 'viewport') {\n    boundaries = getViewportOffsetRectRelativeToArtbitraryNode(offsetParent, fixedPosition);\n  } else {\n    // Handle other cases based on DOM element used as boundaries\n    var boundariesNode = void 0;\n    if (boundariesElement === 'scrollParent') {\n      boundariesNode = getScrollParent(getParentNode(reference));\n      if (boundariesNode.nodeName === 'BODY') {\n        boundariesNode = popper.ownerDocument.documentElement;\n      }\n    } else if (boundariesElement === 'window') {\n      boundariesNode = popper.ownerDocument.documentElement;\n    } else {\n      boundariesNode = boundariesElement;\n    }\n    var offsets = getOffsetRectRelativeToArbitraryNode(boundariesNode, offsetParent, fixedPosition);\n\n    // In case of HTML, we need a different computation\n    if (boundariesNode.nodeName === 'HTML' && !isFixed(offsetParent)) {\n      var _getWindowSizes = getWindowSizes(popper.ownerDocument),\n        height = _getWindowSizes.height,\n        width = _getWindowSizes.width;\n      boundaries.top += offsets.top - offsets.marginTop;\n      boundaries.bottom = height + offsets.top;\n      boundaries.left += offsets.left - offsets.marginLeft;\n      boundaries.right = width + offsets.left;\n    } else {\n      // for all the other DOM elements, this one is good\n      boundaries = offsets;\n    }\n  }\n\n  // Add paddings\n  padding = padding || 0;\n  var isPaddingNumber = typeof padding === 'number';\n  boundaries.left += isPaddingNumber ? padding : padding.left || 0;\n  boundaries.top += isPaddingNumber ? padding : padding.top || 0;\n  boundaries.right -= isPaddingNumber ? padding : padding.right || 0;\n  boundaries.bottom -= isPaddingNumber ? padding : padding.bottom || 0;\n  return boundaries;\n}\nfunction getArea(_ref) {\n  var width = _ref.width,\n    height = _ref.height;\n  return width * height;\n}\n\n/**\n * Utility used to transform the `auto` placement to the placement with more\n * available space.\n * @method\n * @memberof Popper.Utils\n * @argument {Object} data - The data object generated by update method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction computeAutoPlacement(placement, refRect, popper, reference, boundariesElement) {\n  var padding = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;\n  if (placement.indexOf('auto') === -1) {\n    return placement;\n  }\n  var boundaries = getBoundaries(popper, reference, padding, boundariesElement);\n  var rects = {\n    top: {\n      width: boundaries.width,\n      height: refRect.top - boundaries.top\n    },\n    right: {\n      width: boundaries.right - refRect.right,\n      height: boundaries.height\n    },\n    bottom: {\n      width: boundaries.width,\n      height: boundaries.bottom - refRect.bottom\n    },\n    left: {\n      width: refRect.left - boundaries.left,\n      height: boundaries.height\n    }\n  };\n  var sortedAreas = Object.keys(rects).map(function (key) {\n    return _extends({\n      key: key\n    }, rects[key], {\n      area: getArea(rects[key])\n    });\n  }).sort(function (a, b) {\n    return b.area - a.area;\n  });\n  var filteredAreas = sortedAreas.filter(function (_ref2) {\n    var width = _ref2.width,\n      height = _ref2.height;\n    return width >= popper.clientWidth && height >= popper.clientHeight;\n  });\n  var computedPlacement = filteredAreas.length > 0 ? filteredAreas[0].key : sortedAreas[0].key;\n  var variation = placement.split('-')[1];\n  return computedPlacement + (variation ? '-' + variation : '');\n}\n\n/**\n * Get offsets to the reference element\n * @method\n * @memberof Popper.Utils\n * @param {Object} state\n * @param {Element} popper - the popper element\n * @param {Element} reference - the reference element (the popper will be relative to this)\n * @param {Element} fixedPosition - is in fixed position mode\n * @returns {Object} An object containing the offsets which will be applied to the popper\n */\nfunction getReferenceOffsets(state, popper, reference) {\n  var fixedPosition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  var commonOffsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, getReferenceNode(reference));\n  return getOffsetRectRelativeToArbitraryNode(reference, commonOffsetParent, fixedPosition);\n}\n\n/**\n * Get the outer sizes of the given element (offset size + margins)\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @returns {Object} object containing width and height properties\n */\nfunction getOuterSizes(element) {\n  var window = element.ownerDocument.defaultView;\n  var styles = window.getComputedStyle(element);\n  var x = parseFloat(styles.marginTop || 0) + parseFloat(styles.marginBottom || 0);\n  var y = parseFloat(styles.marginLeft || 0) + parseFloat(styles.marginRight || 0);\n  var result = {\n    width: element.offsetWidth + y,\n    height: element.offsetHeight + x\n  };\n  return result;\n}\n\n/**\n * Get the opposite placement of the given one\n * @method\n * @memberof Popper.Utils\n * @argument {String} placement\n * @returns {String} flipped placement\n */\nfunction getOppositePlacement(placement) {\n  var hash = {\n    left: 'right',\n    right: 'left',\n    bottom: 'top',\n    top: 'bottom'\n  };\n  return placement.replace(/left|right|bottom|top/g, function (matched) {\n    return hash[matched];\n  });\n}\n\n/**\n * Get offsets to the popper\n * @method\n * @memberof Popper.Utils\n * @param {Object} position - CSS position the Popper will get applied\n * @param {HTMLElement} popper - the popper element\n * @param {Object} referenceOffsets - the reference offsets (the popper will be relative to this)\n * @param {String} placement - one of the valid placement options\n * @returns {Object} popperOffsets - An object containing the offsets which will be applied to the popper\n */\nfunction getPopperOffsets(popper, referenceOffsets, placement) {\n  placement = placement.split('-')[0];\n\n  // Get popper node sizes\n  var popperRect = getOuterSizes(popper);\n\n  // Add position, width and height to our offsets object\n  var popperOffsets = {\n    width: popperRect.width,\n    height: popperRect.height\n  };\n\n  // depending by the popper placement we have to compute its offsets slightly differently\n  var isHoriz = ['right', 'left'].indexOf(placement) !== -1;\n  var mainSide = isHoriz ? 'top' : 'left';\n  var secondarySide = isHoriz ? 'left' : 'top';\n  var measurement = isHoriz ? 'height' : 'width';\n  var secondaryMeasurement = !isHoriz ? 'height' : 'width';\n  popperOffsets[mainSide] = referenceOffsets[mainSide] + referenceOffsets[measurement] / 2 - popperRect[measurement] / 2;\n  if (placement === secondarySide) {\n    popperOffsets[secondarySide] = referenceOffsets[secondarySide] - popperRect[secondaryMeasurement];\n  } else {\n    popperOffsets[secondarySide] = referenceOffsets[getOppositePlacement(secondarySide)];\n  }\n  return popperOffsets;\n}\n\n/**\n * Mimics the `find` method of Array\n * @method\n * @memberof Popper.Utils\n * @argument {Array} arr\n * @argument prop\n * @argument value\n * @returns index or -1\n */\nfunction find(arr, check) {\n  // use native find if supported\n  if (Array.prototype.find) {\n    return arr.find(check);\n  }\n\n  // use `filter` to obtain the same behavior of `find`\n  return arr.filter(check)[0];\n}\n\n/**\n * Return the index of the matching object\n * @method\n * @memberof Popper.Utils\n * @argument {Array} arr\n * @argument prop\n * @argument value\n * @returns index or -1\n */\nfunction findIndex(arr, prop, value) {\n  // use native findIndex if supported\n  if (Array.prototype.findIndex) {\n    return arr.findIndex(function (cur) {\n      return cur[prop] === value;\n    });\n  }\n\n  // use `find` + `indexOf` if `findIndex` isn't supported\n  var match = find(arr, function (obj) {\n    return obj[prop] === value;\n  });\n  return arr.indexOf(match);\n}\n\n/**\n * Loop trough the list of modifiers and run them in order,\n * each of them will then edit the data object.\n * @method\n * @memberof Popper.Utils\n * @param {dataObject} data\n * @param {Array} modifiers\n * @param {String} ends - Optional modifier name used as stopper\n * @returns {dataObject}\n */\nfunction runModifiers(modifiers, data, ends) {\n  var modifiersToRun = ends === undefined ? modifiers : modifiers.slice(0, findIndex(modifiers, 'name', ends));\n  modifiersToRun.forEach(function (modifier) {\n    if (modifier['function']) {\n      // eslint-disable-line dot-notation\n      console.warn('`modifier.function` is deprecated, use `modifier.fn`!');\n    }\n    var fn = modifier['function'] || modifier.fn; // eslint-disable-line dot-notation\n    if (modifier.enabled && isFunction(fn)) {\n      // Add properties to offsets to make them a complete clientRect object\n      // we do this before each modifier to make sure the previous one doesn't\n      // mess with these values\n      data.offsets.popper = getClientRect(data.offsets.popper);\n      data.offsets.reference = getClientRect(data.offsets.reference);\n      data = fn(data, modifier);\n    }\n  });\n  return data;\n}\n\n/**\n * Updates the position of the popper, computing the new offsets and applying\n * the new style.<br />\n * Prefer `scheduleUpdate` over `update` because of performance reasons.\n * @method\n * @memberof Popper\n */\nfunction update() {\n  // if popper is destroyed, don't perform any further update\n  if (this.state.isDestroyed) {\n    return;\n  }\n  var data = {\n    instance: this,\n    styles: {},\n    arrowStyles: {},\n    attributes: {},\n    flipped: false,\n    offsets: {}\n  };\n\n  // compute reference element offsets\n  data.offsets.reference = getReferenceOffsets(this.state, this.popper, this.reference, this.options.positionFixed);\n\n  // compute auto placement, store placement inside the data object,\n  // modifiers will be able to edit `placement` if needed\n  // and refer to originalPlacement to know the original value\n  data.placement = computeAutoPlacement(this.options.placement, data.offsets.reference, this.popper, this.reference, this.options.modifiers.flip.boundariesElement, this.options.modifiers.flip.padding);\n\n  // store the computed placement inside `originalPlacement`\n  data.originalPlacement = data.placement;\n  data.positionFixed = this.options.positionFixed;\n\n  // compute the popper offsets\n  data.offsets.popper = getPopperOffsets(this.popper, data.offsets.reference, data.placement);\n  data.offsets.popper.position = this.options.positionFixed ? 'fixed' : 'absolute';\n\n  // run the modifiers\n  data = runModifiers(this.modifiers, data);\n\n  // the first `update` will call `onCreate` callback\n  // the other ones will call `onUpdate` callback\n  if (!this.state.isCreated) {\n    this.state.isCreated = true;\n    this.options.onCreate(data);\n  } else {\n    this.options.onUpdate(data);\n  }\n}\n\n/**\n * Helper used to know if the given modifier is enabled.\n * @method\n * @memberof Popper.Utils\n * @returns {Boolean}\n */\nfunction isModifierEnabled(modifiers, modifierName) {\n  return modifiers.some(function (_ref) {\n    var name = _ref.name,\n      enabled = _ref.enabled;\n    return enabled && name === modifierName;\n  });\n}\n\n/**\n * Get the prefixed supported property name\n * @method\n * @memberof Popper.Utils\n * @argument {String} property (camelCase)\n * @returns {String} prefixed property (camelCase or PascalCase, depending on the vendor prefix)\n */\nfunction getSupportedPropertyName(property) {\n  var prefixes = [false, 'ms', 'Webkit', 'Moz', 'O'];\n  var upperProp = property.charAt(0).toUpperCase() + property.slice(1);\n  for (var i = 0; i < prefixes.length; i++) {\n    var prefix = prefixes[i];\n    var toCheck = prefix ? '' + prefix + upperProp : property;\n    if (typeof document.body.style[toCheck] !== 'undefined') {\n      return toCheck;\n    }\n  }\n  return null;\n}\n\n/**\n * Destroys the popper.\n * @method\n * @memberof Popper\n */\nfunction destroy() {\n  this.state.isDestroyed = true;\n\n  // touch DOM only if `applyStyle` modifier is enabled\n  if (isModifierEnabled(this.modifiers, 'applyStyle')) {\n    this.popper.removeAttribute('x-placement');\n    this.popper.style.position = '';\n    this.popper.style.top = '';\n    this.popper.style.left = '';\n    this.popper.style.right = '';\n    this.popper.style.bottom = '';\n    this.popper.style.willChange = '';\n    this.popper.style[getSupportedPropertyName('transform')] = '';\n  }\n  this.disableEventListeners();\n\n  // remove the popper if user explicitly asked for the deletion on destroy\n  // do not use `remove` because IE11 doesn't support it\n  if (this.options.removeOnDestroy) {\n    this.popper.parentNode.removeChild(this.popper);\n  }\n  return this;\n}\n\n/**\n * Get the window associated with the element\n * @argument {Element} element\n * @returns {Window}\n */\nfunction getWindow(element) {\n  var ownerDocument = element.ownerDocument;\n  return ownerDocument ? ownerDocument.defaultView : window;\n}\nfunction attachToScrollParents(scrollParent, event, callback, scrollParents) {\n  var isBody = scrollParent.nodeName === 'BODY';\n  var target = isBody ? scrollParent.ownerDocument.defaultView : scrollParent;\n  target.addEventListener(event, callback, {\n    passive: true\n  });\n  if (!isBody) {\n    attachToScrollParents(getScrollParent(target.parentNode), event, callback, scrollParents);\n  }\n  scrollParents.push(target);\n}\n\n/**\n * Setup needed event listeners used to update the popper position\n * @method\n * @memberof Popper.Utils\n * @private\n */\nfunction setupEventListeners(reference, options, state, updateBound) {\n  // Resize event listener on window\n  state.updateBound = updateBound;\n  getWindow(reference).addEventListener('resize', state.updateBound, {\n    passive: true\n  });\n\n  // Scroll event listener on scroll parents\n  var scrollElement = getScrollParent(reference);\n  attachToScrollParents(scrollElement, 'scroll', state.updateBound, state.scrollParents);\n  state.scrollElement = scrollElement;\n  state.eventsEnabled = true;\n  return state;\n}\n\n/**\n * It will add resize/scroll events and start recalculating\n * position of the popper element when they are triggered.\n * @method\n * @memberof Popper\n */\nfunction enableEventListeners() {\n  if (!this.state.eventsEnabled) {\n    this.state = setupEventListeners(this.reference, this.options, this.state, this.scheduleUpdate);\n  }\n}\n\n/**\n * Remove event listeners used to update the popper position\n * @method\n * @memberof Popper.Utils\n * @private\n */\nfunction removeEventListeners(reference, state) {\n  // Remove resize event listener on window\n  getWindow(reference).removeEventListener('resize', state.updateBound);\n\n  // Remove scroll event listener on scroll parents\n  state.scrollParents.forEach(function (target) {\n    target.removeEventListener('scroll', state.updateBound);\n  });\n\n  // Reset state\n  state.updateBound = null;\n  state.scrollParents = [];\n  state.scrollElement = null;\n  state.eventsEnabled = false;\n  return state;\n}\n\n/**\n * It will remove resize/scroll events and won't recalculate popper position\n * when they are triggered. It also won't trigger `onUpdate` callback anymore,\n * unless you call `update` method manually.\n * @method\n * @memberof Popper\n */\nfunction disableEventListeners() {\n  if (this.state.eventsEnabled) {\n    cancelAnimationFrame(this.scheduleUpdate);\n    this.state = removeEventListeners(this.reference, this.state);\n  }\n}\n\n/**\n * Tells if a given input is a number\n * @method\n * @memberof Popper.Utils\n * @param {*} input to check\n * @return {Boolean}\n */\nfunction isNumeric(n) {\n  return n !== '' && !isNaN(parseFloat(n)) && isFinite(n);\n}\n\n/**\n * Set the style to the given popper\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element - Element to apply the style to\n * @argument {Object} styles\n * Object with a list of properties and values which will be applied to the element\n */\nfunction setStyles(element, styles) {\n  Object.keys(styles).forEach(function (prop) {\n    var unit = '';\n    // add unit if the value is numeric and is one of the following\n    if (['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(prop) !== -1 && isNumeric(styles[prop])) {\n      unit = 'px';\n    }\n    element.style[prop] = styles[prop] + unit;\n  });\n}\n\n/**\n * Set the attributes to the given popper\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element - Element to apply the attributes to\n * @argument {Object} styles\n * Object with a list of properties and values which will be applied to the element\n */\nfunction setAttributes(element, attributes) {\n  Object.keys(attributes).forEach(function (prop) {\n    var value = attributes[prop];\n    if (value !== false) {\n      element.setAttribute(prop, attributes[prop]);\n    } else {\n      element.removeAttribute(prop);\n    }\n  });\n}\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by `update` method\n * @argument {Object} data.styles - List of style properties - values to apply to popper element\n * @argument {Object} data.attributes - List of attribute properties - values to apply to popper element\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The same data object\n */\nfunction applyStyle(data) {\n  // any property present in `data.styles` will be applied to the popper,\n  // in this way we can make the 3rd party modifiers add custom styles to it\n  // Be aware, modifiers could override the properties defined in the previous\n  // lines of this modifier!\n  setStyles(data.instance.popper, data.styles);\n\n  // any property present in `data.attributes` will be applied to the popper,\n  // they will be set as HTML attributes of the element\n  setAttributes(data.instance.popper, data.attributes);\n\n  // if arrowElement is defined and arrowStyles has some properties\n  if (data.arrowElement && Object.keys(data.arrowStyles).length) {\n    setStyles(data.arrowElement, data.arrowStyles);\n  }\n  return data;\n}\n\n/**\n * Set the x-placement attribute before everything else because it could be used\n * to add margins to the popper margins needs to be calculated to get the\n * correct popper offsets.\n * @method\n * @memberof Popper.modifiers\n * @param {HTMLElement} reference - The reference element used to position the popper\n * @param {HTMLElement} popper - The HTML element used as popper\n * @param {Object} options - Popper.js options\n */\nfunction applyStyleOnLoad(reference, popper, options, modifierOptions, state) {\n  // compute reference element offsets\n  var referenceOffsets = getReferenceOffsets(state, popper, reference, options.positionFixed);\n\n  // compute auto placement, store placement inside the data object,\n  // modifiers will be able to edit `placement` if needed\n  // and refer to originalPlacement to know the original value\n  var placement = computeAutoPlacement(options.placement, referenceOffsets, popper, reference, options.modifiers.flip.boundariesElement, options.modifiers.flip.padding);\n  popper.setAttribute('x-placement', placement);\n\n  // Apply `position` to popper before anything else because\n  // without the position applied we can't guarantee correct computations\n  setStyles(popper, {\n    position: options.positionFixed ? 'fixed' : 'absolute'\n  });\n  return options;\n}\n\n/**\n * @function\n * @memberof Popper.Utils\n * @argument {Object} data - The data object generated by `update` method\n * @argument {Boolean} shouldRound - If the offsets should be rounded at all\n * @returns {Object} The popper's position offsets rounded\n *\n * The tale of pixel-perfect positioning. It's still not 100% perfect, but as\n * good as it can be within reason.\n * Discussion here: https://github.com/FezVrasta/popper.js/pull/715\n *\n * Low DPI screens cause a popper to be blurry if not using full pixels (Safari\n * as well on High DPI screens).\n *\n * Firefox prefers no rounding for positioning and does not have blurriness on\n * high DPI screens.\n *\n * Only horizontal placement and left/right values need to be considered.\n */\nfunction getRoundedOffsets(data, shouldRound) {\n  var _data$offsets = data.offsets,\n    popper = _data$offsets.popper,\n    reference = _data$offsets.reference;\n  var round = Math.round,\n    floor = Math.floor;\n  var noRound = function noRound(v) {\n    return v;\n  };\n  var referenceWidth = round(reference.width);\n  var popperWidth = round(popper.width);\n  var isVertical = ['left', 'right'].indexOf(data.placement) !== -1;\n  var isVariation = data.placement.indexOf('-') !== -1;\n  var sameWidthParity = referenceWidth % 2 === popperWidth % 2;\n  var bothOddWidth = referenceWidth % 2 === 1 && popperWidth % 2 === 1;\n  var horizontalToInteger = !shouldRound ? noRound : isVertical || isVariation || sameWidthParity ? round : floor;\n  var verticalToInteger = !shouldRound ? noRound : round;\n  return {\n    left: horizontalToInteger(bothOddWidth && !isVariation && shouldRound ? popper.left - 1 : popper.left),\n    top: verticalToInteger(popper.top),\n    bottom: verticalToInteger(popper.bottom),\n    right: horizontalToInteger(popper.right)\n  };\n}\nvar isFirefox = isBrowser && /Firefox/i.test(navigator.userAgent);\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by `update` method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction computeStyle(data, options) {\n  var x = options.x,\n    y = options.y;\n  var popper = data.offsets.popper;\n\n  // Remove this legacy support in Popper.js v2\n\n  var legacyGpuAccelerationOption = find(data.instance.modifiers, function (modifier) {\n    return modifier.name === 'applyStyle';\n  }).gpuAcceleration;\n  if (legacyGpuAccelerationOption !== undefined) {\n    console.warn('WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!');\n  }\n  var gpuAcceleration = legacyGpuAccelerationOption !== undefined ? legacyGpuAccelerationOption : options.gpuAcceleration;\n  var offsetParent = getOffsetParent(data.instance.popper);\n  var offsetParentRect = getBoundingClientRect(offsetParent);\n\n  // Styles\n  var styles = {\n    position: popper.position\n  };\n  var offsets = getRoundedOffsets(data, window.devicePixelRatio < 2 || !isFirefox);\n  var sideA = x === 'bottom' ? 'top' : 'bottom';\n  var sideB = y === 'right' ? 'left' : 'right';\n\n  // if gpuAcceleration is set to `true` and transform is supported,\n  //  we use `translate3d` to apply the position to the popper we\n  // automatically use the supported prefixed version if needed\n  var prefixedProperty = getSupportedPropertyName('transform');\n\n  // now, let's make a step back and look at this code closely (wtf?)\n  // If the content of the popper grows once it's been positioned, it\n  // may happen that the popper gets misplaced because of the new content\n  // overflowing its reference element\n  // To avoid this problem, we provide two options (x and y), which allow\n  // the consumer to define the offset origin.\n  // If we position a popper on top of a reference element, we can set\n  // `x` to `top` to make the popper grow towards its top instead of\n  // its bottom.\n  var left = void 0,\n    top = void 0;\n  if (sideA === 'bottom') {\n    // when offsetParent is <html> the positioning is relative to the bottom of the screen (excluding the scrollbar)\n    // and not the bottom of the html element\n    if (offsetParent.nodeName === 'HTML') {\n      top = -offsetParent.clientHeight + offsets.bottom;\n    } else {\n      top = -offsetParentRect.height + offsets.bottom;\n    }\n  } else {\n    top = offsets.top;\n  }\n  if (sideB === 'right') {\n    if (offsetParent.nodeName === 'HTML') {\n      left = -offsetParent.clientWidth + offsets.right;\n    } else {\n      left = -offsetParentRect.width + offsets.right;\n    }\n  } else {\n    left = offsets.left;\n  }\n  if (gpuAcceleration && prefixedProperty) {\n    styles[prefixedProperty] = 'translate3d(' + left + 'px, ' + top + 'px, 0)';\n    styles[sideA] = 0;\n    styles[sideB] = 0;\n    styles.willChange = 'transform';\n  } else {\n    // othwerise, we use the standard `top`, `left`, `bottom` and `right` properties\n    var invertTop = sideA === 'bottom' ? -1 : 1;\n    var invertLeft = sideB === 'right' ? -1 : 1;\n    styles[sideA] = top * invertTop;\n    styles[sideB] = left * invertLeft;\n    styles.willChange = sideA + ', ' + sideB;\n  }\n\n  // Attributes\n  var attributes = {\n    'x-placement': data.placement\n  };\n\n  // Update `data` attributes, styles and arrowStyles\n  data.attributes = _extends({}, attributes, data.attributes);\n  data.styles = _extends({}, styles, data.styles);\n  data.arrowStyles = _extends({}, data.offsets.arrow, data.arrowStyles);\n  return data;\n}\n\n/**\n * Helper used to know if the given modifier depends from another one.<br />\n * It checks if the needed modifier is listed and enabled.\n * @method\n * @memberof Popper.Utils\n * @param {Array} modifiers - list of modifiers\n * @param {String} requestingName - name of requesting modifier\n * @param {String} requestedName - name of requested modifier\n * @returns {Boolean}\n */\nfunction isModifierRequired(modifiers, requestingName, requestedName) {\n  var requesting = find(modifiers, function (_ref) {\n    var name = _ref.name;\n    return name === requestingName;\n  });\n  var isRequired = !!requesting && modifiers.some(function (modifier) {\n    return modifier.name === requestedName && modifier.enabled && modifier.order < requesting.order;\n  });\n  if (!isRequired) {\n    var _requesting = '`' + requestingName + '`';\n    var requested = '`' + requestedName + '`';\n    console.warn(requested + ' modifier is required by ' + _requesting + ' modifier in order to work, be sure to include it before ' + _requesting + '!');\n  }\n  return isRequired;\n}\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by update method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction arrow(data, options) {\n  var _data$offsets$arrow;\n\n  // arrow depends on keepTogether in order to work\n  if (!isModifierRequired(data.instance.modifiers, 'arrow', 'keepTogether')) {\n    return data;\n  }\n  var arrowElement = options.element;\n\n  // if arrowElement is a string, suppose it's a CSS selector\n  if (typeof arrowElement === 'string') {\n    arrowElement = data.instance.popper.querySelector(arrowElement);\n\n    // if arrowElement is not found, don't run the modifier\n    if (!arrowElement) {\n      return data;\n    }\n  } else {\n    // if the arrowElement isn't a query selector we must check that the\n    // provided DOM node is child of its popper node\n    if (!data.instance.popper.contains(arrowElement)) {\n      console.warn('WARNING: `arrow.element` must be child of its popper element!');\n      return data;\n    }\n  }\n  var placement = data.placement.split('-')[0];\n  var _data$offsets = data.offsets,\n    popper = _data$offsets.popper,\n    reference = _data$offsets.reference;\n  var isVertical = ['left', 'right'].indexOf(placement) !== -1;\n  var len = isVertical ? 'height' : 'width';\n  var sideCapitalized = isVertical ? 'Top' : 'Left';\n  var side = sideCapitalized.toLowerCase();\n  var altSide = isVertical ? 'left' : 'top';\n  var opSide = isVertical ? 'bottom' : 'right';\n  var arrowElementSize = getOuterSizes(arrowElement)[len];\n\n  //\n  // extends keepTogether behavior making sure the popper and its\n  // reference have enough pixels in conjunction\n  //\n\n  // top/left side\n  if (reference[opSide] - arrowElementSize < popper[side]) {\n    data.offsets.popper[side] -= popper[side] - (reference[opSide] - arrowElementSize);\n  }\n  // bottom/right side\n  if (reference[side] + arrowElementSize > popper[opSide]) {\n    data.offsets.popper[side] += reference[side] + arrowElementSize - popper[opSide];\n  }\n  data.offsets.popper = getClientRect(data.offsets.popper);\n\n  // compute center of the popper\n  var center = reference[side] + reference[len] / 2 - arrowElementSize / 2;\n\n  // Compute the sideValue using the updated popper offsets\n  // take popper margin in account because we don't have this info available\n  var css = getStyleComputedProperty(data.instance.popper);\n  var popperMarginSide = parseFloat(css['margin' + sideCapitalized]);\n  var popperBorderSide = parseFloat(css['border' + sideCapitalized + 'Width']);\n  var sideValue = center - data.offsets.popper[side] - popperMarginSide - popperBorderSide;\n\n  // prevent arrowElement from being placed not contiguously to its popper\n  sideValue = Math.max(Math.min(popper[len] - arrowElementSize, sideValue), 0);\n  data.arrowElement = arrowElement;\n  data.offsets.arrow = (_data$offsets$arrow = {}, defineProperty(_data$offsets$arrow, side, Math.round(sideValue)), defineProperty(_data$offsets$arrow, altSide, ''), _data$offsets$arrow);\n  return data;\n}\n\n/**\n * Get the opposite placement variation of the given one\n * @method\n * @memberof Popper.Utils\n * @argument {String} placement variation\n * @returns {String} flipped placement variation\n */\nfunction getOppositeVariation(variation) {\n  if (variation === 'end') {\n    return 'start';\n  } else if (variation === 'start') {\n    return 'end';\n  }\n  return variation;\n}\n\n/**\n * List of accepted placements to use as values of the `placement` option.<br />\n * Valid placements are:\n * - `auto`\n * - `top`\n * - `right`\n * - `bottom`\n * - `left`\n *\n * Each placement can have a variation from this list:\n * - `-start`\n * - `-end`\n *\n * Variations are interpreted easily if you think of them as the left to right\n * written languages. Horizontally (`top` and `bottom`), `start` is left and `end`\n * is right.<br />\n * Vertically (`left` and `right`), `start` is top and `end` is bottom.\n *\n * Some valid examples are:\n * - `top-end` (on top of reference, right aligned)\n * - `right-start` (on right of reference, top aligned)\n * - `bottom` (on bottom, centered)\n * - `auto-end` (on the side with more space available, alignment depends by placement)\n *\n * @static\n * @type {Array}\n * @enum {String}\n * @readonly\n * @method placements\n * @memberof Popper\n */\nvar placements = ['auto-start', 'auto', 'auto-end', 'top-start', 'top', 'top-end', 'right-start', 'right', 'right-end', 'bottom-end', 'bottom', 'bottom-start', 'left-end', 'left', 'left-start'];\n\n// Get rid of `auto` `auto-start` and `auto-end`\nvar validPlacements = placements.slice(3);\n\n/**\n * Given an initial placement, returns all the subsequent placements\n * clockwise (or counter-clockwise).\n *\n * @method\n * @memberof Popper.Utils\n * @argument {String} placement - A valid placement (it accepts variations)\n * @argument {Boolean} counter - Set to true to walk the placements counterclockwise\n * @returns {Array} placements including their variations\n */\nfunction clockwise(placement) {\n  var counter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  var index = validPlacements.indexOf(placement);\n  var arr = validPlacements.slice(index + 1).concat(validPlacements.slice(0, index));\n  return counter ? arr.reverse() : arr;\n}\nvar BEHAVIORS = {\n  FLIP: 'flip',\n  CLOCKWISE: 'clockwise',\n  COUNTERCLOCKWISE: 'counterclockwise'\n};\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by update method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction flip(data, options) {\n  // if `inner` modifier is enabled, we can't use the `flip` modifier\n  if (isModifierEnabled(data.instance.modifiers, 'inner')) {\n    return data;\n  }\n  if (data.flipped && data.placement === data.originalPlacement) {\n    // seems like flip is trying to loop, probably there's not enough space on any of the flippable sides\n    return data;\n  }\n  var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, options.boundariesElement, data.positionFixed);\n  var placement = data.placement.split('-')[0];\n  var placementOpposite = getOppositePlacement(placement);\n  var variation = data.placement.split('-')[1] || '';\n  var flipOrder = [];\n  switch (options.behavior) {\n    case BEHAVIORS.FLIP:\n      flipOrder = [placement, placementOpposite];\n      break;\n    case BEHAVIORS.CLOCKWISE:\n      flipOrder = clockwise(placement);\n      break;\n    case BEHAVIORS.COUNTERCLOCKWISE:\n      flipOrder = clockwise(placement, true);\n      break;\n    default:\n      flipOrder = options.behavior;\n  }\n  flipOrder.forEach(function (step, index) {\n    if (placement !== step || flipOrder.length === index + 1) {\n      return data;\n    }\n    placement = data.placement.split('-')[0];\n    placementOpposite = getOppositePlacement(placement);\n    var popperOffsets = data.offsets.popper;\n    var refOffsets = data.offsets.reference;\n\n    // using floor because the reference offsets may contain decimals we are not going to consider here\n    var floor = Math.floor;\n    var overlapsRef = placement === 'left' && floor(popperOffsets.right) > floor(refOffsets.left) || placement === 'right' && floor(popperOffsets.left) < floor(refOffsets.right) || placement === 'top' && floor(popperOffsets.bottom) > floor(refOffsets.top) || placement === 'bottom' && floor(popperOffsets.top) < floor(refOffsets.bottom);\n    var overflowsLeft = floor(popperOffsets.left) < floor(boundaries.left);\n    var overflowsRight = floor(popperOffsets.right) > floor(boundaries.right);\n    var overflowsTop = floor(popperOffsets.top) < floor(boundaries.top);\n    var overflowsBottom = floor(popperOffsets.bottom) > floor(boundaries.bottom);\n    var overflowsBoundaries = placement === 'left' && overflowsLeft || placement === 'right' && overflowsRight || placement === 'top' && overflowsTop || placement === 'bottom' && overflowsBottom;\n\n    // flip the variation if required\n    var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;\n\n    // flips variation if reference element overflows boundaries\n    var flippedVariationByRef = !!options.flipVariations && (isVertical && variation === 'start' && overflowsLeft || isVertical && variation === 'end' && overflowsRight || !isVertical && variation === 'start' && overflowsTop || !isVertical && variation === 'end' && overflowsBottom);\n\n    // flips variation if popper content overflows boundaries\n    var flippedVariationByContent = !!options.flipVariationsByContent && (isVertical && variation === 'start' && overflowsRight || isVertical && variation === 'end' && overflowsLeft || !isVertical && variation === 'start' && overflowsBottom || !isVertical && variation === 'end' && overflowsTop);\n    var flippedVariation = flippedVariationByRef || flippedVariationByContent;\n    if (overlapsRef || overflowsBoundaries || flippedVariation) {\n      // this boolean to detect any flip loop\n      data.flipped = true;\n      if (overlapsRef || overflowsBoundaries) {\n        placement = flipOrder[index + 1];\n      }\n      if (flippedVariation) {\n        variation = getOppositeVariation(variation);\n      }\n      data.placement = placement + (variation ? '-' + variation : '');\n\n      // this object contains `position`, we want to preserve it along with\n      // any additional property we may add in the future\n      data.offsets.popper = _extends({}, data.offsets.popper, getPopperOffsets(data.instance.popper, data.offsets.reference, data.placement));\n      data = runModifiers(data.instance.modifiers, data, 'flip');\n    }\n  });\n  return data;\n}\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by update method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction keepTogether(data) {\n  var _data$offsets = data.offsets,\n    popper = _data$offsets.popper,\n    reference = _data$offsets.reference;\n  var placement = data.placement.split('-')[0];\n  var floor = Math.floor;\n  var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;\n  var side = isVertical ? 'right' : 'bottom';\n  var opSide = isVertical ? 'left' : 'top';\n  var measurement = isVertical ? 'width' : 'height';\n  if (popper[side] < floor(reference[opSide])) {\n    data.offsets.popper[opSide] = floor(reference[opSide]) - popper[measurement];\n  }\n  if (popper[opSide] > floor(reference[side])) {\n    data.offsets.popper[opSide] = floor(reference[side]);\n  }\n  return data;\n}\n\n/**\n * Converts a string containing value + unit into a px value number\n * @function\n * @memberof {modifiers~offset}\n * @private\n * @argument {String} str - Value + unit string\n * @argument {String} measurement - `height` or `width`\n * @argument {Object} popperOffsets\n * @argument {Object} referenceOffsets\n * @returns {Number|String}\n * Value in pixels, or original string if no values were extracted\n */\nfunction toValue(str, measurement, popperOffsets, referenceOffsets) {\n  // separate value from unit\n  var split = str.match(/((?:\\-|\\+)?\\d*\\.?\\d*)(.*)/);\n  var value = +split[1];\n  var unit = split[2];\n\n  // If it's not a number it's an operator, I guess\n  if (!value) {\n    return str;\n  }\n  if (unit.indexOf('%') === 0) {\n    var element = void 0;\n    switch (unit) {\n      case '%p':\n        element = popperOffsets;\n        break;\n      case '%':\n      case '%r':\n      default:\n        element = referenceOffsets;\n    }\n    var rect = getClientRect(element);\n    return rect[measurement] / 100 * value;\n  } else if (unit === 'vh' || unit === 'vw') {\n    // if is a vh or vw, we calculate the size based on the viewport\n    var size = void 0;\n    if (unit === 'vh') {\n      size = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);\n    } else {\n      size = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);\n    }\n    return size / 100 * value;\n  } else {\n    // if is an explicit pixel unit, we get rid of the unit and keep the value\n    // if is an implicit unit, it's px, and we return just the value\n    return value;\n  }\n}\n\n/**\n * Parse an `offset` string to extrapolate `x` and `y` numeric offsets.\n * @function\n * @memberof {modifiers~offset}\n * @private\n * @argument {String} offset\n * @argument {Object} popperOffsets\n * @argument {Object} referenceOffsets\n * @argument {String} basePlacement\n * @returns {Array} a two cells array with x and y offsets in numbers\n */\nfunction parseOffset(offset, popperOffsets, referenceOffsets, basePlacement) {\n  var offsets = [0, 0];\n\n  // Use height if placement is left or right and index is 0 otherwise use width\n  // in this way the first offset will use an axis and the second one\n  // will use the other one\n  var useHeight = ['right', 'left'].indexOf(basePlacement) !== -1;\n\n  // Split the offset string to obtain a list of values and operands\n  // The regex addresses values with the plus or minus sign in front (+10, -20, etc)\n  var fragments = offset.split(/(\\+|\\-)/).map(function (frag) {\n    return frag.trim();\n  });\n\n  // Detect if the offset string contains a pair of values or a single one\n  // they could be separated by comma or space\n  var divider = fragments.indexOf(find(fragments, function (frag) {\n    return frag.search(/,|\\s/) !== -1;\n  }));\n  if (fragments[divider] && fragments[divider].indexOf(',') === -1) {\n    console.warn('Offsets separated by white space(s) are deprecated, use a comma (,) instead.');\n  }\n\n  // If divider is found, we divide the list of values and operands to divide\n  // them by ofset X and Y.\n  var splitRegex = /\\s*,\\s*|\\s+/;\n  var ops = divider !== -1 ? [fragments.slice(0, divider).concat([fragments[divider].split(splitRegex)[0]]), [fragments[divider].split(splitRegex)[1]].concat(fragments.slice(divider + 1))] : [fragments];\n\n  // Convert the values with units to absolute pixels to allow our computations\n  ops = ops.map(function (op, index) {\n    // Most of the units rely on the orientation of the popper\n    var measurement = (index === 1 ? !useHeight : useHeight) ? 'height' : 'width';\n    var mergeWithPrevious = false;\n    return op\n    // This aggregates any `+` or `-` sign that aren't considered operators\n    // e.g.: 10 + +5 => [10, +, +5]\n    .reduce(function (a, b) {\n      if (a[a.length - 1] === '' && ['+', '-'].indexOf(b) !== -1) {\n        a[a.length - 1] = b;\n        mergeWithPrevious = true;\n        return a;\n      } else if (mergeWithPrevious) {\n        a[a.length - 1] += b;\n        mergeWithPrevious = false;\n        return a;\n      } else {\n        return a.concat(b);\n      }\n    }, [])\n    // Here we convert the string values into number values (in px)\n    .map(function (str) {\n      return toValue(str, measurement, popperOffsets, referenceOffsets);\n    });\n  });\n\n  // Loop trough the offsets arrays and execute the operations\n  ops.forEach(function (op, index) {\n    op.forEach(function (frag, index2) {\n      if (isNumeric(frag)) {\n        offsets[index] += frag * (op[index2 - 1] === '-' ? -1 : 1);\n      }\n    });\n  });\n  return offsets;\n}\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by update method\n * @argument {Object} options - Modifiers configuration and options\n * @argument {Number|String} options.offset=0\n * The offset value as described in the modifier description\n * @returns {Object} The data object, properly modified\n */\nfunction offset(data, _ref) {\n  var offset = _ref.offset;\n  var placement = data.placement,\n    _data$offsets = data.offsets,\n    popper = _data$offsets.popper,\n    reference = _data$offsets.reference;\n  var basePlacement = placement.split('-')[0];\n  var offsets = void 0;\n  if (isNumeric(+offset)) {\n    offsets = [+offset, 0];\n  } else {\n    offsets = parseOffset(offset, popper, reference, basePlacement);\n  }\n  if (basePlacement === 'left') {\n    popper.top += offsets[0];\n    popper.left -= offsets[1];\n  } else if (basePlacement === 'right') {\n    popper.top += offsets[0];\n    popper.left += offsets[1];\n  } else if (basePlacement === 'top') {\n    popper.left += offsets[0];\n    popper.top -= offsets[1];\n  } else if (basePlacement === 'bottom') {\n    popper.left += offsets[0];\n    popper.top += offsets[1];\n  }\n  data.popper = popper;\n  return data;\n}\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by `update` method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction preventOverflow(data, options) {\n  var boundariesElement = options.boundariesElement || getOffsetParent(data.instance.popper);\n\n  // If offsetParent is the reference element, we really want to\n  // go one step up and use the next offsetParent as reference to\n  // avoid to make this modifier completely useless and look like broken\n  if (data.instance.reference === boundariesElement) {\n    boundariesElement = getOffsetParent(boundariesElement);\n  }\n\n  // NOTE: DOM access here\n  // resets the popper's position so that the document size can be calculated excluding\n  // the size of the popper element itself\n  var transformProp = getSupportedPropertyName('transform');\n  var popperStyles = data.instance.popper.style; // assignment to help minification\n  var top = popperStyles.top,\n    left = popperStyles.left,\n    transform = popperStyles[transformProp];\n  popperStyles.top = '';\n  popperStyles.left = '';\n  popperStyles[transformProp] = '';\n  var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, boundariesElement, data.positionFixed);\n\n  // NOTE: DOM access here\n  // restores the original style properties after the offsets have been computed\n  popperStyles.top = top;\n  popperStyles.left = left;\n  popperStyles[transformProp] = transform;\n  options.boundaries = boundaries;\n  var order = options.priority;\n  var popper = data.offsets.popper;\n  var check = {\n    primary: function primary(placement) {\n      var value = popper[placement];\n      if (popper[placement] < boundaries[placement] && !options.escapeWithReference) {\n        value = Math.max(popper[placement], boundaries[placement]);\n      }\n      return defineProperty({}, placement, value);\n    },\n    secondary: function secondary(placement) {\n      var mainSide = placement === 'right' ? 'left' : 'top';\n      var value = popper[mainSide];\n      if (popper[placement] > boundaries[placement] && !options.escapeWithReference) {\n        value = Math.min(popper[mainSide], boundaries[placement] - (placement === 'right' ? popper.width : popper.height));\n      }\n      return defineProperty({}, mainSide, value);\n    }\n  };\n  order.forEach(function (placement) {\n    var side = ['left', 'top'].indexOf(placement) !== -1 ? 'primary' : 'secondary';\n    popper = _extends({}, popper, check[side](placement));\n  });\n  data.offsets.popper = popper;\n  return data;\n}\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by `update` method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction shift(data) {\n  var placement = data.placement;\n  var basePlacement = placement.split('-')[0];\n  var shiftvariation = placement.split('-')[1];\n\n  // if shift shiftvariation is specified, run the modifier\n  if (shiftvariation) {\n    var _data$offsets = data.offsets,\n      reference = _data$offsets.reference,\n      popper = _data$offsets.popper;\n    var isVertical = ['bottom', 'top'].indexOf(basePlacement) !== -1;\n    var side = isVertical ? 'left' : 'top';\n    var measurement = isVertical ? 'width' : 'height';\n    var shiftOffsets = {\n      start: defineProperty({}, side, reference[side]),\n      end: defineProperty({}, side, reference[side] + reference[measurement] - popper[measurement])\n    };\n    data.offsets.popper = _extends({}, popper, shiftOffsets[shiftvariation]);\n  }\n  return data;\n}\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by update method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction hide(data) {\n  if (!isModifierRequired(data.instance.modifiers, 'hide', 'preventOverflow')) {\n    return data;\n  }\n  var refRect = data.offsets.reference;\n  var bound = find(data.instance.modifiers, function (modifier) {\n    return modifier.name === 'preventOverflow';\n  }).boundaries;\n  if (refRect.bottom < bound.top || refRect.left > bound.right || refRect.top > bound.bottom || refRect.right < bound.left) {\n    // Avoid unnecessary DOM access if visibility hasn't changed\n    if (data.hide === true) {\n      return data;\n    }\n    data.hide = true;\n    data.attributes['x-out-of-boundaries'] = '';\n  } else {\n    // Avoid unnecessary DOM access if visibility hasn't changed\n    if (data.hide === false) {\n      return data;\n    }\n    data.hide = false;\n    data.attributes['x-out-of-boundaries'] = false;\n  }\n  return data;\n}\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by `update` method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction inner(data) {\n  var placement = data.placement;\n  var basePlacement = placement.split('-')[0];\n  var _data$offsets = data.offsets,\n    popper = _data$offsets.popper,\n    reference = _data$offsets.reference;\n  var isHoriz = ['left', 'right'].indexOf(basePlacement) !== -1;\n  var subtractLength = ['top', 'left'].indexOf(basePlacement) === -1;\n  popper[isHoriz ? 'left' : 'top'] = reference[basePlacement] - (subtractLength ? popper[isHoriz ? 'width' : 'height'] : 0);\n  data.placement = getOppositePlacement(placement);\n  data.offsets.popper = getClientRect(popper);\n  return data;\n}\n\n/**\n * Modifier function, each modifier can have a function of this type assigned\n * to its `fn` property.<br />\n * These functions will be called on each update, this means that you must\n * make sure they are performant enough to avoid performance bottlenecks.\n *\n * @function ModifierFn\n * @argument {dataObject} data - The data object generated by `update` method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {dataObject} The data object, properly modified\n */\n\n/**\n * Modifiers are plugins used to alter the behavior of your poppers.<br />\n * Popper.js uses a set of 9 modifiers to provide all the basic functionalities\n * needed by the library.\n *\n * Usually you don't want to override the `order`, `fn` and `onLoad` props.\n * All the other properties are configurations that could be tweaked.\n * @namespace modifiers\n */\nvar modifiers = {\n  /**\n   * Modifier used to shift the popper on the start or end of its reference\n   * element.<br />\n   * It will read the variation of the `placement` property.<br />\n   * It can be one either `-end` or `-start`.\n   * @memberof modifiers\n   * @inner\n   */\n  shift: {\n    /** @prop {number} order=100 - Index used to define the order of execution */\n    order: 100,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: shift\n  },\n  /**\n   * The `offset` modifier can shift your popper on both its axis.\n   *\n   * It accepts the following units:\n   * - `px` or unit-less, interpreted as pixels\n   * - `%` or `%r`, percentage relative to the length of the reference element\n   * - `%p`, percentage relative to the length of the popper element\n   * - `vw`, CSS viewport width unit\n   * - `vh`, CSS viewport height unit\n   *\n   * For length is intended the main axis relative to the placement of the popper.<br />\n   * This means that if the placement is `top` or `bottom`, the length will be the\n   * `width`. In case of `left` or `right`, it will be the `height`.\n   *\n   * You can provide a single value (as `Number` or `String`), or a pair of values\n   * as `String` divided by a comma or one (or more) white spaces.<br />\n   * The latter is a deprecated method because it leads to confusion and will be\n   * removed in v2.<br />\n   * Additionally, it accepts additions and subtractions between different units.\n   * Note that multiplications and divisions aren't supported.\n   *\n   * Valid examples are:\n   * ```\n   * 10\n   * '10%'\n   * '10, 10'\n   * '10%, 10'\n   * '10 + 10%'\n   * '10 - 5vh + 3%'\n   * '-10px + 5vh, 5px - 6%'\n   * ```\n   * > **NB**: If you desire to apply offsets to your poppers in a way that may make them overlap\n   * > with their reference element, unfortunately, you will have to disable the `flip` modifier.\n   * > You can read more on this at this [issue](https://github.com/FezVrasta/popper.js/issues/373).\n   *\n   * @memberof modifiers\n   * @inner\n   */\n  offset: {\n    /** @prop {number} order=200 - Index used to define the order of execution */\n    order: 200,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: offset,\n    /** @prop {Number|String} offset=0\n     * The offset value as described in the modifier description\n     */\n    offset: 0\n  },\n  /**\n   * Modifier used to prevent the popper from being positioned outside the boundary.\n   *\n   * A scenario exists where the reference itself is not within the boundaries.<br />\n   * We can say it has \"escaped the boundaries\"  or just \"escaped\".<br />\n   * In this case we need to decide whether the popper should either:\n   *\n   * - detach from the reference and remain \"trapped\" in the boundaries, or\n   * - if it should ignore the boundary and \"escape with its reference\"\n   *\n   * When `escapeWithReference` is set to`true` and reference is completely\n   * outside its boundaries, the popper will overflow (or completely leave)\n   * the boundaries in order to remain attached to the edge of the reference.\n   *\n   * @memberof modifiers\n   * @inner\n   */\n  preventOverflow: {\n    /** @prop {number} order=300 - Index used to define the order of execution */\n    order: 300,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: preventOverflow,\n    /**\n     * @prop {Array} [priority=['left','right','top','bottom']]\n     * Popper will try to prevent overflow following these priorities by default,\n     * then, it could overflow on the left and on top of the `boundariesElement`\n     */\n    priority: ['left', 'right', 'top', 'bottom'],\n    /**\n     * @prop {number} padding=5\n     * Amount of pixel used to define a minimum distance between the boundaries\n     * and the popper. This makes sure the popper always has a little padding\n     * between the edges of its container\n     */\n    padding: 5,\n    /**\n     * @prop {String|HTMLElement} boundariesElement='scrollParent'\n     * Boundaries used by the modifier. Can be `scrollParent`, `window`,\n     * `viewport` or any DOM element.\n     */\n    boundariesElement: 'scrollParent'\n  },\n  /**\n   * Modifier used to make sure the reference and its popper stay near each other\n   * without leaving any gap between the two. Especially useful when the arrow is\n   * enabled and you want to ensure that it points to its reference element.\n   * It cares only about the first axis. You can still have poppers with margin\n   * between the popper and its reference element.\n   * @memberof modifiers\n   * @inner\n   */\n  keepTogether: {\n    /** @prop {number} order=400 - Index used to define the order of execution */\n    order: 400,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: keepTogether\n  },\n  /**\n   * This modifier is used to move the `arrowElement` of the popper to make\n   * sure it is positioned between the reference element and its popper element.\n   * It will read the outer size of the `arrowElement` node to detect how many\n   * pixels of conjunction are needed.\n   *\n   * It has no effect if no `arrowElement` is provided.\n   * @memberof modifiers\n   * @inner\n   */\n  arrow: {\n    /** @prop {number} order=500 - Index used to define the order of execution */\n    order: 500,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: arrow,\n    /** @prop {String|HTMLElement} element='[x-arrow]' - Selector or node used as arrow */\n    element: '[x-arrow]'\n  },\n  /**\n   * Modifier used to flip the popper's placement when it starts to overlap its\n   * reference element.\n   *\n   * Requires the `preventOverflow` modifier before it in order to work.\n   *\n   * **NOTE:** this modifier will interrupt the current update cycle and will\n   * restart it if it detects the need to flip the placement.\n   * @memberof modifiers\n   * @inner\n   */\n  flip: {\n    /** @prop {number} order=600 - Index used to define the order of execution */\n    order: 600,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: flip,\n    /**\n     * @prop {String|Array} behavior='flip'\n     * The behavior used to change the popper's placement. It can be one of\n     * `flip`, `clockwise`, `counterclockwise` or an array with a list of valid\n     * placements (with optional variations)\n     */\n    behavior: 'flip',\n    /**\n     * @prop {number} padding=5\n     * The popper will flip if it hits the edges of the `boundariesElement`\n     */\n    padding: 5,\n    /**\n     * @prop {String|HTMLElement} boundariesElement='viewport'\n     * The element which will define the boundaries of the popper position.\n     * The popper will never be placed outside of the defined boundaries\n     * (except if `keepTogether` is enabled)\n     */\n    boundariesElement: 'viewport',\n    /**\n     * @prop {Boolean} flipVariations=false\n     * The popper will switch placement variation between `-start` and `-end` when\n     * the reference element overlaps its boundaries.\n     *\n     * The original placement should have a set variation.\n     */\n    flipVariations: false,\n    /**\n     * @prop {Boolean} flipVariationsByContent=false\n     * The popper will switch placement variation between `-start` and `-end` when\n     * the popper element overlaps its reference boundaries.\n     *\n     * The original placement should have a set variation.\n     */\n    flipVariationsByContent: false\n  },\n  /**\n   * Modifier used to make the popper flow toward the inner of the reference element.\n   * By default, when this modifier is disabled, the popper will be placed outside\n   * the reference element.\n   * @memberof modifiers\n   * @inner\n   */\n  inner: {\n    /** @prop {number} order=700 - Index used to define the order of execution */\n    order: 700,\n    /** @prop {Boolean} enabled=false - Whether the modifier is enabled or not */\n    enabled: false,\n    /** @prop {ModifierFn} */\n    fn: inner\n  },\n  /**\n   * Modifier used to hide the popper when its reference element is outside of the\n   * popper boundaries. It will set a `x-out-of-boundaries` attribute which can\n   * be used to hide with a CSS selector the popper when its reference is\n   * out of boundaries.\n   *\n   * Requires the `preventOverflow` modifier before it in order to work.\n   * @memberof modifiers\n   * @inner\n   */\n  hide: {\n    /** @prop {number} order=800 - Index used to define the order of execution */\n    order: 800,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: hide\n  },\n  /**\n   * Computes the style that will be applied to the popper element to gets\n   * properly positioned.\n   *\n   * Note that this modifier will not touch the DOM, it just prepares the styles\n   * so that `applyStyle` modifier can apply it. This separation is useful\n   * in case you need to replace `applyStyle` with a custom implementation.\n   *\n   * This modifier has `850` as `order` value to maintain backward compatibility\n   * with previous versions of Popper.js. Expect the modifiers ordering method\n   * to change in future major versions of the library.\n   *\n   * @memberof modifiers\n   * @inner\n   */\n  computeStyle: {\n    /** @prop {number} order=850 - Index used to define the order of execution */\n    order: 850,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: computeStyle,\n    /**\n     * @prop {Boolean} gpuAcceleration=true\n     * If true, it uses the CSS 3D transformation to position the popper.\n     * Otherwise, it will use the `top` and `left` properties\n     */\n    gpuAcceleration: true,\n    /**\n     * @prop {string} [x='bottom']\n     * Where to anchor the X axis (`bottom` or `top`). AKA X offset origin.\n     * Change this if your popper should grow in a direction different from `bottom`\n     */\n    x: 'bottom',\n    /**\n     * @prop {string} [x='left']\n     * Where to anchor the Y axis (`left` or `right`). AKA Y offset origin.\n     * Change this if your popper should grow in a direction different from `right`\n     */\n    y: 'right'\n  },\n  /**\n   * Applies the computed styles to the popper element.\n   *\n   * All the DOM manipulations are limited to this modifier. This is useful in case\n   * you want to integrate Popper.js inside a framework or view library and you\n   * want to delegate all the DOM manipulations to it.\n   *\n   * Note that if you disable this modifier, you must make sure the popper element\n   * has its position set to `absolute` before Popper.js can do its work!\n   *\n   * Just disable this modifier and define your own to achieve the desired effect.\n   *\n   * @memberof modifiers\n   * @inner\n   */\n  applyStyle: {\n    /** @prop {number} order=900 - Index used to define the order of execution */\n    order: 900,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: applyStyle,\n    /** @prop {Function} */\n    onLoad: applyStyleOnLoad,\n    /**\n     * @deprecated since version 1.10.0, the property moved to `computeStyle` modifier\n     * @prop {Boolean} gpuAcceleration=true\n     * If true, it uses the CSS 3D transformation to position the popper.\n     * Otherwise, it will use the `top` and `left` properties\n     */\n    gpuAcceleration: undefined\n  }\n};\n\n/**\n * The `dataObject` is an object containing all the information used by Popper.js.\n * This object is passed to modifiers and to the `onCreate` and `onUpdate` callbacks.\n * @name dataObject\n * @property {Object} data.instance The Popper.js instance\n * @property {String} data.placement Placement applied to popper\n * @property {String} data.originalPlacement Placement originally defined on init\n * @property {Boolean} data.flipped True if popper has been flipped by flip modifier\n * @property {Boolean} data.hide True if the reference element is out of boundaries, useful to know when to hide the popper\n * @property {HTMLElement} data.arrowElement Node used as arrow by arrow modifier\n * @property {Object} data.styles Any CSS property defined here will be applied to the popper. It expects the JavaScript nomenclature (eg. `marginBottom`)\n * @property {Object} data.arrowStyles Any CSS property defined here will be applied to the popper arrow. It expects the JavaScript nomenclature (eg. `marginBottom`)\n * @property {Object} data.boundaries Offsets of the popper boundaries\n * @property {Object} data.offsets The measurements of popper, reference and arrow elements\n * @property {Object} data.offsets.popper `top`, `left`, `width`, `height` values\n * @property {Object} data.offsets.reference `top`, `left`, `width`, `height` values\n * @property {Object} data.offsets.arrow] `top` and `left` offsets, only one of them will be different from 0\n */\n\n/**\n * Default options provided to Popper.js constructor.<br />\n * These can be overridden using the `options` argument of Popper.js.<br />\n * To override an option, simply pass an object with the same\n * structure of the `options` object, as the 3rd argument. For example:\n * ```\n * new Popper(ref, pop, {\n *   modifiers: {\n *     preventOverflow: { enabled: false }\n *   }\n * })\n * ```\n * @type {Object}\n * @static\n * @memberof Popper\n */\nvar Defaults = {\n  /**\n   * Popper's placement.\n   * @prop {Popper.placements} placement='bottom'\n   */\n  placement: 'bottom',\n  /**\n   * Set this to true if you want popper to position it self in 'fixed' mode\n   * @prop {Boolean} positionFixed=false\n   */\n  positionFixed: false,\n  /**\n   * Whether events (resize, scroll) are initially enabled.\n   * @prop {Boolean} eventsEnabled=true\n   */\n  eventsEnabled: true,\n  /**\n   * Set to true if you want to automatically remove the popper when\n   * you call the `destroy` method.\n   * @prop {Boolean} removeOnDestroy=false\n   */\n  removeOnDestroy: false,\n  /**\n   * Callback called when the popper is created.<br />\n   * By default, it is set to no-op.<br />\n   * Access Popper.js instance with `data.instance`.\n   * @prop {onCreate}\n   */\n  onCreate: function onCreate() {},\n  /**\n   * Callback called when the popper is updated. This callback is not called\n   * on the initialization/creation of the popper, but only on subsequent\n   * updates.<br />\n   * By default, it is set to no-op.<br />\n   * Access Popper.js instance with `data.instance`.\n   * @prop {onUpdate}\n   */\n  onUpdate: function onUpdate() {},\n  /**\n   * List of modifiers used to modify the offsets before they are applied to the popper.\n   * They provide most of the functionalities of Popper.js.\n   * @prop {modifiers}\n   */\n  modifiers: modifiers\n};\n\n/**\n * @callback onCreate\n * @param {dataObject} data\n */\n\n/**\n * @callback onUpdate\n * @param {dataObject} data\n */\n\n// Utils\n// Methods\nvar Popper = function () {\n  /**\n   * Creates a new Popper.js instance.\n   * @class Popper\n   * @param {Element|referenceObject} reference - The reference element used to position the popper\n   * @param {Element} popper - The HTML / XML element used as the popper\n   * @param {Object} options - Your custom options to override the ones defined in [Defaults](#defaults)\n   * @return {Object} instance - The generated Popper.js instance\n   */\n  function Popper(reference, popper) {\n    var _this = this;\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    classCallCheck(this, Popper);\n    this.scheduleUpdate = function () {\n      return requestAnimationFrame(_this.update);\n    };\n\n    // make update() debounced, so that it only runs at most once-per-tick\n    this.update = debounce(this.update.bind(this));\n\n    // with {} we create a new object with the options inside it\n    this.options = _extends({}, Popper.Defaults, options);\n\n    // init state\n    this.state = {\n      isDestroyed: false,\n      isCreated: false,\n      scrollParents: []\n    };\n\n    // get reference and popper elements (allow jQuery wrappers)\n    this.reference = reference && reference.jquery ? reference[0] : reference;\n    this.popper = popper && popper.jquery ? popper[0] : popper;\n\n    // Deep merge modifiers options\n    this.options.modifiers = {};\n    Object.keys(_extends({}, Popper.Defaults.modifiers, options.modifiers)).forEach(function (name) {\n      _this.options.modifiers[name] = _extends({}, Popper.Defaults.modifiers[name] || {}, options.modifiers ? options.modifiers[name] : {});\n    });\n\n    // Refactoring modifiers' list (Object => Array)\n    this.modifiers = Object.keys(this.options.modifiers).map(function (name) {\n      return _extends({\n        name: name\n      }, _this.options.modifiers[name]);\n    })\n    // sort the modifiers by order\n    .sort(function (a, b) {\n      return a.order - b.order;\n    });\n\n    // modifiers have the ability to execute arbitrary code when Popper.js get inited\n    // such code is executed in the same order of its modifier\n    // they could add new properties to their options configuration\n    // BE AWARE: don't add options to `options.modifiers.name` but to `modifierOptions`!\n    this.modifiers.forEach(function (modifierOptions) {\n      if (modifierOptions.enabled && isFunction(modifierOptions.onLoad)) {\n        modifierOptions.onLoad(_this.reference, _this.popper, _this.options, modifierOptions, _this.state);\n      }\n    });\n\n    // fire the first update to position the popper in the right place\n    this.update();\n    var eventsEnabled = this.options.eventsEnabled;\n    if (eventsEnabled) {\n      // setup event listeners, they will take care of update the position in specific situations\n      this.enableEventListeners();\n    }\n    this.state.eventsEnabled = eventsEnabled;\n  }\n\n  // We can't use class properties because they don't get listed in the\n  // class prototype and break stuff like Sinon stubs\n\n  createClass(Popper, [{\n    key: 'update',\n    value: function update$$1() {\n      return update.call(this);\n    }\n  }, {\n    key: 'destroy',\n    value: function destroy$$1() {\n      return destroy.call(this);\n    }\n  }, {\n    key: 'enableEventListeners',\n    value: function enableEventListeners$$1() {\n      return enableEventListeners.call(this);\n    }\n  }, {\n    key: 'disableEventListeners',\n    value: function disableEventListeners$$1() {\n      return disableEventListeners.call(this);\n    }\n\n    /**\n     * Schedules an update. It will run on the next UI update available.\n     * @method scheduleUpdate\n     * @memberof Popper\n     */\n\n    /**\n     * Collection of utilities useful when writing custom modifiers.\n     * Starting from version 1.7, this method is available only if you\n     * include `popper-utils.js` before `popper.js`.\n     *\n     * **DEPRECATION**: This way to access PopperUtils is deprecated\n     * and will be removed in v2! Use the PopperUtils module directly instead.\n     * Due to the high instability of the methods contained in Utils, we can't\n     * guarantee them to follow semver. Use them at your own risk!\n     * @static\n     * @private\n     * @type {Object}\n     * @deprecated since version 1.8\n     * @member Utils\n     * @memberof Popper\n     */\n  }]);\n\n  return Popper;\n}();\n\n/**\n * The `referenceObject` is an object that provides an interface compatible with Popper.js\n * and lets you use it as replacement of a real DOM node.<br />\n * You can use this method to position a popper relatively to a set of coordinates\n * in case you don't have a DOM node to use as reference.\n *\n * ```\n * new Popper(referenceObject, popperNode);\n * ```\n *\n * NB: This feature isn't supported in Internet Explorer 10.\n * @name referenceObject\n * @property {Function} data.getBoundingClientRect\n * A function that returns a set of coordinates compatible with the native `getBoundingClientRect` method.\n * @property {number} data.clientWidth\n * An ES6 getter that will return the width of the virtual reference element.\n * @property {number} data.clientHeight\n * An ES6 getter that will return the height of the virtual reference element.\n */\n\nPopper.Utils = (typeof window !== 'undefined' ? window : __webpack_require__.g).PopperUtils;\nPopper.placements = placements;\nPopper.Defaults = Defaults;\n/* harmony default export */ const esm_popper = (Popper);\n;// CONCATENATED MODULE: ./shiptimize-admin.js\n\n\nclass Shiptimize {\n  constructor() {\n    console.log(\"I'm alive!\");\n    this.boostrap();\n  }\n\n  /** \n   *  \n   */\n  boostrap() {\n    if (jQuery(\".shiptimize-tooltip-message\").size() == 0) {\n      setTimeout(() => {\n        this.boostrap();\n      }, 500);\n      return;\n    }\n    console.log(jQuery(\".shiptimize-tooltip-message\").size());\n    this.tooltips();\n    this.loadAnalytics();\n  }\n  tooltips() {\n    let toltip = jQuery(\".shiptimize-tooltip-message\");\n    if (toltip.size() == 0) {\n      return;\n    }\n    let me = this;\n    toltip.each(function (idx, elem) {\n      me.attachPopper(elem, container);\n    });\n  }\n  attachPopper(toltip, container) {\n    let eToltip = jQuery(toltip);\n    let toltipReference = eToltip.siblings(\".shiptimize-tooltip-reference\");\n    let arrow = eToltip.children('.shiptimize-tooltip-message__arrow').get(0);\n    var popper = new esm_popper(toltipReference.get(0), toltip, {\n      placement: 'left',\n      modifiers: {\n        flip: {\n          behavior: ['top', 'left', 'bottom']\n        },\n        preventOverflow: {\n          boundariesElement: container\n        },\n        offset: {\n          enabled: true,\n          offset: '10,10'\n        },\n        arrow: {\n          enabled: true,\n          element: arrow\n        }\n      }\n    });\n    setTimeout(() => {\n      popper.update();\n    }, 200);\n  }\n  exportSuccess(appLink) {\n    this.platform.exportSuccess(appLink);\n  }\n\n  /** \n   * @param string category \n   * @param string action \n   * @param string label \n   */\n  sendAnalyticsEvent(category, action, label) {\n    ga('shiptimize.send', 'event', category, action, label, {\n      transport: 'beacon'\n    });\n  }\n  loadAnalytics() {\n    if (typeof ga == 'undefined') {\n      (function (i, s, o, g, r, a, m) {\n        i['GoogleAnalyticsObject'] = r;\n        i[r] = i[r] || function () {\n          (i[r].q = i[r].q || []).push(arguments);\n        }, i[r].l = 1 * new Date();\n        a = s.createElement(o), m = s.getElementsByTagName(o)[0];\n        a.async = 1;\n        a.src = g;\n        m.parentNode.insertBefore(a, m);\n      })(window, document, 'script', 'https://www.google-analytics.com/analytics.js', 'ga');\n      console.log(\"inserting analytics \");\n    }\n    ga('create', 'UA-101485643-1', 'auto', 'shiptimize');\n    ga('shiptimize.set', 'anonymizeIp', true);\n    console.log(\"creating tracker\");\n  }\n\n  /**\n   * Request the label status every 1s \n   */\n  monitorLabelStatus(callbackUrl) {\n    var data = {\n      'action': 'shiptimize_label_status',\n      'callbackUrl': callbackUrl\n    };\n    console.log(\"Monitor label status with data \", data);\n    jQuery.post(labelmonitorurl, data, data => {\n      console.log(data);\n      if (typeof data.response != 'undefined') {\n        // Check for falta errors \n        if (data.httpCode == '200') {\n          this.loaderMsg(shiptimize_label_request + ' ' + data.response.Finished + '%');\n        } else {\n          this.loaderMsg(\"Fatal API error \" + data.httpCode);\n          setTimeout(() => {\n            this.closeLoader();\n          }, 5000);\n          return;\n        }\n\n        // Print API errors\n        if (data.response.Error.Id > 0) {\n          this.loaderMsg(data.response.Error.Info);\n        }\n        if (data.response.Error.Id == 902) {\n          //No process running \n          setTimeout(() => {\n            this.closeLoader();\n          }, 2000);\n        }\n        if (data.response.Finished == 100) {\n          if (data.response.LabelFile.length > 0) {\n            let labelinfo = shiptimize_label_click.replace('%', `<a href=\"${data.response.LabelFile}\" target='_blank'>${shiptimize_label_label}</a>`);\n            jQuery(\"#shiptimize_label_status\").html(`<div class=\"notice notice-info is-dismissible updated\">${labelinfo}</div>`);\n            window.open(data.response.LabelFile, '_blank');\n            this.closeLoader();\n\n            /** \n             * Make sure the info is updated without the need to reload the page \n             */\n            for (var x = 0; x < data.response.ClientReferenceCodeList.length; ++x) {\n              var labelresult = data.response.ClientReferenceCodeList[x];\n              if (labelresult.Error.Id == 0) {\n                jQuery(\"#shiptimize-label\" + labelresult.ReferenceCode).addClass('shiptimize-icon-print-printed');\n              } else {\n                jQuery(\"#shiptimize-label\" + labelresult.ReferenceCode).addClass(\"shiptimize-icon-print-error\");\n              }\n              jQuery(\"#shiptimize-tooltip\" + labelresult.ReferenceCode).html(labelresult.message);\n            }\n          } else {\n            let msg = '';\n            for (var x = 0; x < data.response.ClientReferenceCodeList.length; ++x) {\n              let labelresult = data.response.ClientReferenceCodeList[0];\n              if (labelresult.Error.Id > 0) {\n                msg += \"<div class='shiptimize-label-error error'>\" + labelresult.Error.Info + \"</div>\";\n              }\n              jQuery(\"#shiptimize-label\" + labelresult.ReferenceCode).addClass(\"shiptimize-icon-print-error\");\n              jQuery(\"#shiptimize-tooltip\" + labelresult.ReferenceCode).html(labelresult.message);\n            }\n            this.loaderMsg(msg);\n            setTimeout(() => {\n              this.closeLoader();\n            }, 10000);\n          }\n        }\n        if (data.response.Finished < 100) {\n          setTimeout(() => {\n            this.monitorLabelStatus(callbackUrl);\n          }, 2000);\n        }\n      }\n    }, \"json\");\n  }\n  loaderMsg(message) {\n    jQuery(\".shiptimize-loader-message\").html(message);\n  }\n  openLoader(message) {\n    jQuery('body').append('<div class=\"shiptimize-loader-wrapper\"><div class=\"shiptimize-loader\"><div></div><div></div><div></div></div><div class=\"shiptimize-loader-message\">' + message + '</div></div>');\n  }\n  closeLoader() {\n    jQuery(\".shiptimize-loader-wrapper\").remove();\n  }\n}\njQuery(function () {\n  window.shiptimize = new Shiptimize();\n  window.Popper = esm_popper;\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LENBQUMzVCxJQUFJLENBQUNzWCxPQUFPLENBQUM7RUFDcEQ7RUFFQUUsVUFBVUEsQ0FBQ0YsT0FBTyxFQUFFO0lBQ2xCM0QsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDOEQsTUFBTSxDQUFDLHNKQUFzSixHQUFHSCxPQUFPLEdBQUksY0FBYyxDQUFDO0VBQzNNO0VBRUFiLFdBQVdBLENBQUEsRUFBRTtJQUNYOUMsTUFBTSxDQUFDLDRCQUE0QixDQUFDLENBQUMrRCxNQUFNLENBQUMsQ0FBQztFQUMvQztBQUNGO0FBRUEvRCxNQUFNLENBQUMsWUFBWTtFQUNqQjdZLE1BQU0sQ0FBQzZjLFVBQVUsR0FBRyxJQUFJckUsVUFBVSxDQUFDLENBQUM7RUFDcEN4WSxNQUFNLENBQUMrWCxNQUFNLEdBQUdBLFVBQU07QUFDeEIsQ0FBQyxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2hpcHRpbWl6ZS8uLi8uLi9zcmMvdXRpbHMvaXNCcm93c2VyLmpzP2NjOTYiLCJ3ZWJwYWNrOi8vc2hpcHRpbWl6ZS8uLi8uLi9zcmMvdXRpbHMvZGVib3VuY2UuanM/ZmI0OSIsIndlYnBhY2s6Ly9zaGlwdGltaXplLy4uLy4uL3NyYy91dGlscy9pc0Z1bmN0aW9uLmpzPzU0ZmEiLCJ3ZWJwYWNrOi8vc2hpcHRpbWl6ZS8uLi8uLi9zcmMvdXRpbHMvZ2V0U3R5bGVDb21wdXRlZFByb3BlcnR5LmpzP2Y0ZDkiLCJ3ZWJwYWNrOi8vc2hpcHRpbWl6ZS8uLi8uLi9zcmMvdXRpbHMvZ2V0UGFyZW50Tm9kZS5qcz9jOTA1Iiwid2VicGFjazovL3NoaXB0aW1pemUvLi4vLi4vc3JjL3V0aWxzL2dldFNjcm9sbFBhcmVudC5qcz9mMGZmIiwid2VicGFjazovL3NoaXB0aW1pemUvLi4vLi4vc3JjL3V0aWxzL2dldFJlZmVyZW5jZU5vZGUuanM/ZDVmNSIsIndlYnBhY2s6Ly9zaGlwdGltaXplLy4uLy4uL3NyYy91dGlscy9pc0lFLmpzP2FlZmQiLCJ3ZWJwYWNrOi8vc2hpcHRpbWl6ZS8uLi8uLi9zcmMvdXRpbHMvZ2V0T2Zmc2V0UGFyZW50LmpzP2RmM2UiLCJ3ZWJwYWNrOi8vc2hpcHRpbWl6ZS8uLi8uLi9zcmMvdXRpbHMvaXNPZmZzZXRDb250YWluZXIuanM/MTAwNCIsIndlYnBhY2s6Ly9zaGlwdGltaXplLy4uLy4uL3NyYy91dGlscy9nZXRSb290LmpzPzg3OGMiLCJ3ZWJwYWNrOi8vc2hpcHRpbWl6ZS8uLi8uLi9zcmMvdXRpbHMvZmluZENvbW1vbk9mZnNldFBhcmVudC5qcz83M2Q3Iiwid2VicGFjazovL3NoaXB0aW1pemUvLi4vLi4vc3JjL3V0aWxzL2dldFNjcm9sbC5qcz8zOTMyIiwid2VicGFjazovL3NoaXB0aW1pemUvLi4vLi4vc3JjL3V0aWxzL2luY2x1ZGVTY3JvbGwuanM/NGRhOSIsIndlYnBhY2s6Ly9zaGlwdGltaXplLy4uLy4uL3NyYy91dGlscy9nZXRCb3JkZXJzU2l6ZS5qcz82MDNmIiwid2VicGFjazovL3NoaXB0aW1pemUvLi4vLi4vc3JjL3V0aWxzL2dldFdpbmRvd1NpemVzLmpzPzYyMzciLCJ3ZWJwYWNrOi8vc2hpcHRpbWl6ZS8uLi8uLi9zcmMvdXRpbHMvZ2V0Q2xpZW50UmVjdC5qcz9lYTk2Iiwid2VicGFjazovL3NoaXB0aW1pemUvLi4vLi4vc3JjL3V0aWxzL2dldEJvdW5kaW5nQ2xpZW50UmVjdC5qcz9hY2E5Iiwid2VicGFjazovL3NoaXB0aW1pemUvLi4vLi4vc3JjL3V0aWxzL2dldE9mZnNldFJlY3RSZWxhdGl2ZVRvQXJiaXRyYXJ5Tm9kZS5qcz84NGFiIiwid2VicGFjazovL3NoaXB0aW1pemUvLi4vLi4vc3JjL3V0aWxzL2dldFZpZXdwb3J0T2Zmc2V0UmVjdFJlbGF0aXZlVG9BcnRiaXRyYXJ5Tm9kZS5qcz84MmRkIiwid2VicGFjazovL3NoaXB0aW1pemUvLi4vLi4vc3JjL3V0aWxzL2lzRml4ZWQuanM/OGZhYyIsIndlYnBhY2s6Ly9zaGlwdGltaXplLy4uLy4uL3NyYy91dGlscy9nZXRGaXhlZFBvc2l0aW9uT2Zmc2V0UGFyZW50LmpzPzNjNTkiLCJ3ZWJwYWNrOi8vc2hpcHRpbWl6ZS8uLi8uLi9zcmMvdXRpbHMvZ2V0Qm91bmRhcmllcy5qcz9jNjY3Iiwid2VicGFjazovL3NoaXB0aW1pemUvLi4vLi4vc3JjL3V0aWxzL2NvbXB1dGVBdXRvUGxhY2VtZW50LmpzPzA1OTciLCJ3ZWJwYWNrOi8vc2hpcHRpbWl6ZS8uLi8uLi9zcmMvdXRpbHMvZ2V0UmVmZXJlbmNlT2Zmc2V0cy5qcz9hMDM0Iiwid2VicGFjazovL3NoaXB0aW1pemUvLi4vLi4vc3JjL3V0aWxzL2dldE91dGVyU2l6ZXMuanM/ZWUyMyIsIndlYnBhY2s6Ly9zaGlwdGltaXplLy4uLy4uL3NyYy91dGlscy9nZXRPcHBvc2l0ZVBsYWNlbWVudC5qcz9jYTJjIiwid2VicGFjazovL3NoaXB0aW1pemUvLi4vLi4vc3JjL3V0aWxzL2dldFBvcHBlck9mZnNldHMuanM/YmJiZiIsIndlYnBhY2s6Ly9zaGlwdGltaXplLy4uLy4uL3NyYy91dGlscy9maW5kLmpzPzFiNzciLCJ3ZWJwYWNrOi8vc2hpcHRpbWl6ZS8uLi8uLi9zcmMvdXRpbHMvZmluZEluZGV4LmpzPzZmYWIiLCJ3ZWJwYWNrOi8vc2hpcHRpbWl6ZS8uLi8uLi9zcmMvdXRpbHMvcnVuTW9kaWZpZXJzLmpzPzliODMiLCJ3ZWJwYWNrOi8vc2hpcHRpbWl6ZS8uLi8uLi9zcmMvbWV0aG9kcy91cGRhdGUuanM/M2M2MyIsIndlYnBhY2s6Ly9zaGlwdGltaXplLy4uLy4uL3NyYy91dGlscy9pc01vZGlmaWVyRW5hYmxlZC5qcz81ODc2Iiwid2VicGFjazovL3NoaXB0aW1pemUvLi4vLi4vc3JjL3V0aWxzL2dldFN1cHBvcnRlZFByb3BlcnR5TmFtZS5qcz8xNzczIiwid2VicGFjazovL3NoaXB0aW1pemUvLi4vLi4vc3JjL21ldGhvZHMvZGVzdHJveS5qcz80MWQ5Iiwid2VicGFjazovL3NoaXB0aW1pemUvLi4vLi4vc3JjL3V0aWxzL2dldFdpbmRvdy5qcz85OGE2Iiwid2VicGFjazovL3NoaXB0aW1pemUvLi4vLi4vc3JjL3V0aWxzL3NldHVwRXZlbnRMaXN0ZW5lcnMuanM/ZjM4MiIsIndlYnBhY2s6Ly9zaGlwdGltaXplLy4uLy4uL3NyYy9tZXRob2RzL2VuYWJsZUV2ZW50TGlzdGVuZXJzLmpzP2U4Y2EiLCJ3ZWJwYWNrOi8vc2hpcHRpbWl6ZS8uLi8uLi9zcmMvdXRpbHMvcmVtb3ZlRXZlbnRMaXN0ZW5lcnMuanM/NTNjNyIsIndlYnBhY2s6Ly9zaGlwdGltaXplLy4uLy4uL3NyYy9tZXRob2RzL2Rpc2FibGVFdmVudExpc3RlbmVycy5qcz8zYTg5Iiwid2VicGFjazovL3NoaXB0aW1pemUvLi4vLi4vc3JjL3V0aWxzL2lzTnVtZXJpYy5qcz9mMDRkIiwid2VicGFjazovL3NoaXB0aW1pemUvLi4vLi4vc3JjL3V0aWxzL3NldFN0eWxlcy5qcz9lZjA1Iiwid2VicGFjazovL3NoaXB0aW1pemUvLi4vLi4vc3JjL3V0aWxzL3NldEF0dHJpYnV0ZXMuanM/ZmU0ZCIsIndlYnBhY2s6Ly9zaGlwdGltaXplLy4uLy4uL3NyYy9tb2RpZmllcnMvYXBwbHlTdHlsZS5qcz83ZTYwIiwid2VicGFjazovL3NoaXB0aW1pemUvLi4vLi4vc3JjL3V0aWxzL2dldFJvdW5kZWRPZmZzZXRzLmpzP2FjMTQiLCJ3ZWJwYWNrOi8vc2hpcHRpbWl6ZS8uLi8uLi9zcmMvbW9kaWZpZXJzL2NvbXB1dGVTdHlsZS5qcz82MGEyIiwid2VicGFjazovL3NoaXB0aW1pemUvLi4vLi4vc3JjL3V0aWxzL2lzTW9kaWZpZXJSZXF1aXJlZC5qcz9hZDdlIiwid2VicGFjazovL3NoaXB0aW1pemUvLi4vLi4vc3JjL21vZGlmaWVycy9hcnJvdy5qcz82YWU4Iiwid2VicGFjazovL3NoaXB0aW1pemUvLi4vLi4vc3JjL3V0aWxzL2dldE9wcG9zaXRlVmFyaWF0aW9uLmpzPzkzYmIiLCJ3ZWJwYWNrOi8vc2hpcHRpbWl6ZS8uLi8uLi9zcmMvbWV0aG9kcy9wbGFjZW1lbnRzLmpzPzZkNDYiLCJ3ZWJwYWNrOi8vc2hpcHRpbWl6ZS8uLi8uLi9zcmMvdXRpbHMvY2xvY2t3aXNlLmpzP2ZkYjgiLCJ3ZWJwYWNrOi8vc2hpcHRpbWl6ZS8uLi8uLi9zcmMvbW9kaWZpZXJzL2ZsaXAuanM/YmY0NyIsIndlYnBhY2s6Ly9zaGlwdGltaXplLy4uLy4uL3NyYy9tb2RpZmllcnMva2VlcFRvZ2V0aGVyLmpzP2JiZmUiLCJ3ZWJwYWNrOi8vc2hpcHRpbWl6ZS8uLi8uLi9zcmMvbW9kaWZpZXJzL29mZnNldC5qcz84ZTNlIiwid2VicGFjazovL3NoaXB0aW1pemUvLi4vLi4vc3JjL21vZGlmaWVycy9wcmV2ZW50T3ZlcmZsb3cuanM/MjdmOSIsIndlYnBhY2s6Ly9zaGlwdGltaXplLy4uLy4uL3NyYy9tb2RpZmllcnMvc2hpZnQuanM/YmExYSIsIndlYnBhY2s6Ly9zaGlwdGltaXplLy4uLy4uL3NyYy9tb2RpZmllcnMvaGlkZS5qcz9mMWQ2Iiwid2VicGFjazovL3NoaXB0aW1pemUvLi4vLi4vc3JjL21vZGlmaWVycy9pbm5lci5qcz8xNWVkIiwid2VicGFjazovL3NoaXB0aW1pemUvLi4vLi4vc3JjL21vZGlmaWVycy9pbmRleC5qcz8yNTA0Iiwid2VicGFjazovL3NoaXB0aW1pemUvLi4vLi4vc3JjL21ldGhvZHMvZGVmYXVsdHMuanM/YTg0OCIsIndlYnBhY2s6Ly9zaGlwdGltaXplLy4uLy4uL3NyYy9pbmRleC5qcz8yNDI3Iiwid2VicGFjazovL3NoaXB0aW1pemUvLi9zaGlwdGltaXplLWFkbWluLmpzPzM4YTIiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJztcbiIsImltcG9ydCBpc0Jyb3dzZXIgZnJvbSAnLi9pc0Jyb3dzZXInO1xuXG5jb25zdCB0aW1lb3V0RHVyYXRpb24gPSAoZnVuY3Rpb24oKXtcbiAgY29uc3QgbG9uZ2VyVGltZW91dEJyb3dzZXJzID0gWydFZGdlJywgJ1RyaWRlbnQnLCAnRmlyZWZveCddO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxvbmdlclRpbWVvdXRCcm93c2Vycy5sZW5ndGg7IGkgKz0gMSkge1xuICAgIGlmIChpc0Jyb3dzZXIgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKGxvbmdlclRpbWVvdXRCcm93c2Vyc1tpXSkgPj0gMCkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICB9XG4gIHJldHVybiAwO1xufSgpKTtcblxuZXhwb3J0IGZ1bmN0aW9uIG1pY3JvdGFza0RlYm91bmNlKGZuKSB7XG4gIGxldCBjYWxsZWQgPSBmYWxzZVxuICByZXR1cm4gKCkgPT4ge1xuICAgIGlmIChjYWxsZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBjYWxsZWQgPSB0cnVlXG4gICAgd2luZG93LlByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4ge1xuICAgICAgY2FsbGVkID0gZmFsc2VcbiAgICAgIGZuKClcbiAgICB9KVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0YXNrRGVib3VuY2UoZm4pIHtcbiAgbGV0IHNjaGVkdWxlZCA9IGZhbHNlO1xuICByZXR1cm4gKCkgPT4ge1xuICAgIGlmICghc2NoZWR1bGVkKSB7XG4gICAgICBzY2hlZHVsZWQgPSB0cnVlO1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHNjaGVkdWxlZCA9IGZhbHNlO1xuICAgICAgICBmbigpO1xuICAgICAgfSwgdGltZW91dER1cmF0aW9uKTtcbiAgICB9XG4gIH07XG59XG5cbmNvbnN0IHN1cHBvcnRzTWljcm9UYXNrcyA9IGlzQnJvd3NlciAmJiB3aW5kb3cuUHJvbWlzZVxuXG5cbi8qKlxuKiBDcmVhdGUgYSBkZWJvdW5jZWQgdmVyc2lvbiBvZiBhIG1ldGhvZCwgdGhhdCdzIGFzeW5jaHJvbm91c2x5IGRlZmVycmVkXG4qIGJ1dCBjYWxsZWQgaW4gdGhlIG1pbmltdW0gdGltZSBwb3NzaWJsZS5cbipcbiogQG1ldGhvZFxuKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4qIEBhcmd1bWVudCB7RnVuY3Rpb259IGZuXG4qIEByZXR1cm5zIHtGdW5jdGlvbn1cbiovXG5leHBvcnQgZGVmYXVsdCAoc3VwcG9ydHNNaWNyb1Rhc2tzXG4gID8gbWljcm90YXNrRGVib3VuY2VcbiAgOiB0YXNrRGVib3VuY2UpO1xuIiwiLyoqXG4gKiBDaGVjayBpZiB0aGUgZ2l2ZW4gdmFyaWFibGUgaXMgYSBmdW5jdGlvblxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtBbnl9IGZ1bmN0aW9uVG9DaGVjayAtIHZhcmlhYmxlIHRvIGNoZWNrXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gYW5zd2VyIHRvOiBpcyBhIGZ1bmN0aW9uP1xuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpc0Z1bmN0aW9uKGZ1bmN0aW9uVG9DaGVjaykge1xuICBjb25zdCBnZXRUeXBlID0ge307XG4gIHJldHVybiAoXG4gICAgZnVuY3Rpb25Ub0NoZWNrICYmXG4gICAgZ2V0VHlwZS50b1N0cmluZy5jYWxsKGZ1bmN0aW9uVG9DaGVjaykgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSdcbiAgKTtcbn1cbiIsIi8qKlxuICogR2V0IENTUyBjb21wdXRlZCBwcm9wZXJ0eSBvZiB0aGUgZ2l2ZW4gZWxlbWVudFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtFZW1lbnR9IGVsZW1lbnRcbiAqIEBhcmd1bWVudCB7U3RyaW5nfSBwcm9wZXJ0eVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRTdHlsZUNvbXB1dGVkUHJvcGVydHkoZWxlbWVudCwgcHJvcGVydHkpIHtcbiAgaWYgKGVsZW1lbnQubm9kZVR5cGUgIT09IDEpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgLy8gTk9URTogMSBET00gYWNjZXNzIGhlcmVcbiAgY29uc3Qgd2luZG93ID0gZWxlbWVudC5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3O1xuICBjb25zdCBjc3MgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50LCBudWxsKTtcbiAgcmV0dXJuIHByb3BlcnR5ID8gY3NzW3Byb3BlcnR5XSA6IGNzcztcbn1cbiIsIi8qKlxuICogUmV0dXJucyB0aGUgcGFyZW50Tm9kZSBvciB0aGUgaG9zdCBvZiB0aGUgZWxlbWVudFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcmV0dXJucyB7RWxlbWVudH0gcGFyZW50XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldFBhcmVudE5vZGUoZWxlbWVudCkge1xuICBpZiAoZWxlbWVudC5ub2RlTmFtZSA9PT0gJ0hUTUwnKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cbiAgcmV0dXJuIGVsZW1lbnQucGFyZW50Tm9kZSB8fCBlbGVtZW50Lmhvc3Q7XG59XG4iLCJpbXBvcnQgZ2V0U3R5bGVDb21wdXRlZFByb3BlcnR5IGZyb20gJy4vZ2V0U3R5bGVDb21wdXRlZFByb3BlcnR5JztcbmltcG9ydCBnZXRQYXJlbnROb2RlIGZyb20gJy4vZ2V0UGFyZW50Tm9kZSc7XG5cbi8qKlxuICogUmV0dXJucyB0aGUgc2Nyb2xsaW5nIHBhcmVudCBvZiB0aGUgZ2l2ZW4gZWxlbWVudFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcmV0dXJucyB7RWxlbWVudH0gc2Nyb2xsIHBhcmVudFxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRTY3JvbGxQYXJlbnQoZWxlbWVudCkge1xuICAvLyBSZXR1cm4gYm9keSwgYGdldFNjcm9sbGAgd2lsbCB0YWtlIGNhcmUgdG8gZ2V0IHRoZSBjb3JyZWN0IGBzY3JvbGxUb3BgIGZyb20gaXRcbiAgaWYgKCFlbGVtZW50KSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmJvZHlcbiAgfVxuXG4gIHN3aXRjaCAoZWxlbWVudC5ub2RlTmFtZSkge1xuICAgIGNhc2UgJ0hUTUwnOlxuICAgIGNhc2UgJ0JPRFknOlxuICAgICAgcmV0dXJuIGVsZW1lbnQub3duZXJEb2N1bWVudC5ib2R5XG4gICAgY2FzZSAnI2RvY3VtZW50JzpcbiAgICAgIHJldHVybiBlbGVtZW50LmJvZHlcbiAgfVxuXG4gIC8vIEZpcmVmb3ggd2FudCB1cyB0byBjaGVjayBgLXhgIGFuZCBgLXlgIHZhcmlhdGlvbnMgYXMgd2VsbFxuICBjb25zdCB7IG92ZXJmbG93LCBvdmVyZmxvd1gsIG92ZXJmbG93WSB9ID0gZ2V0U3R5bGVDb21wdXRlZFByb3BlcnR5KGVsZW1lbnQpO1xuICBpZiAoLyhhdXRvfHNjcm9sbHxvdmVybGF5KS8udGVzdChvdmVyZmxvdyArIG92ZXJmbG93WSArIG92ZXJmbG93WCkpIHtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuXG4gIHJldHVybiBnZXRTY3JvbGxQYXJlbnQoZ2V0UGFyZW50Tm9kZShlbGVtZW50KSk7XG59XG4iLCIvKipcbiAqIFJldHVybnMgdGhlIHJlZmVyZW5jZSBub2RlIG9mIHRoZSByZWZlcmVuY2Ugb2JqZWN0LCBvciB0aGUgcmVmZXJlbmNlIG9iamVjdCBpdHNlbGYuXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcGFyYW0ge0VsZW1lbnR8T2JqZWN0fSByZWZlcmVuY2UgLSB0aGUgcmVmZXJlbmNlIGVsZW1lbnQgKHRoZSBwb3BwZXIgd2lsbCBiZSByZWxhdGl2ZSB0byB0aGlzKVxuICogQHJldHVybnMge0VsZW1lbnR9IHBhcmVudFxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRSZWZlcmVuY2VOb2RlKHJlZmVyZW5jZSkge1xuICByZXR1cm4gcmVmZXJlbmNlICYmIHJlZmVyZW5jZS5yZWZlcmVuY2VOb2RlID8gcmVmZXJlbmNlLnJlZmVyZW5jZU5vZGUgOiByZWZlcmVuY2U7XG59XG4iLCJpbXBvcnQgaXNCcm93c2VyIGZyb20gJy4vaXNCcm93c2VyJztcblxuY29uc3QgaXNJRTExID0gaXNCcm93c2VyICYmICEhKHdpbmRvdy5NU0lucHV0TWV0aG9kQ29udGV4dCAmJiBkb2N1bWVudC5kb2N1bWVudE1vZGUpO1xuY29uc3QgaXNJRTEwID0gaXNCcm93c2VyICYmIC9NU0lFIDEwLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuXG4vKipcbiAqIERldGVybWluZXMgaWYgdGhlIGJyb3dzZXIgaXMgSW50ZXJuZXQgRXhwbG9yZXJcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBwYXJhbSB7TnVtYmVyfSB2ZXJzaW9uIHRvIGNoZWNrXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gaXNJRVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpc0lFKHZlcnNpb24pIHtcbiAgaWYgKHZlcnNpb24gPT09IDExKSB7XG4gICAgcmV0dXJuIGlzSUUxMTtcbiAgfVxuICBpZiAodmVyc2lvbiA9PT0gMTApIHtcbiAgICByZXR1cm4gaXNJRTEwO1xuICB9XG4gIHJldHVybiBpc0lFMTEgfHwgaXNJRTEwO1xufVxuIiwiaW1wb3J0IGdldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eSBmcm9tICcuL2dldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eSc7XG5pbXBvcnQgaXNJRSBmcm9tICcuL2lzSUUnO1xuLyoqXG4gKiBSZXR1cm5zIHRoZSBvZmZzZXQgcGFyZW50IG9mIHRoZSBnaXZlbiBlbGVtZW50XG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEByZXR1cm5zIHtFbGVtZW50fSBvZmZzZXQgcGFyZW50XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldE9mZnNldFBhcmVudChlbGVtZW50KSB7XG4gIGlmICghZWxlbWVudCkge1xuICAgIHJldHVybiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gIH1cblxuICBjb25zdCBub09mZnNldFBhcmVudCA9IGlzSUUoMTApID8gZG9jdW1lbnQuYm9keSA6IG51bGw7XG5cbiAgLy8gTk9URTogMSBET00gYWNjZXNzIGhlcmVcbiAgbGV0IG9mZnNldFBhcmVudCA9IGVsZW1lbnQub2Zmc2V0UGFyZW50IHx8IG51bGw7XG4gIC8vIFNraXAgaGlkZGVuIGVsZW1lbnRzIHdoaWNoIGRvbid0IGhhdmUgYW4gb2Zmc2V0UGFyZW50XG4gIHdoaWxlIChvZmZzZXRQYXJlbnQgPT09IG5vT2Zmc2V0UGFyZW50ICYmIGVsZW1lbnQubmV4dEVsZW1lbnRTaWJsaW5nKSB7XG4gICAgb2Zmc2V0UGFyZW50ID0gKGVsZW1lbnQgPSBlbGVtZW50Lm5leHRFbGVtZW50U2libGluZykub2Zmc2V0UGFyZW50O1xuICB9XG5cbiAgY29uc3Qgbm9kZU5hbWUgPSBvZmZzZXRQYXJlbnQgJiYgb2Zmc2V0UGFyZW50Lm5vZGVOYW1lO1xuXG4gIGlmICghbm9kZU5hbWUgfHwgbm9kZU5hbWUgPT09ICdCT0RZJyB8fCBub2RlTmFtZSA9PT0gJ0hUTUwnKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQgPyBlbGVtZW50Lm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50IDogZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICB9XG5cbiAgLy8gLm9mZnNldFBhcmVudCB3aWxsIHJldHVybiB0aGUgY2xvc2VzdCBUSCwgVEQgb3IgVEFCTEUgaW4gY2FzZVxuICAvLyBubyBvZmZzZXRQYXJlbnQgaXMgcHJlc2VudCwgSSBoYXRlIHRoaXMgam9iLi4uXG4gIGlmIChcbiAgICBbJ1RIJywgJ1REJywgJ1RBQkxFJ10uaW5kZXhPZihvZmZzZXRQYXJlbnQubm9kZU5hbWUpICE9PSAtMSAmJlxuICAgIGdldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eShvZmZzZXRQYXJlbnQsICdwb3NpdGlvbicpID09PSAnc3RhdGljJ1xuICApIHtcbiAgICByZXR1cm4gZ2V0T2Zmc2V0UGFyZW50KG9mZnNldFBhcmVudCk7XG4gIH1cblxuICByZXR1cm4gb2Zmc2V0UGFyZW50O1xufVxuIiwiaW1wb3J0IGdldE9mZnNldFBhcmVudCBmcm9tICcuL2dldE9mZnNldFBhcmVudCc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGlzT2Zmc2V0Q29udGFpbmVyKGVsZW1lbnQpIHtcbiAgY29uc3QgeyBub2RlTmFtZSB9ID0gZWxlbWVudDtcbiAgaWYgKG5vZGVOYW1lID09PSAnQk9EWScpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIChcbiAgICBub2RlTmFtZSA9PT0gJ0hUTUwnIHx8IGdldE9mZnNldFBhcmVudChlbGVtZW50LmZpcnN0RWxlbWVudENoaWxkKSA9PT0gZWxlbWVudFxuICApO1xufVxuIiwiLyoqXG4gKiBGaW5kcyB0aGUgcm9vdCBub2RlIChkb2N1bWVudCwgc2hhZG93RE9NIHJvb3QpIG9mIHRoZSBnaXZlbiBlbGVtZW50XG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IG5vZGVcbiAqIEByZXR1cm5zIHtFbGVtZW50fSByb290IG5vZGVcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0Um9vdChub2RlKSB7XG4gIGlmIChub2RlLnBhcmVudE5vZGUgIT09IG51bGwpIHtcbiAgICByZXR1cm4gZ2V0Um9vdChub2RlLnBhcmVudE5vZGUpO1xuICB9XG5cbiAgcmV0dXJuIG5vZGU7XG59XG4iLCJpbXBvcnQgaXNPZmZzZXRDb250YWluZXIgZnJvbSAnLi9pc09mZnNldENvbnRhaW5lcic7XG5pbXBvcnQgZ2V0Um9vdCBmcm9tICcuL2dldFJvb3QnO1xuaW1wb3J0IGdldE9mZnNldFBhcmVudCBmcm9tICcuL2dldE9mZnNldFBhcmVudCc7XG5cbi8qKlxuICogRmluZHMgdGhlIG9mZnNldCBwYXJlbnQgY29tbW9uIHRvIHRoZSB0d28gcHJvdmlkZWQgbm9kZXNcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gZWxlbWVudDFcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gZWxlbWVudDJcbiAqIEByZXR1cm5zIHtFbGVtZW50fSBjb21tb24gb2Zmc2V0IHBhcmVudFxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBmaW5kQ29tbW9uT2Zmc2V0UGFyZW50KGVsZW1lbnQxLCBlbGVtZW50Mikge1xuICAvLyBUaGlzIGNoZWNrIGlzIG5lZWRlZCB0byBhdm9pZCBlcnJvcnMgaW4gY2FzZSBvbmUgb2YgdGhlIGVsZW1lbnRzIGlzbid0IGRlZmluZWQgZm9yIGFueSByZWFzb25cbiAgaWYgKCFlbGVtZW50MSB8fCAhZWxlbWVudDEubm9kZVR5cGUgfHwgIWVsZW1lbnQyIHx8ICFlbGVtZW50Mi5ub2RlVHlwZSkge1xuICAgIHJldHVybiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gIH1cblxuICAvLyBIZXJlIHdlIG1ha2Ugc3VyZSB0byBnaXZlIGFzIFwic3RhcnRcIiB0aGUgZWxlbWVudCB0aGF0IGNvbWVzIGZpcnN0IGluIHRoZSBET01cbiAgY29uc3Qgb3JkZXIgPVxuICAgIGVsZW1lbnQxLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKGVsZW1lbnQyKSAmXG4gICAgTm9kZS5ET0NVTUVOVF9QT1NJVElPTl9GT0xMT1dJTkc7XG4gIGNvbnN0IHN0YXJ0ID0gb3JkZXIgPyBlbGVtZW50MSA6IGVsZW1lbnQyO1xuICBjb25zdCBlbmQgPSBvcmRlciA/IGVsZW1lbnQyIDogZWxlbWVudDE7XG5cbiAgLy8gR2V0IGNvbW1vbiBhbmNlc3RvciBjb250YWluZXJcbiAgY29uc3QgcmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICByYW5nZS5zZXRTdGFydChzdGFydCwgMCk7XG4gIHJhbmdlLnNldEVuZChlbmQsIDApO1xuICBjb25zdCB7IGNvbW1vbkFuY2VzdG9yQ29udGFpbmVyIH0gPSByYW5nZTtcblxuICAvLyBCb3RoIG5vZGVzIGFyZSBpbnNpZGUgI2RvY3VtZW50XG4gIGlmIChcbiAgICAoZWxlbWVudDEgIT09IGNvbW1vbkFuY2VzdG9yQ29udGFpbmVyICYmXG4gICAgICBlbGVtZW50MiAhPT0gY29tbW9uQW5jZXN0b3JDb250YWluZXIpIHx8XG4gICAgc3RhcnQuY29udGFpbnMoZW5kKVxuICApIHtcbiAgICBpZiAoaXNPZmZzZXRDb250YWluZXIoY29tbW9uQW5jZXN0b3JDb250YWluZXIpKSB7XG4gICAgICByZXR1cm4gY29tbW9uQW5jZXN0b3JDb250YWluZXI7XG4gICAgfVxuXG4gICAgcmV0dXJuIGdldE9mZnNldFBhcmVudChjb21tb25BbmNlc3RvckNvbnRhaW5lcik7XG4gIH1cblxuICAvLyBvbmUgb2YgdGhlIG5vZGVzIGlzIGluc2lkZSBzaGFkb3dET00sIGZpbmQgd2hpY2ggb25lXG4gIGNvbnN0IGVsZW1lbnQxcm9vdCA9IGdldFJvb3QoZWxlbWVudDEpO1xuICBpZiAoZWxlbWVudDFyb290Lmhvc3QpIHtcbiAgICByZXR1cm4gZmluZENvbW1vbk9mZnNldFBhcmVudChlbGVtZW50MXJvb3QuaG9zdCwgZWxlbWVudDIpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmaW5kQ29tbW9uT2Zmc2V0UGFyZW50KGVsZW1lbnQxLCBnZXRSb290KGVsZW1lbnQyKS5ob3N0KTtcbiAgfVxufVxuIiwiLyoqXG4gKiBHZXRzIHRoZSBzY3JvbGwgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQgaW4gdGhlIGdpdmVuIHNpZGUgKHRvcCBhbmQgbGVmdClcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gZWxlbWVudFxuICogQGFyZ3VtZW50IHtTdHJpbmd9IHNpZGUgYHRvcGAgb3IgYGxlZnRgXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBhbW91bnQgb2Ygc2Nyb2xsZWQgcGl4ZWxzXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldFNjcm9sbChlbGVtZW50LCBzaWRlID0gJ3RvcCcpIHtcbiAgY29uc3QgdXBwZXJTaWRlID0gc2lkZSA9PT0gJ3RvcCcgPyAnc2Nyb2xsVG9wJyA6ICdzY3JvbGxMZWZ0JztcbiAgY29uc3Qgbm9kZU5hbWUgPSBlbGVtZW50Lm5vZGVOYW1lO1xuXG4gIGlmIChub2RlTmFtZSA9PT0gJ0JPRFknIHx8IG5vZGVOYW1lID09PSAnSFRNTCcpIHtcbiAgICBjb25zdCBodG1sID0gZWxlbWVudC5vd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICBjb25zdCBzY3JvbGxpbmdFbGVtZW50ID0gZWxlbWVudC5vd25lckRvY3VtZW50LnNjcm9sbGluZ0VsZW1lbnQgfHwgaHRtbDtcbiAgICByZXR1cm4gc2Nyb2xsaW5nRWxlbWVudFt1cHBlclNpZGVdO1xuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnRbdXBwZXJTaWRlXTtcbn1cbiIsImltcG9ydCBnZXRTY3JvbGwgZnJvbSAnLi9nZXRTY3JvbGwnO1xuXG4vKlxuICogU3VtIG9yIHN1YnRyYWN0IHRoZSBlbGVtZW50IHNjcm9sbCB2YWx1ZXMgKGxlZnQgYW5kIHRvcCkgZnJvbSBhIGdpdmVuIHJlY3Qgb2JqZWN0XG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcGFyYW0ge09iamVjdH0gcmVjdCAtIFJlY3Qgb2JqZWN0IHlvdSB3YW50IHRvIGNoYW5nZVxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCAtIFRoZSBlbGVtZW50IGZyb20gdGhlIGZ1bmN0aW9uIHJlYWRzIHRoZSBzY3JvbGwgdmFsdWVzXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHN1YnRyYWN0IC0gc2V0IHRvIHRydWUgaWYgeW91IHdhbnQgdG8gc3VidHJhY3QgdGhlIHNjcm9sbCB2YWx1ZXNcbiAqIEByZXR1cm4ge09iamVjdH0gcmVjdCAtIFRoZSBtb2RpZmllciByZWN0IG9iamVjdFxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpbmNsdWRlU2Nyb2xsKHJlY3QsIGVsZW1lbnQsIHN1YnRyYWN0ID0gZmFsc2UpIHtcbiAgY29uc3Qgc2Nyb2xsVG9wID0gZ2V0U2Nyb2xsKGVsZW1lbnQsICd0b3AnKTtcbiAgY29uc3Qgc2Nyb2xsTGVmdCA9IGdldFNjcm9sbChlbGVtZW50LCAnbGVmdCcpO1xuICBjb25zdCBtb2RpZmllciA9IHN1YnRyYWN0ID8gLTEgOiAxO1xuICByZWN0LnRvcCArPSBzY3JvbGxUb3AgKiBtb2RpZmllcjtcbiAgcmVjdC5ib3R0b20gKz0gc2Nyb2xsVG9wICogbW9kaWZpZXI7XG4gIHJlY3QubGVmdCArPSBzY3JvbGxMZWZ0ICogbW9kaWZpZXI7XG4gIHJlY3QucmlnaHQgKz0gc2Nyb2xsTGVmdCAqIG1vZGlmaWVyO1xuICByZXR1cm4gcmVjdDtcbn1cbiIsIi8qXG4gKiBIZWxwZXIgdG8gZGV0ZWN0IGJvcmRlcnMgb2YgYSBnaXZlbiBlbGVtZW50XG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcGFyYW0ge0NTU1N0eWxlRGVjbGFyYXRpb259IHN0eWxlc1xuICogUmVzdWx0IG9mIGBnZXRTdHlsZUNvbXB1dGVkUHJvcGVydHlgIG9uIHRoZSBnaXZlbiBlbGVtZW50XG4gKiBAcGFyYW0ge1N0cmluZ30gYXhpcyAtIGB4YCBvciBgeWBcbiAqIEByZXR1cm4ge251bWJlcn0gYm9yZGVycyAtIFRoZSBib3JkZXJzIHNpemUgb2YgdGhlIGdpdmVuIGF4aXNcbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRCb3JkZXJzU2l6ZShzdHlsZXMsIGF4aXMpIHtcbiAgY29uc3Qgc2lkZUEgPSBheGlzID09PSAneCcgPyAnTGVmdCcgOiAnVG9wJztcbiAgY29uc3Qgc2lkZUIgPSBzaWRlQSA9PT0gJ0xlZnQnID8gJ1JpZ2h0JyA6ICdCb3R0b20nO1xuXG4gIHJldHVybiAoXG4gICAgcGFyc2VGbG9hdChzdHlsZXNbYGJvcmRlciR7c2lkZUF9V2lkdGhgXSkgK1xuICAgIHBhcnNlRmxvYXQoc3R5bGVzW2Bib3JkZXIke3NpZGVCfVdpZHRoYF0pXG4gICk7XG59XG4iLCJpbXBvcnQgaXNJRSBmcm9tICcuL2lzSUUnO1xuXG5mdW5jdGlvbiBnZXRTaXplKGF4aXMsIGJvZHksIGh0bWwsIGNvbXB1dGVkU3R5bGUpIHtcbiAgcmV0dXJuIE1hdGgubWF4KFxuICAgIGJvZHlbYG9mZnNldCR7YXhpc31gXSxcbiAgICBib2R5W2BzY3JvbGwke2F4aXN9YF0sXG4gICAgaHRtbFtgY2xpZW50JHtheGlzfWBdLFxuICAgIGh0bWxbYG9mZnNldCR7YXhpc31gXSxcbiAgICBodG1sW2BzY3JvbGwke2F4aXN9YF0sXG4gICAgaXNJRSgxMClcbiAgICAgID8gKHBhcnNlSW50KGh0bWxbYG9mZnNldCR7YXhpc31gXSkgKyBcbiAgICAgIHBhcnNlSW50KGNvbXB1dGVkU3R5bGVbYG1hcmdpbiR7YXhpcyA9PT0gJ0hlaWdodCcgPyAnVG9wJyA6ICdMZWZ0J31gXSkgKyBcbiAgICAgIHBhcnNlSW50KGNvbXB1dGVkU3R5bGVbYG1hcmdpbiR7YXhpcyA9PT0gJ0hlaWdodCcgPyAnQm90dG9tJyA6ICdSaWdodCd9YF0pKVxuICAgIDogMCBcbiAgKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0V2luZG93U2l6ZXMoZG9jdW1lbnQpIHtcbiAgY29uc3QgYm9keSA9IGRvY3VtZW50LmJvZHk7XG4gIGNvbnN0IGh0bWwgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gIGNvbnN0IGNvbXB1dGVkU3R5bGUgPSBpc0lFKDEwKSAmJiBnZXRDb21wdXRlZFN0eWxlKGh0bWwpO1xuXG4gIHJldHVybiB7XG4gICAgaGVpZ2h0OiBnZXRTaXplKCdIZWlnaHQnLCBib2R5LCBodG1sLCBjb21wdXRlZFN0eWxlKSxcbiAgICB3aWR0aDogZ2V0U2l6ZSgnV2lkdGgnLCBib2R5LCBodG1sLCBjb21wdXRlZFN0eWxlKSxcbiAgfTtcbn1cbiIsIi8qKlxuICogR2l2ZW4gZWxlbWVudCBvZmZzZXRzLCBnZW5lcmF0ZSBhbiBvdXRwdXQgc2ltaWxhciB0byBnZXRCb3VuZGluZ0NsaWVudFJlY3RcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvZmZzZXRzXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBDbGllbnRSZWN0IGxpa2Ugb3V0cHV0XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldENsaWVudFJlY3Qob2Zmc2V0cykge1xuICByZXR1cm4ge1xuICAgIC4uLm9mZnNldHMsXG4gICAgcmlnaHQ6IG9mZnNldHMubGVmdCArIG9mZnNldHMud2lkdGgsXG4gICAgYm90dG9tOiBvZmZzZXRzLnRvcCArIG9mZnNldHMuaGVpZ2h0LFxuICB9O1xufVxuIiwiaW1wb3J0IGdldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eSBmcm9tICcuL2dldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eSc7XG5pbXBvcnQgZ2V0Qm9yZGVyc1NpemUgZnJvbSAnLi9nZXRCb3JkZXJzU2l6ZSc7XG5pbXBvcnQgZ2V0V2luZG93U2l6ZXMgZnJvbSAnLi9nZXRXaW5kb3dTaXplcyc7XG5pbXBvcnQgZ2V0U2Nyb2xsIGZyb20gJy4vZ2V0U2Nyb2xsJztcbmltcG9ydCBnZXRDbGllbnRSZWN0IGZyb20gJy4vZ2V0Q2xpZW50UmVjdCc7XG5pbXBvcnQgaXNJRSBmcm9tICcuL2lzSUUnO1xuXG4vKipcbiAqIEdldCBib3VuZGluZyBjbGllbnQgcmVjdCBvZiBnaXZlbiBlbGVtZW50XG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gKiBAcmV0dXJuIHtPYmplY3R9IGNsaWVudCByZWN0XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldEJvdW5kaW5nQ2xpZW50UmVjdChlbGVtZW50KSB7XG4gIGxldCByZWN0ID0ge307XG5cbiAgLy8gSUUxMCAxMCBGSVg6IFBsZWFzZSwgZG9uJ3QgYXNrLCB0aGUgZWxlbWVudCBpc24ndFxuICAvLyBjb25zaWRlcmVkIGluIERPTSBpbiBzb21lIGNpcmN1bXN0YW5jZXMuLi5cbiAgLy8gVGhpcyBpc24ndCByZXByb2R1Y2libGUgaW4gSUUxMCBjb21wYXRpYmlsaXR5IG1vZGUgb2YgSUUxMVxuICB0cnkge1xuICAgIGlmIChpc0lFKDEwKSkge1xuICAgICAgcmVjdCA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBjb25zdCBzY3JvbGxUb3AgPSBnZXRTY3JvbGwoZWxlbWVudCwgJ3RvcCcpO1xuICAgICAgY29uc3Qgc2Nyb2xsTGVmdCA9IGdldFNjcm9sbChlbGVtZW50LCAnbGVmdCcpO1xuICAgICAgcmVjdC50b3AgKz0gc2Nyb2xsVG9wO1xuICAgICAgcmVjdC5sZWZ0ICs9IHNjcm9sbExlZnQ7XG4gICAgICByZWN0LmJvdHRvbSArPSBzY3JvbGxUb3A7XG4gICAgICByZWN0LnJpZ2h0ICs9IHNjcm9sbExlZnQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmVjdCA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgfVxuICB9XG4gIGNhdGNoKGUpe31cblxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgbGVmdDogcmVjdC5sZWZ0LFxuICAgIHRvcDogcmVjdC50b3AsXG4gICAgd2lkdGg6IHJlY3QucmlnaHQgLSByZWN0LmxlZnQsXG4gICAgaGVpZ2h0OiByZWN0LmJvdHRvbSAtIHJlY3QudG9wLFxuICB9O1xuXG4gIC8vIHN1YnRyYWN0IHNjcm9sbGJhciBzaXplIGZyb20gc2l6ZXNcbiAgY29uc3Qgc2l6ZXMgPSBlbGVtZW50Lm5vZGVOYW1lID09PSAnSFRNTCcgPyBnZXRXaW5kb3dTaXplcyhlbGVtZW50Lm93bmVyRG9jdW1lbnQpIDoge307XG4gIGNvbnN0IHdpZHRoID1cbiAgICBzaXplcy53aWR0aCB8fCBlbGVtZW50LmNsaWVudFdpZHRoIHx8IHJlc3VsdC53aWR0aDtcbiAgY29uc3QgaGVpZ2h0ID1cbiAgICBzaXplcy5oZWlnaHQgfHwgZWxlbWVudC5jbGllbnRIZWlnaHQgfHwgcmVzdWx0LmhlaWdodDtcblxuICBsZXQgaG9yaXpTY3JvbGxiYXIgPSBlbGVtZW50Lm9mZnNldFdpZHRoIC0gd2lkdGg7XG4gIGxldCB2ZXJ0U2Nyb2xsYmFyID0gZWxlbWVudC5vZmZzZXRIZWlnaHQgLSBoZWlnaHQ7XG5cbiAgLy8gaWYgYW4gaHlwb3RoZXRpY2FsIHNjcm9sbGJhciBpcyBkZXRlY3RlZCwgd2UgbXVzdCBiZSBzdXJlIGl0J3Mgbm90IGEgYGJvcmRlcmBcbiAgLy8gd2UgbWFrZSB0aGlzIGNoZWNrIGNvbmRpdGlvbmFsIGZvciBwZXJmb3JtYW5jZSByZWFzb25zXG4gIGlmIChob3JpelNjcm9sbGJhciB8fCB2ZXJ0U2Nyb2xsYmFyKSB7XG4gICAgY29uc3Qgc3R5bGVzID0gZ2V0U3R5bGVDb21wdXRlZFByb3BlcnR5KGVsZW1lbnQpO1xuICAgIGhvcml6U2Nyb2xsYmFyIC09IGdldEJvcmRlcnNTaXplKHN0eWxlcywgJ3gnKTtcbiAgICB2ZXJ0U2Nyb2xsYmFyIC09IGdldEJvcmRlcnNTaXplKHN0eWxlcywgJ3knKTtcblxuICAgIHJlc3VsdC53aWR0aCAtPSBob3JpelNjcm9sbGJhcjtcbiAgICByZXN1bHQuaGVpZ2h0IC09IHZlcnRTY3JvbGxiYXI7XG4gIH1cblxuICByZXR1cm4gZ2V0Q2xpZW50UmVjdChyZXN1bHQpO1xufVxuIiwiaW1wb3J0IGdldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eSBmcm9tICcuL2dldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eSc7XG5pbXBvcnQgaW5jbHVkZVNjcm9sbCBmcm9tICcuL2luY2x1ZGVTY3JvbGwnO1xuaW1wb3J0IGdldFNjcm9sbFBhcmVudCBmcm9tICcuL2dldFNjcm9sbFBhcmVudCc7XG5pbXBvcnQgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IGZyb20gJy4vZ2V0Qm91bmRpbmdDbGllbnRSZWN0JztcbmltcG9ydCBydW5Jc0lFIGZyb20gJy4vaXNJRSc7XG5pbXBvcnQgZ2V0Q2xpZW50UmVjdCBmcm9tICcuL2dldENsaWVudFJlY3QnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRPZmZzZXRSZWN0UmVsYXRpdmVUb0FyYml0cmFyeU5vZGUoY2hpbGRyZW4sIHBhcmVudCwgZml4ZWRQb3NpdGlvbiA9IGZhbHNlKSB7XG4gIGNvbnN0IGlzSUUxMCA9IHJ1bklzSUUoMTApO1xuICBjb25zdCBpc0hUTUwgPSBwYXJlbnQubm9kZU5hbWUgPT09ICdIVE1MJztcbiAgY29uc3QgY2hpbGRyZW5SZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGNoaWxkcmVuKTtcbiAgY29uc3QgcGFyZW50UmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChwYXJlbnQpO1xuICBjb25zdCBzY3JvbGxQYXJlbnQgPSBnZXRTY3JvbGxQYXJlbnQoY2hpbGRyZW4pO1xuXG4gIGNvbnN0IHN0eWxlcyA9IGdldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eShwYXJlbnQpO1xuICBjb25zdCBib3JkZXJUb3BXaWR0aCA9IHBhcnNlRmxvYXQoc3R5bGVzLmJvcmRlclRvcFdpZHRoKTtcbiAgY29uc3QgYm9yZGVyTGVmdFdpZHRoID0gcGFyc2VGbG9hdChzdHlsZXMuYm9yZGVyTGVmdFdpZHRoKTtcblxuICAvLyBJbiBjYXNlcyB3aGVyZSB0aGUgcGFyZW50IGlzIGZpeGVkLCB3ZSBtdXN0IGlnbm9yZSBuZWdhdGl2ZSBzY3JvbGwgaW4gb2Zmc2V0IGNhbGNcbiAgaWYoZml4ZWRQb3NpdGlvbiAmJiBpc0hUTUwpIHtcbiAgICBwYXJlbnRSZWN0LnRvcCA9IE1hdGgubWF4KHBhcmVudFJlY3QudG9wLCAwKTtcbiAgICBwYXJlbnRSZWN0LmxlZnQgPSBNYXRoLm1heChwYXJlbnRSZWN0LmxlZnQsIDApO1xuICB9XG4gIGxldCBvZmZzZXRzID0gZ2V0Q2xpZW50UmVjdCh7XG4gICAgdG9wOiBjaGlsZHJlblJlY3QudG9wIC0gcGFyZW50UmVjdC50b3AgLSBib3JkZXJUb3BXaWR0aCxcbiAgICBsZWZ0OiBjaGlsZHJlblJlY3QubGVmdCAtIHBhcmVudFJlY3QubGVmdCAtIGJvcmRlckxlZnRXaWR0aCxcbiAgICB3aWR0aDogY2hpbGRyZW5SZWN0LndpZHRoLFxuICAgIGhlaWdodDogY2hpbGRyZW5SZWN0LmhlaWdodCxcbiAgfSk7XG4gIG9mZnNldHMubWFyZ2luVG9wID0gMDtcbiAgb2Zmc2V0cy5tYXJnaW5MZWZ0ID0gMDtcblxuICAvLyBTdWJ0cmFjdCBtYXJnaW5zIG9mIGRvY3VtZW50RWxlbWVudCBpbiBjYXNlIGl0J3MgYmVpbmcgdXNlZCBhcyBwYXJlbnRcbiAgLy8gd2UgZG8gdGhpcyBvbmx5IG9uIEhUTUwgYmVjYXVzZSBpdCdzIHRoZSBvbmx5IGVsZW1lbnQgdGhhdCBiZWhhdmVzXG4gIC8vIGRpZmZlcmVudGx5IHdoZW4gbWFyZ2lucyBhcmUgYXBwbGllZCB0byBpdC4gVGhlIG1hcmdpbnMgYXJlIGluY2x1ZGVkIGluXG4gIC8vIHRoZSBib3ggb2YgdGhlIGRvY3VtZW50RWxlbWVudCwgaW4gdGhlIG90aGVyIGNhc2VzIG5vdC5cbiAgaWYgKCFpc0lFMTAgJiYgaXNIVE1MKSB7XG4gICAgY29uc3QgbWFyZ2luVG9wID0gcGFyc2VGbG9hdChzdHlsZXMubWFyZ2luVG9wKTtcbiAgICBjb25zdCBtYXJnaW5MZWZ0ID0gcGFyc2VGbG9hdChzdHlsZXMubWFyZ2luTGVmdCk7XG5cbiAgICBvZmZzZXRzLnRvcCAtPSBib3JkZXJUb3BXaWR0aCAtIG1hcmdpblRvcDtcbiAgICBvZmZzZXRzLmJvdHRvbSAtPSBib3JkZXJUb3BXaWR0aCAtIG1hcmdpblRvcDtcbiAgICBvZmZzZXRzLmxlZnQgLT0gYm9yZGVyTGVmdFdpZHRoIC0gbWFyZ2luTGVmdDtcbiAgICBvZmZzZXRzLnJpZ2h0IC09IGJvcmRlckxlZnRXaWR0aCAtIG1hcmdpbkxlZnQ7XG5cbiAgICAvLyBBdHRhY2ggbWFyZ2luVG9wIGFuZCBtYXJnaW5MZWZ0IGJlY2F1c2UgaW4gc29tZSBjaXJjdW1zdGFuY2VzIHdlIG1heSBuZWVkIHRoZW1cbiAgICBvZmZzZXRzLm1hcmdpblRvcCA9IG1hcmdpblRvcDtcbiAgICBvZmZzZXRzLm1hcmdpbkxlZnQgPSBtYXJnaW5MZWZ0O1xuICB9XG5cbiAgaWYgKFxuICAgIGlzSUUxMCAmJiAhZml4ZWRQb3NpdGlvblxuICAgICAgPyBwYXJlbnQuY29udGFpbnMoc2Nyb2xsUGFyZW50KVxuICAgICAgOiBwYXJlbnQgPT09IHNjcm9sbFBhcmVudCAmJiBzY3JvbGxQYXJlbnQubm9kZU5hbWUgIT09ICdCT0RZJ1xuICApIHtcbiAgICBvZmZzZXRzID0gaW5jbHVkZVNjcm9sbChvZmZzZXRzLCBwYXJlbnQpO1xuICB9XG5cbiAgcmV0dXJuIG9mZnNldHM7XG59XG4iLCJpbXBvcnQgZ2V0T2Zmc2V0UmVjdFJlbGF0aXZlVG9BcmJpdHJhcnlOb2RlIGZyb20gJy4vZ2V0T2Zmc2V0UmVjdFJlbGF0aXZlVG9BcmJpdHJhcnlOb2RlJztcbmltcG9ydCBnZXRTY3JvbGwgZnJvbSAnLi9nZXRTY3JvbGwnO1xuaW1wb3J0IGdldENsaWVudFJlY3QgZnJvbSAnLi9nZXRDbGllbnRSZWN0JztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0Vmlld3BvcnRPZmZzZXRSZWN0UmVsYXRpdmVUb0FydGJpdHJhcnlOb2RlKGVsZW1lbnQsIGV4Y2x1ZGVTY3JvbGwgPSBmYWxzZSkge1xuICBjb25zdCBodG1sID0gZWxlbWVudC5vd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgY29uc3QgcmVsYXRpdmVPZmZzZXQgPSBnZXRPZmZzZXRSZWN0UmVsYXRpdmVUb0FyYml0cmFyeU5vZGUoZWxlbWVudCwgaHRtbCk7XG4gIGNvbnN0IHdpZHRoID0gTWF0aC5tYXgoaHRtbC5jbGllbnRXaWR0aCwgd2luZG93LmlubmVyV2lkdGggfHwgMCk7XG4gIGNvbnN0IGhlaWdodCA9IE1hdGgubWF4KGh0bWwuY2xpZW50SGVpZ2h0LCB3aW5kb3cuaW5uZXJIZWlnaHQgfHwgMCk7XG5cbiAgY29uc3Qgc2Nyb2xsVG9wID0gIWV4Y2x1ZGVTY3JvbGwgPyBnZXRTY3JvbGwoaHRtbCkgOiAwO1xuICBjb25zdCBzY3JvbGxMZWZ0ID0gIWV4Y2x1ZGVTY3JvbGwgPyBnZXRTY3JvbGwoaHRtbCwgJ2xlZnQnKSA6IDA7XG5cbiAgY29uc3Qgb2Zmc2V0ID0ge1xuICAgIHRvcDogc2Nyb2xsVG9wIC0gcmVsYXRpdmVPZmZzZXQudG9wICsgcmVsYXRpdmVPZmZzZXQubWFyZ2luVG9wLFxuICAgIGxlZnQ6IHNjcm9sbExlZnQgLSByZWxhdGl2ZU9mZnNldC5sZWZ0ICsgcmVsYXRpdmVPZmZzZXQubWFyZ2luTGVmdCxcbiAgICB3aWR0aCxcbiAgICBoZWlnaHQsXG4gIH07XG5cbiAgcmV0dXJuIGdldENsaWVudFJlY3Qob2Zmc2V0KTtcbn1cbiIsImltcG9ydCBnZXRTdHlsZUNvbXB1dGVkUHJvcGVydHkgZnJvbSAnLi9nZXRTdHlsZUNvbXB1dGVkUHJvcGVydHknO1xuaW1wb3J0IGdldFBhcmVudE5vZGUgZnJvbSAnLi9nZXRQYXJlbnROb2RlJztcblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgZ2l2ZW4gZWxlbWVudCBpcyBmaXhlZCBvciBpcyBpbnNpZGUgYSBmaXhlZCBwYXJlbnRcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gZWxlbWVudFxuICogQGFyZ3VtZW50IHtFbGVtZW50fSBjdXN0b21Db250YWluZXJcbiAqIEByZXR1cm5zIHtCb29sZWFufSBhbnN3ZXIgdG8gXCJpc0ZpeGVkP1wiXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGlzRml4ZWQoZWxlbWVudCkge1xuICBjb25zdCBub2RlTmFtZSA9IGVsZW1lbnQubm9kZU5hbWU7XG4gIGlmIChub2RlTmFtZSA9PT0gJ0JPRFknIHx8IG5vZGVOYW1lID09PSAnSFRNTCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGdldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eShlbGVtZW50LCAncG9zaXRpb24nKSA9PT0gJ2ZpeGVkJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGNvbnN0IHBhcmVudE5vZGUgPSBnZXRQYXJlbnROb2RlKGVsZW1lbnQpO1xuICBpZiAoIXBhcmVudE5vZGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGlzRml4ZWQocGFyZW50Tm9kZSk7XG59XG4iLCJpbXBvcnQgZ2V0U3R5bGVDb21wdXRlZFByb3BlcnR5IGZyb20gJy4vZ2V0U3R5bGVDb21wdXRlZFByb3BlcnR5JztcbmltcG9ydCBpc0lFIGZyb20gJy4vaXNJRSc7XG4vKipcbiAqIEZpbmRzIHRoZSBmaXJzdCBwYXJlbnQgb2YgYW4gZWxlbWVudCB0aGF0IGhhcyBhIHRyYW5zZm9ybWVkIHByb3BlcnR5IGRlZmluZWRcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gZWxlbWVudFxuICogQHJldHVybnMge0VsZW1lbnR9IGZpcnN0IHRyYW5zZm9ybWVkIHBhcmVudCBvciBkb2N1bWVudEVsZW1lbnRcbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRGaXhlZFBvc2l0aW9uT2Zmc2V0UGFyZW50KGVsZW1lbnQpIHtcbiAgLy8gVGhpcyBjaGVjayBpcyBuZWVkZWQgdG8gYXZvaWQgZXJyb3JzIGluIGNhc2Ugb25lIG9mIHRoZSBlbGVtZW50cyBpc24ndCBkZWZpbmVkIGZvciBhbnkgcmVhc29uXG4gICBpZiAoIWVsZW1lbnQgfHwgIWVsZW1lbnQucGFyZW50RWxlbWVudCB8fCBpc0lFKCkpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICB9XG4gIGxldCBlbCA9IGVsZW1lbnQucGFyZW50RWxlbWVudDtcbiAgd2hpbGUgKGVsICYmIGdldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eShlbCwgJ3RyYW5zZm9ybScpID09PSAnbm9uZScpIHtcbiAgICBlbCA9IGVsLnBhcmVudEVsZW1lbnQ7XG4gIH1cbiAgcmV0dXJuIGVsIHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcblxufVxuIiwiaW1wb3J0IGdldFNjcm9sbFBhcmVudCBmcm9tICcuL2dldFNjcm9sbFBhcmVudCc7XG5pbXBvcnQgZ2V0UGFyZW50Tm9kZSBmcm9tICcuL2dldFBhcmVudE5vZGUnO1xuaW1wb3J0IGdldFJlZmVyZW5jZU5vZGUgZnJvbSAnLi9nZXRSZWZlcmVuY2VOb2RlJztcbmltcG9ydCBmaW5kQ29tbW9uT2Zmc2V0UGFyZW50IGZyb20gJy4vZmluZENvbW1vbk9mZnNldFBhcmVudCc7XG5pbXBvcnQgZ2V0T2Zmc2V0UmVjdFJlbGF0aXZlVG9BcmJpdHJhcnlOb2RlIGZyb20gJy4vZ2V0T2Zmc2V0UmVjdFJlbGF0aXZlVG9BcmJpdHJhcnlOb2RlJztcbmltcG9ydCBnZXRWaWV3cG9ydE9mZnNldFJlY3RSZWxhdGl2ZVRvQXJ0Yml0cmFyeU5vZGUgZnJvbSAnLi9nZXRWaWV3cG9ydE9mZnNldFJlY3RSZWxhdGl2ZVRvQXJ0Yml0cmFyeU5vZGUnO1xuaW1wb3J0IGdldFdpbmRvd1NpemVzIGZyb20gJy4vZ2V0V2luZG93U2l6ZXMnO1xuaW1wb3J0IGlzRml4ZWQgZnJvbSAnLi9pc0ZpeGVkJztcbmltcG9ydCBnZXRGaXhlZFBvc2l0aW9uT2Zmc2V0UGFyZW50IGZyb20gJy4vZ2V0Rml4ZWRQb3NpdGlvbk9mZnNldFBhcmVudCc7XG5cbi8qKlxuICogQ29tcHV0ZWQgdGhlIGJvdW5kYXJpZXMgbGltaXRzIGFuZCByZXR1cm4gdGhlbVxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcG9wcGVyXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSByZWZlcmVuY2VcbiAqIEBwYXJhbSB7bnVtYmVyfSBwYWRkaW5nXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBib3VuZGFyaWVzRWxlbWVudCAtIEVsZW1lbnQgdXNlZCB0byBkZWZpbmUgdGhlIGJvdW5kYXJpZXNcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gZml4ZWRQb3NpdGlvbiAtIElzIGluIGZpeGVkIHBvc2l0aW9uIG1vZGVcbiAqIEByZXR1cm5zIHtPYmplY3R9IENvb3JkaW5hdGVzIG9mIHRoZSBib3VuZGFyaWVzXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldEJvdW5kYXJpZXMoXG4gIHBvcHBlcixcbiAgcmVmZXJlbmNlLFxuICBwYWRkaW5nLFxuICBib3VuZGFyaWVzRWxlbWVudCxcbiAgZml4ZWRQb3NpdGlvbiA9IGZhbHNlXG4pIHtcbiAgLy8gTk9URTogMSBET00gYWNjZXNzIGhlcmVcblxuICBsZXQgYm91bmRhcmllcyA9IHsgdG9wOiAwLCBsZWZ0OiAwIH07XG4gIGNvbnN0IG9mZnNldFBhcmVudCA9IGZpeGVkUG9zaXRpb24gPyBnZXRGaXhlZFBvc2l0aW9uT2Zmc2V0UGFyZW50KHBvcHBlcikgOiBmaW5kQ29tbW9uT2Zmc2V0UGFyZW50KHBvcHBlciwgZ2V0UmVmZXJlbmNlTm9kZShyZWZlcmVuY2UpKTtcblxuICAvLyBIYW5kbGUgdmlld3BvcnQgY2FzZVxuICBpZiAoYm91bmRhcmllc0VsZW1lbnQgPT09ICd2aWV3cG9ydCcgKSB7XG4gICAgYm91bmRhcmllcyA9IGdldFZpZXdwb3J0T2Zmc2V0UmVjdFJlbGF0aXZlVG9BcnRiaXRyYXJ5Tm9kZShvZmZzZXRQYXJlbnQsIGZpeGVkUG9zaXRpb24pO1xuICB9XG5cbiAgZWxzZSB7XG4gICAgLy8gSGFuZGxlIG90aGVyIGNhc2VzIGJhc2VkIG9uIERPTSBlbGVtZW50IHVzZWQgYXMgYm91bmRhcmllc1xuICAgIGxldCBib3VuZGFyaWVzTm9kZTtcbiAgICBpZiAoYm91bmRhcmllc0VsZW1lbnQgPT09ICdzY3JvbGxQYXJlbnQnKSB7XG4gICAgICBib3VuZGFyaWVzTm9kZSA9IGdldFNjcm9sbFBhcmVudChnZXRQYXJlbnROb2RlKHJlZmVyZW5jZSkpO1xuICAgICAgaWYgKGJvdW5kYXJpZXNOb2RlLm5vZGVOYW1lID09PSAnQk9EWScpIHtcbiAgICAgICAgYm91bmRhcmllc05vZGUgPSBwb3BwZXIub3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChib3VuZGFyaWVzRWxlbWVudCA9PT0gJ3dpbmRvdycpIHtcbiAgICAgIGJvdW5kYXJpZXNOb2RlID0gcG9wcGVyLm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgIH0gZWxzZSB7XG4gICAgICBib3VuZGFyaWVzTm9kZSA9IGJvdW5kYXJpZXNFbGVtZW50O1xuICAgIH1cblxuICAgIGNvbnN0IG9mZnNldHMgPSBnZXRPZmZzZXRSZWN0UmVsYXRpdmVUb0FyYml0cmFyeU5vZGUoXG4gICAgICBib3VuZGFyaWVzTm9kZSxcbiAgICAgIG9mZnNldFBhcmVudCxcbiAgICAgIGZpeGVkUG9zaXRpb25cbiAgICApO1xuXG4gICAgLy8gSW4gY2FzZSBvZiBIVE1MLCB3ZSBuZWVkIGEgZGlmZmVyZW50IGNvbXB1dGF0aW9uXG4gICAgaWYgKGJvdW5kYXJpZXNOb2RlLm5vZGVOYW1lID09PSAnSFRNTCcgJiYgIWlzRml4ZWQob2Zmc2V0UGFyZW50KSkge1xuICAgICAgY29uc3QgeyBoZWlnaHQsIHdpZHRoIH0gPSBnZXRXaW5kb3dTaXplcyhwb3BwZXIub3duZXJEb2N1bWVudCk7XG4gICAgICBib3VuZGFyaWVzLnRvcCArPSBvZmZzZXRzLnRvcCAtIG9mZnNldHMubWFyZ2luVG9wO1xuICAgICAgYm91bmRhcmllcy5ib3R0b20gPSBoZWlnaHQgKyBvZmZzZXRzLnRvcDtcbiAgICAgIGJvdW5kYXJpZXMubGVmdCArPSBvZmZzZXRzLmxlZnQgLSBvZmZzZXRzLm1hcmdpbkxlZnQ7XG4gICAgICBib3VuZGFyaWVzLnJpZ2h0ID0gd2lkdGggKyBvZmZzZXRzLmxlZnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGZvciBhbGwgdGhlIG90aGVyIERPTSBlbGVtZW50cywgdGhpcyBvbmUgaXMgZ29vZFxuICAgICAgYm91bmRhcmllcyA9IG9mZnNldHM7XG4gICAgfVxuICB9XG5cbiAgLy8gQWRkIHBhZGRpbmdzXG4gIHBhZGRpbmcgPSBwYWRkaW5nIHx8IDA7XG4gIGNvbnN0IGlzUGFkZGluZ051bWJlciA9IHR5cGVvZiBwYWRkaW5nID09PSAnbnVtYmVyJztcbiAgYm91bmRhcmllcy5sZWZ0ICs9IGlzUGFkZGluZ051bWJlciA/IHBhZGRpbmcgOiBwYWRkaW5nLmxlZnQgfHwgMDsgXG4gIGJvdW5kYXJpZXMudG9wICs9IGlzUGFkZGluZ051bWJlciA/IHBhZGRpbmcgOiBwYWRkaW5nLnRvcCB8fCAwOyBcbiAgYm91bmRhcmllcy5yaWdodCAtPSBpc1BhZGRpbmdOdW1iZXIgPyBwYWRkaW5nIDogcGFkZGluZy5yaWdodCB8fCAwOyBcbiAgYm91bmRhcmllcy5ib3R0b20gLT0gaXNQYWRkaW5nTnVtYmVyID8gcGFkZGluZyA6IHBhZGRpbmcuYm90dG9tIHx8IDA7IFxuXG4gIHJldHVybiBib3VuZGFyaWVzO1xufVxuIiwiaW1wb3J0IGdldEJvdW5kYXJpZXMgZnJvbSAnLi4vdXRpbHMvZ2V0Qm91bmRhcmllcyc7XG5cbmZ1bmN0aW9uIGdldEFyZWEoeyB3aWR0aCwgaGVpZ2h0IH0pIHtcbiAgcmV0dXJuIHdpZHRoICogaGVpZ2h0O1xufVxuXG4vKipcbiAqIFV0aWxpdHkgdXNlZCB0byB0cmFuc2Zvcm0gdGhlIGBhdXRvYCBwbGFjZW1lbnQgdG8gdGhlIHBsYWNlbWVudCB3aXRoIG1vcmVcbiAqIGF2YWlsYWJsZSBzcGFjZS5cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSB1cGRhdGUgbWV0aG9kXG4gKiBAYXJndW1lbnQge09iamVjdH0gb3B0aW9ucyAtIE1vZGlmaWVycyBjb25maWd1cmF0aW9uIGFuZCBvcHRpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgZGF0YSBvYmplY3QsIHByb3Blcmx5IG1vZGlmaWVkXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNvbXB1dGVBdXRvUGxhY2VtZW50KFxuICBwbGFjZW1lbnQsXG4gIHJlZlJlY3QsXG4gIHBvcHBlcixcbiAgcmVmZXJlbmNlLFxuICBib3VuZGFyaWVzRWxlbWVudCxcbiAgcGFkZGluZyA9IDBcbikge1xuICBpZiAocGxhY2VtZW50LmluZGV4T2YoJ2F1dG8nKSA9PT0gLTEpIHtcbiAgICByZXR1cm4gcGxhY2VtZW50O1xuICB9XG5cbiAgY29uc3QgYm91bmRhcmllcyA9IGdldEJvdW5kYXJpZXMoXG4gICAgcG9wcGVyLFxuICAgIHJlZmVyZW5jZSxcbiAgICBwYWRkaW5nLFxuICAgIGJvdW5kYXJpZXNFbGVtZW50XG4gICk7XG5cbiAgY29uc3QgcmVjdHMgPSB7XG4gICAgdG9wOiB7XG4gICAgICB3aWR0aDogYm91bmRhcmllcy53aWR0aCxcbiAgICAgIGhlaWdodDogcmVmUmVjdC50b3AgLSBib3VuZGFyaWVzLnRvcCxcbiAgICB9LFxuICAgIHJpZ2h0OiB7XG4gICAgICB3aWR0aDogYm91bmRhcmllcy5yaWdodCAtIHJlZlJlY3QucmlnaHQsXG4gICAgICBoZWlnaHQ6IGJvdW5kYXJpZXMuaGVpZ2h0LFxuICAgIH0sXG4gICAgYm90dG9tOiB7XG4gICAgICB3aWR0aDogYm91bmRhcmllcy53aWR0aCxcbiAgICAgIGhlaWdodDogYm91bmRhcmllcy5ib3R0b20gLSByZWZSZWN0LmJvdHRvbSxcbiAgICB9LFxuICAgIGxlZnQ6IHtcbiAgICAgIHdpZHRoOiByZWZSZWN0LmxlZnQgLSBib3VuZGFyaWVzLmxlZnQsXG4gICAgICBoZWlnaHQ6IGJvdW5kYXJpZXMuaGVpZ2h0LFxuICAgIH0sXG4gIH07XG5cbiAgY29uc3Qgc29ydGVkQXJlYXMgPSBPYmplY3Qua2V5cyhyZWN0cylcbiAgICAubWFwKGtleSA9PiAoe1xuICAgICAga2V5LFxuICAgICAgLi4ucmVjdHNba2V5XSxcbiAgICAgIGFyZWE6IGdldEFyZWEocmVjdHNba2V5XSksXG4gICAgfSkpXG4gICAgLnNvcnQoKGEsIGIpID0+IGIuYXJlYSAtIGEuYXJlYSk7XG5cbiAgY29uc3QgZmlsdGVyZWRBcmVhcyA9IHNvcnRlZEFyZWFzLmZpbHRlcihcbiAgICAoeyB3aWR0aCwgaGVpZ2h0IH0pID0+XG4gICAgICB3aWR0aCA+PSBwb3BwZXIuY2xpZW50V2lkdGggJiYgaGVpZ2h0ID49IHBvcHBlci5jbGllbnRIZWlnaHRcbiAgKTtcblxuICBjb25zdCBjb21wdXRlZFBsYWNlbWVudCA9IGZpbHRlcmVkQXJlYXMubGVuZ3RoID4gMFxuICAgID8gZmlsdGVyZWRBcmVhc1swXS5rZXlcbiAgICA6IHNvcnRlZEFyZWFzWzBdLmtleTtcblxuICBjb25zdCB2YXJpYXRpb24gPSBwbGFjZW1lbnQuc3BsaXQoJy0nKVsxXTtcblxuICByZXR1cm4gY29tcHV0ZWRQbGFjZW1lbnQgKyAodmFyaWF0aW9uID8gYC0ke3ZhcmlhdGlvbn1gIDogJycpO1xufVxuIiwiaW1wb3J0IGZpbmRDb21tb25PZmZzZXRQYXJlbnQgZnJvbSAnLi9maW5kQ29tbW9uT2Zmc2V0UGFyZW50JztcbmltcG9ydCBnZXRPZmZzZXRSZWN0UmVsYXRpdmVUb0FyYml0cmFyeU5vZGUgZnJvbSAnLi9nZXRPZmZzZXRSZWN0UmVsYXRpdmVUb0FyYml0cmFyeU5vZGUnO1xuaW1wb3J0IGdldEZpeGVkUG9zaXRpb25PZmZzZXRQYXJlbnQgZnJvbSAnLi9nZXRGaXhlZFBvc2l0aW9uT2Zmc2V0UGFyZW50JztcbmltcG9ydCBnZXRSZWZlcmVuY2VOb2RlIGZyb20gJy4vZ2V0UmVmZXJlbmNlTm9kZSc7XG5cbi8qKlxuICogR2V0IG9mZnNldHMgdG8gdGhlIHJlZmVyZW5jZSBlbGVtZW50XG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhdGVcbiAqIEBwYXJhbSB7RWxlbWVudH0gcG9wcGVyIC0gdGhlIHBvcHBlciBlbGVtZW50XG4gKiBAcGFyYW0ge0VsZW1lbnR9IHJlZmVyZW5jZSAtIHRoZSByZWZlcmVuY2UgZWxlbWVudCAodGhlIHBvcHBlciB3aWxsIGJlIHJlbGF0aXZlIHRvIHRoaXMpXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGZpeGVkUG9zaXRpb24gLSBpcyBpbiBmaXhlZCBwb3NpdGlvbiBtb2RlXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgb2Zmc2V0cyB3aGljaCB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIHBvcHBlclxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRSZWZlcmVuY2VPZmZzZXRzKHN0YXRlLCBwb3BwZXIsIHJlZmVyZW5jZSwgZml4ZWRQb3NpdGlvbiA9IG51bGwpIHtcbiAgY29uc3QgY29tbW9uT2Zmc2V0UGFyZW50ID0gZml4ZWRQb3NpdGlvbiA/IGdldEZpeGVkUG9zaXRpb25PZmZzZXRQYXJlbnQocG9wcGVyKSA6IGZpbmRDb21tb25PZmZzZXRQYXJlbnQocG9wcGVyLCBnZXRSZWZlcmVuY2VOb2RlKHJlZmVyZW5jZSkpO1xuICByZXR1cm4gZ2V0T2Zmc2V0UmVjdFJlbGF0aXZlVG9BcmJpdHJhcnlOb2RlKHJlZmVyZW5jZSwgY29tbW9uT2Zmc2V0UGFyZW50LCBmaXhlZFBvc2l0aW9uKTtcbn1cbiIsIi8qKlxuICogR2V0IHRoZSBvdXRlciBzaXplcyBvZiB0aGUgZ2l2ZW4gZWxlbWVudCAob2Zmc2V0IHNpemUgKyBtYXJnaW5zKVxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcmV0dXJucyB7T2JqZWN0fSBvYmplY3QgY29udGFpbmluZyB3aWR0aCBhbmQgaGVpZ2h0IHByb3BlcnRpZXNcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0T3V0ZXJTaXplcyhlbGVtZW50KSB7XG4gIGNvbnN0IHdpbmRvdyA9IGVsZW1lbnQub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldztcbiAgY29uc3Qgc3R5bGVzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG4gIGNvbnN0IHggPSBwYXJzZUZsb2F0KHN0eWxlcy5tYXJnaW5Ub3AgfHwgMCkgKyBwYXJzZUZsb2F0KHN0eWxlcy5tYXJnaW5Cb3R0b20gfHwgMCk7XG4gIGNvbnN0IHkgPSBwYXJzZUZsb2F0KHN0eWxlcy5tYXJnaW5MZWZ0IHx8IDApICsgcGFyc2VGbG9hdChzdHlsZXMubWFyZ2luUmlnaHQgfHwgMCk7XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICB3aWR0aDogZWxlbWVudC5vZmZzZXRXaWR0aCArIHksXG4gICAgaGVpZ2h0OiBlbGVtZW50Lm9mZnNldEhlaWdodCArIHgsXG4gIH07XG4gIHJldHVybiByZXN1bHQ7XG59XG4iLCIvKipcbiAqIEdldCB0aGUgb3Bwb3NpdGUgcGxhY2VtZW50IG9mIHRoZSBnaXZlbiBvbmVcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7U3RyaW5nfSBwbGFjZW1lbnRcbiAqIEByZXR1cm5zIHtTdHJpbmd9IGZsaXBwZWQgcGxhY2VtZW50XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldE9wcG9zaXRlUGxhY2VtZW50KHBsYWNlbWVudCkge1xuICBjb25zdCBoYXNoID0geyBsZWZ0OiAncmlnaHQnLCByaWdodDogJ2xlZnQnLCBib3R0b206ICd0b3AnLCB0b3A6ICdib3R0b20nIH07XG4gIHJldHVybiBwbGFjZW1lbnQucmVwbGFjZSgvbGVmdHxyaWdodHxib3R0b218dG9wL2csIG1hdGNoZWQgPT4gaGFzaFttYXRjaGVkXSk7XG59XG4iLCJpbXBvcnQgZ2V0T3V0ZXJTaXplcyBmcm9tICcuL2dldE91dGVyU2l6ZXMnO1xuaW1wb3J0IGdldE9wcG9zaXRlUGxhY2VtZW50IGZyb20gJy4vZ2V0T3Bwb3NpdGVQbGFjZW1lbnQnO1xuXG4vKipcbiAqIEdldCBvZmZzZXRzIHRvIHRoZSBwb3BwZXJcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBwb3NpdGlvbiAtIENTUyBwb3NpdGlvbiB0aGUgUG9wcGVyIHdpbGwgZ2V0IGFwcGxpZWRcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHBvcHBlciAtIHRoZSBwb3BwZXIgZWxlbWVudFxuICogQHBhcmFtIHtPYmplY3R9IHJlZmVyZW5jZU9mZnNldHMgLSB0aGUgcmVmZXJlbmNlIG9mZnNldHMgKHRoZSBwb3BwZXIgd2lsbCBiZSByZWxhdGl2ZSB0byB0aGlzKVxuICogQHBhcmFtIHtTdHJpbmd9IHBsYWNlbWVudCAtIG9uZSBvZiB0aGUgdmFsaWQgcGxhY2VtZW50IG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3R9IHBvcHBlck9mZnNldHMgLSBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgb2Zmc2V0cyB3aGljaCB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIHBvcHBlclxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRQb3BwZXJPZmZzZXRzKHBvcHBlciwgcmVmZXJlbmNlT2Zmc2V0cywgcGxhY2VtZW50KSB7XG4gIHBsYWNlbWVudCA9IHBsYWNlbWVudC5zcGxpdCgnLScpWzBdO1xuXG4gIC8vIEdldCBwb3BwZXIgbm9kZSBzaXplc1xuICBjb25zdCBwb3BwZXJSZWN0ID0gZ2V0T3V0ZXJTaXplcyhwb3BwZXIpO1xuXG4gIC8vIEFkZCBwb3NpdGlvbiwgd2lkdGggYW5kIGhlaWdodCB0byBvdXIgb2Zmc2V0cyBvYmplY3RcbiAgY29uc3QgcG9wcGVyT2Zmc2V0cyA9IHtcbiAgICB3aWR0aDogcG9wcGVyUmVjdC53aWR0aCxcbiAgICBoZWlnaHQ6IHBvcHBlclJlY3QuaGVpZ2h0LFxuICB9O1xuXG4gIC8vIGRlcGVuZGluZyBieSB0aGUgcG9wcGVyIHBsYWNlbWVudCB3ZSBoYXZlIHRvIGNvbXB1dGUgaXRzIG9mZnNldHMgc2xpZ2h0bHkgZGlmZmVyZW50bHlcbiAgY29uc3QgaXNIb3JpeiA9IFsncmlnaHQnLCAnbGVmdCddLmluZGV4T2YocGxhY2VtZW50KSAhPT0gLTE7XG4gIGNvbnN0IG1haW5TaWRlID0gaXNIb3JpeiA/ICd0b3AnIDogJ2xlZnQnO1xuICBjb25zdCBzZWNvbmRhcnlTaWRlID0gaXNIb3JpeiA/ICdsZWZ0JyA6ICd0b3AnO1xuICBjb25zdCBtZWFzdXJlbWVudCA9IGlzSG9yaXogPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG4gIGNvbnN0IHNlY29uZGFyeU1lYXN1cmVtZW50ID0gIWlzSG9yaXogPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG5cbiAgcG9wcGVyT2Zmc2V0c1ttYWluU2lkZV0gPVxuICAgIHJlZmVyZW5jZU9mZnNldHNbbWFpblNpZGVdICtcbiAgICByZWZlcmVuY2VPZmZzZXRzW21lYXN1cmVtZW50XSAvIDIgLVxuICAgIHBvcHBlclJlY3RbbWVhc3VyZW1lbnRdIC8gMjtcbiAgaWYgKHBsYWNlbWVudCA9PT0gc2Vjb25kYXJ5U2lkZSkge1xuICAgIHBvcHBlck9mZnNldHNbc2Vjb25kYXJ5U2lkZV0gPVxuICAgICAgcmVmZXJlbmNlT2Zmc2V0c1tzZWNvbmRhcnlTaWRlXSAtIHBvcHBlclJlY3Rbc2Vjb25kYXJ5TWVhc3VyZW1lbnRdO1xuICB9IGVsc2Uge1xuICAgIHBvcHBlck9mZnNldHNbc2Vjb25kYXJ5U2lkZV0gPVxuICAgICAgcmVmZXJlbmNlT2Zmc2V0c1tnZXRPcHBvc2l0ZVBsYWNlbWVudChzZWNvbmRhcnlTaWRlKV07XG4gIH1cblxuICByZXR1cm4gcG9wcGVyT2Zmc2V0cztcbn1cbiIsIi8qKlxuICogTWltaWNzIHRoZSBgZmluZGAgbWV0aG9kIG9mIEFycmF5XG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0FycmF5fSBhcnJcbiAqIEBhcmd1bWVudCBwcm9wXG4gKiBAYXJndW1lbnQgdmFsdWVcbiAqIEByZXR1cm5zIGluZGV4IG9yIC0xXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGZpbmQoYXJyLCBjaGVjaykge1xuICAvLyB1c2UgbmF0aXZlIGZpbmQgaWYgc3VwcG9ydGVkXG4gIGlmIChBcnJheS5wcm90b3R5cGUuZmluZCkge1xuICAgIHJldHVybiBhcnIuZmluZChjaGVjayk7XG4gIH1cblxuICAvLyB1c2UgYGZpbHRlcmAgdG8gb2J0YWluIHRoZSBzYW1lIGJlaGF2aW9yIG9mIGBmaW5kYFxuICByZXR1cm4gYXJyLmZpbHRlcihjaGVjaylbMF07XG59XG4iLCJpbXBvcnQgZmluZCBmcm9tICcuL2ZpbmQnO1xuXG4vKipcbiAqIFJldHVybiB0aGUgaW5kZXggb2YgdGhlIG1hdGNoaW5nIG9iamVjdFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtBcnJheX0gYXJyXG4gKiBAYXJndW1lbnQgcHJvcFxuICogQGFyZ3VtZW50IHZhbHVlXG4gKiBAcmV0dXJucyBpbmRleCBvciAtMVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBmaW5kSW5kZXgoYXJyLCBwcm9wLCB2YWx1ZSkge1xuICAvLyB1c2UgbmF0aXZlIGZpbmRJbmRleCBpZiBzdXBwb3J0ZWRcbiAgaWYgKEFycmF5LnByb3RvdHlwZS5maW5kSW5kZXgpIHtcbiAgICByZXR1cm4gYXJyLmZpbmRJbmRleChjdXIgPT4gY3VyW3Byb3BdID09PSB2YWx1ZSk7XG4gIH1cblxuICAvLyB1c2UgYGZpbmRgICsgYGluZGV4T2ZgIGlmIGBmaW5kSW5kZXhgIGlzbid0IHN1cHBvcnRlZFxuICBjb25zdCBtYXRjaCA9IGZpbmQoYXJyLCBvYmogPT4gb2JqW3Byb3BdID09PSB2YWx1ZSk7XG4gIHJldHVybiBhcnIuaW5kZXhPZihtYXRjaCk7XG59XG4iLCJpbXBvcnQgaXNGdW5jdGlvbiBmcm9tICcuL2lzRnVuY3Rpb24nO1xuaW1wb3J0IGZpbmRJbmRleCBmcm9tICcuL2ZpbmRJbmRleCc7XG5pbXBvcnQgZ2V0Q2xpZW50UmVjdCBmcm9tICcuLi91dGlscy9nZXRDbGllbnRSZWN0JztcblxuLyoqXG4gKiBMb29wIHRyb3VnaCB0aGUgbGlzdCBvZiBtb2RpZmllcnMgYW5kIHJ1biB0aGVtIGluIG9yZGVyLFxuICogZWFjaCBvZiB0aGVtIHdpbGwgdGhlbiBlZGl0IHRoZSBkYXRhIG9iamVjdC5cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBwYXJhbSB7ZGF0YU9iamVjdH0gZGF0YVxuICogQHBhcmFtIHtBcnJheX0gbW9kaWZpZXJzXG4gKiBAcGFyYW0ge1N0cmluZ30gZW5kcyAtIE9wdGlvbmFsIG1vZGlmaWVyIG5hbWUgdXNlZCBhcyBzdG9wcGVyXG4gKiBAcmV0dXJucyB7ZGF0YU9iamVjdH1cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcnVuTW9kaWZpZXJzKG1vZGlmaWVycywgZGF0YSwgZW5kcykge1xuICBjb25zdCBtb2RpZmllcnNUb1J1biA9IGVuZHMgPT09IHVuZGVmaW5lZFxuICAgID8gbW9kaWZpZXJzXG4gICAgOiBtb2RpZmllcnMuc2xpY2UoMCwgZmluZEluZGV4KG1vZGlmaWVycywgJ25hbWUnLCBlbmRzKSk7XG5cbiAgbW9kaWZpZXJzVG9SdW4uZm9yRWFjaChtb2RpZmllciA9PiB7XG4gICAgaWYgKG1vZGlmaWVyWydmdW5jdGlvbiddKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZG90LW5vdGF0aW9uXG4gICAgICBjb25zb2xlLndhcm4oJ2Btb2RpZmllci5mdW5jdGlvbmAgaXMgZGVwcmVjYXRlZCwgdXNlIGBtb2RpZmllci5mbmAhJyk7XG4gICAgfVxuICAgIGNvbnN0IGZuID0gbW9kaWZpZXJbJ2Z1bmN0aW9uJ10gfHwgbW9kaWZpZXIuZm47IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZG90LW5vdGF0aW9uXG4gICAgaWYgKG1vZGlmaWVyLmVuYWJsZWQgJiYgaXNGdW5jdGlvbihmbikpIHtcbiAgICAgIC8vIEFkZCBwcm9wZXJ0aWVzIHRvIG9mZnNldHMgdG8gbWFrZSB0aGVtIGEgY29tcGxldGUgY2xpZW50UmVjdCBvYmplY3RcbiAgICAgIC8vIHdlIGRvIHRoaXMgYmVmb3JlIGVhY2ggbW9kaWZpZXIgdG8gbWFrZSBzdXJlIHRoZSBwcmV2aW91cyBvbmUgZG9lc24ndFxuICAgICAgLy8gbWVzcyB3aXRoIHRoZXNlIHZhbHVlc1xuICAgICAgZGF0YS5vZmZzZXRzLnBvcHBlciA9IGdldENsaWVudFJlY3QoZGF0YS5vZmZzZXRzLnBvcHBlcik7XG4gICAgICBkYXRhLm9mZnNldHMucmVmZXJlbmNlID0gZ2V0Q2xpZW50UmVjdChkYXRhLm9mZnNldHMucmVmZXJlbmNlKTtcblxuICAgICAgZGF0YSA9IGZuKGRhdGEsIG1vZGlmaWVyKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBkYXRhO1xufVxuIiwiaW1wb3J0IGNvbXB1dGVBdXRvUGxhY2VtZW50IGZyb20gJy4uL3V0aWxzL2NvbXB1dGVBdXRvUGxhY2VtZW50JztcbmltcG9ydCBnZXRSZWZlcmVuY2VPZmZzZXRzIGZyb20gJy4uL3V0aWxzL2dldFJlZmVyZW5jZU9mZnNldHMnO1xuaW1wb3J0IGdldFBvcHBlck9mZnNldHMgZnJvbSAnLi4vdXRpbHMvZ2V0UG9wcGVyT2Zmc2V0cyc7XG5pbXBvcnQgcnVuTW9kaWZpZXJzIGZyb20gJy4uL3V0aWxzL3J1bk1vZGlmaWVycyc7XG5cbi8qKlxuICogVXBkYXRlcyB0aGUgcG9zaXRpb24gb2YgdGhlIHBvcHBlciwgY29tcHV0aW5nIHRoZSBuZXcgb2Zmc2V0cyBhbmQgYXBwbHlpbmdcbiAqIHRoZSBuZXcgc3R5bGUuPGJyIC8+XG4gKiBQcmVmZXIgYHNjaGVkdWxlVXBkYXRlYCBvdmVyIGB1cGRhdGVgIGJlY2F1c2Ugb2YgcGVyZm9ybWFuY2UgcmVhc29ucy5cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXJcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdXBkYXRlKCkge1xuICAvLyBpZiBwb3BwZXIgaXMgZGVzdHJveWVkLCBkb24ndCBwZXJmb3JtIGFueSBmdXJ0aGVyIHVwZGF0ZVxuICBpZiAodGhpcy5zdGF0ZS5pc0Rlc3Ryb3llZCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGxldCBkYXRhID0ge1xuICAgIGluc3RhbmNlOiB0aGlzLFxuICAgIHN0eWxlczoge30sXG4gICAgYXJyb3dTdHlsZXM6IHt9LFxuICAgIGF0dHJpYnV0ZXM6IHt9LFxuICAgIGZsaXBwZWQ6IGZhbHNlLFxuICAgIG9mZnNldHM6IHt9LFxuICB9O1xuXG4gIC8vIGNvbXB1dGUgcmVmZXJlbmNlIGVsZW1lbnQgb2Zmc2V0c1xuICBkYXRhLm9mZnNldHMucmVmZXJlbmNlID0gZ2V0UmVmZXJlbmNlT2Zmc2V0cyhcbiAgICB0aGlzLnN0YXRlLFxuICAgIHRoaXMucG9wcGVyLFxuICAgIHRoaXMucmVmZXJlbmNlLFxuICAgIHRoaXMub3B0aW9ucy5wb3NpdGlvbkZpeGVkXG4gICk7XG5cbiAgLy8gY29tcHV0ZSBhdXRvIHBsYWNlbWVudCwgc3RvcmUgcGxhY2VtZW50IGluc2lkZSB0aGUgZGF0YSBvYmplY3QsXG4gIC8vIG1vZGlmaWVycyB3aWxsIGJlIGFibGUgdG8gZWRpdCBgcGxhY2VtZW50YCBpZiBuZWVkZWRcbiAgLy8gYW5kIHJlZmVyIHRvIG9yaWdpbmFsUGxhY2VtZW50IHRvIGtub3cgdGhlIG9yaWdpbmFsIHZhbHVlXG4gIGRhdGEucGxhY2VtZW50ID0gY29tcHV0ZUF1dG9QbGFjZW1lbnQoXG4gICAgdGhpcy5vcHRpb25zLnBsYWNlbWVudCxcbiAgICBkYXRhLm9mZnNldHMucmVmZXJlbmNlLFxuICAgIHRoaXMucG9wcGVyLFxuICAgIHRoaXMucmVmZXJlbmNlLFxuICAgIHRoaXMub3B0aW9ucy5tb2RpZmllcnMuZmxpcC5ib3VuZGFyaWVzRWxlbWVudCxcbiAgICB0aGlzLm9wdGlvbnMubW9kaWZpZXJzLmZsaXAucGFkZGluZ1xuICApO1xuXG4gIC8vIHN0b3JlIHRoZSBjb21wdXRlZCBwbGFjZW1lbnQgaW5zaWRlIGBvcmlnaW5hbFBsYWNlbWVudGBcbiAgZGF0YS5vcmlnaW5hbFBsYWNlbWVudCA9IGRhdGEucGxhY2VtZW50O1xuXG4gIGRhdGEucG9zaXRpb25GaXhlZCA9IHRoaXMub3B0aW9ucy5wb3NpdGlvbkZpeGVkO1xuXG4gIC8vIGNvbXB1dGUgdGhlIHBvcHBlciBvZmZzZXRzXG4gIGRhdGEub2Zmc2V0cy5wb3BwZXIgPSBnZXRQb3BwZXJPZmZzZXRzKFxuICAgIHRoaXMucG9wcGVyLFxuICAgIGRhdGEub2Zmc2V0cy5yZWZlcmVuY2UsXG4gICAgZGF0YS5wbGFjZW1lbnRcbiAgKTtcblxuICBkYXRhLm9mZnNldHMucG9wcGVyLnBvc2l0aW9uID0gdGhpcy5vcHRpb25zLnBvc2l0aW9uRml4ZWRcbiAgICA/ICdmaXhlZCdcbiAgICA6ICdhYnNvbHV0ZSc7XG5cbiAgLy8gcnVuIHRoZSBtb2RpZmllcnNcbiAgZGF0YSA9IHJ1bk1vZGlmaWVycyh0aGlzLm1vZGlmaWVycywgZGF0YSk7XG5cbiAgLy8gdGhlIGZpcnN0IGB1cGRhdGVgIHdpbGwgY2FsbCBgb25DcmVhdGVgIGNhbGxiYWNrXG4gIC8vIHRoZSBvdGhlciBvbmVzIHdpbGwgY2FsbCBgb25VcGRhdGVgIGNhbGxiYWNrXG4gIGlmICghdGhpcy5zdGF0ZS5pc0NyZWF0ZWQpIHtcbiAgICB0aGlzLnN0YXRlLmlzQ3JlYXRlZCA9IHRydWU7XG4gICAgdGhpcy5vcHRpb25zLm9uQ3JlYXRlKGRhdGEpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMub3B0aW9ucy5vblVwZGF0ZShkYXRhKTtcbiAgfVxufVxuIiwiLyoqXG4gKiBIZWxwZXIgdXNlZCB0byBrbm93IGlmIHRoZSBnaXZlbiBtb2RpZmllciBpcyBlbmFibGVkLlxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHJldHVybnMge0Jvb2xlYW59XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGlzTW9kaWZpZXJFbmFibGVkKG1vZGlmaWVycywgbW9kaWZpZXJOYW1lKSB7XG4gIHJldHVybiBtb2RpZmllcnMuc29tZShcbiAgICAoeyBuYW1lLCBlbmFibGVkIH0pID0+IGVuYWJsZWQgJiYgbmFtZSA9PT0gbW9kaWZpZXJOYW1lXG4gICk7XG59XG4iLCIvKipcbiAqIEdldCB0aGUgcHJlZml4ZWQgc3VwcG9ydGVkIHByb3BlcnR5IG5hbWVcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7U3RyaW5nfSBwcm9wZXJ0eSAoY2FtZWxDYXNlKVxuICogQHJldHVybnMge1N0cmluZ30gcHJlZml4ZWQgcHJvcGVydHkgKGNhbWVsQ2FzZSBvciBQYXNjYWxDYXNlLCBkZXBlbmRpbmcgb24gdGhlIHZlbmRvciBwcmVmaXgpXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldFN1cHBvcnRlZFByb3BlcnR5TmFtZShwcm9wZXJ0eSkge1xuICBjb25zdCBwcmVmaXhlcyA9IFtmYWxzZSwgJ21zJywgJ1dlYmtpdCcsICdNb3onLCAnTyddO1xuICBjb25zdCB1cHBlclByb3AgPSBwcm9wZXJ0eS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHByb3BlcnR5LnNsaWNlKDEpO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcHJlZml4ZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBwcmVmaXggPSBwcmVmaXhlc1tpXTtcbiAgICBjb25zdCB0b0NoZWNrID0gcHJlZml4ID8gYCR7cHJlZml4fSR7dXBwZXJQcm9wfWAgOiBwcm9wZXJ0eTtcbiAgICBpZiAodHlwZW9mIGRvY3VtZW50LmJvZHkuc3R5bGVbdG9DaGVja10gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gdG9DaGVjaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG4iLCJpbXBvcnQgaXNNb2RpZmllckVuYWJsZWQgZnJvbSAnLi4vdXRpbHMvaXNNb2RpZmllckVuYWJsZWQnO1xuaW1wb3J0IGdldFN1cHBvcnRlZFByb3BlcnR5TmFtZSBmcm9tICcuLi91dGlscy9nZXRTdXBwb3J0ZWRQcm9wZXJ0eU5hbWUnO1xuXG4vKipcbiAqIERlc3Ryb3lzIHRoZSBwb3BwZXIuXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gIHRoaXMuc3RhdGUuaXNEZXN0cm95ZWQgPSB0cnVlO1xuXG4gIC8vIHRvdWNoIERPTSBvbmx5IGlmIGBhcHBseVN0eWxlYCBtb2RpZmllciBpcyBlbmFibGVkXG4gIGlmIChpc01vZGlmaWVyRW5hYmxlZCh0aGlzLm1vZGlmaWVycywgJ2FwcGx5U3R5bGUnKSkge1xuICAgIHRoaXMucG9wcGVyLnJlbW92ZUF0dHJpYnV0ZSgneC1wbGFjZW1lbnQnKTtcbiAgICB0aGlzLnBvcHBlci5zdHlsZS5wb3NpdGlvbiA9ICcnO1xuICAgIHRoaXMucG9wcGVyLnN0eWxlLnRvcCA9ICcnO1xuICAgIHRoaXMucG9wcGVyLnN0eWxlLmxlZnQgPSAnJztcbiAgICB0aGlzLnBvcHBlci5zdHlsZS5yaWdodCA9ICcnO1xuICAgIHRoaXMucG9wcGVyLnN0eWxlLmJvdHRvbSA9ICcnO1xuICAgIHRoaXMucG9wcGVyLnN0eWxlLndpbGxDaGFuZ2UgPSAnJztcbiAgICB0aGlzLnBvcHBlci5zdHlsZVtnZXRTdXBwb3J0ZWRQcm9wZXJ0eU5hbWUoJ3RyYW5zZm9ybScpXSA9ICcnO1xuICB9XG5cbiAgdGhpcy5kaXNhYmxlRXZlbnRMaXN0ZW5lcnMoKTtcblxuICAvLyByZW1vdmUgdGhlIHBvcHBlciBpZiB1c2VyIGV4cGxpY2l0bHkgYXNrZWQgZm9yIHRoZSBkZWxldGlvbiBvbiBkZXN0cm95XG4gIC8vIGRvIG5vdCB1c2UgYHJlbW92ZWAgYmVjYXVzZSBJRTExIGRvZXNuJ3Qgc3VwcG9ydCBpdFxuICBpZiAodGhpcy5vcHRpb25zLnJlbW92ZU9uRGVzdHJveSkge1xuICAgIHRoaXMucG9wcGVyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5wb3BwZXIpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufVxuIiwiLyoqXG4gKiBHZXQgdGhlIHdpbmRvdyBhc3NvY2lhdGVkIHdpdGggdGhlIGVsZW1lbnRcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gZWxlbWVudFxuICogQHJldHVybnMge1dpbmRvd31cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0V2luZG93KGVsZW1lbnQpIHtcbiAgY29uc3Qgb3duZXJEb2N1bWVudCA9IGVsZW1lbnQub3duZXJEb2N1bWVudDtcbiAgcmV0dXJuIG93bmVyRG9jdW1lbnQgPyBvd25lckRvY3VtZW50LmRlZmF1bHRWaWV3IDogd2luZG93O1xufVxuIiwiaW1wb3J0IGdldFNjcm9sbFBhcmVudCBmcm9tICcuL2dldFNjcm9sbFBhcmVudCc7XG5pbXBvcnQgZ2V0V2luZG93IGZyb20gJy4vZ2V0V2luZG93JztcblxuZnVuY3Rpb24gYXR0YWNoVG9TY3JvbGxQYXJlbnRzKHNjcm9sbFBhcmVudCwgZXZlbnQsIGNhbGxiYWNrLCBzY3JvbGxQYXJlbnRzKSB7XG4gIGNvbnN0IGlzQm9keSA9IHNjcm9sbFBhcmVudC5ub2RlTmFtZSA9PT0gJ0JPRFknO1xuICBjb25zdCB0YXJnZXQgPSBpc0JvZHkgPyBzY3JvbGxQYXJlbnQub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldyA6IHNjcm9sbFBhcmVudDtcbiAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGNhbGxiYWNrLCB7IHBhc3NpdmU6IHRydWUgfSk7XG5cbiAgaWYgKCFpc0JvZHkpIHtcbiAgICBhdHRhY2hUb1Njcm9sbFBhcmVudHMoXG4gICAgICBnZXRTY3JvbGxQYXJlbnQodGFyZ2V0LnBhcmVudE5vZGUpLFxuICAgICAgZXZlbnQsXG4gICAgICBjYWxsYmFjayxcbiAgICAgIHNjcm9sbFBhcmVudHNcbiAgICApO1xuICB9XG4gIHNjcm9sbFBhcmVudHMucHVzaCh0YXJnZXQpO1xufVxuXG4vKipcbiAqIFNldHVwIG5lZWRlZCBldmVudCBsaXN0ZW5lcnMgdXNlZCB0byB1cGRhdGUgdGhlIHBvcHBlciBwb3NpdGlvblxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gc2V0dXBFdmVudExpc3RlbmVycyhcbiAgcmVmZXJlbmNlLFxuICBvcHRpb25zLFxuICBzdGF0ZSxcbiAgdXBkYXRlQm91bmRcbikge1xuICAvLyBSZXNpemUgZXZlbnQgbGlzdGVuZXIgb24gd2luZG93XG4gIHN0YXRlLnVwZGF0ZUJvdW5kID0gdXBkYXRlQm91bmQ7XG4gIGdldFdpbmRvdyhyZWZlcmVuY2UpLmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHN0YXRlLnVwZGF0ZUJvdW5kLCB7IHBhc3NpdmU6IHRydWUgfSk7XG5cbiAgLy8gU2Nyb2xsIGV2ZW50IGxpc3RlbmVyIG9uIHNjcm9sbCBwYXJlbnRzXG4gIGNvbnN0IHNjcm9sbEVsZW1lbnQgPSBnZXRTY3JvbGxQYXJlbnQocmVmZXJlbmNlKTtcbiAgYXR0YWNoVG9TY3JvbGxQYXJlbnRzKFxuICAgIHNjcm9sbEVsZW1lbnQsXG4gICAgJ3Njcm9sbCcsXG4gICAgc3RhdGUudXBkYXRlQm91bmQsXG4gICAgc3RhdGUuc2Nyb2xsUGFyZW50c1xuICApO1xuICBzdGF0ZS5zY3JvbGxFbGVtZW50ID0gc2Nyb2xsRWxlbWVudDtcbiAgc3RhdGUuZXZlbnRzRW5hYmxlZCA9IHRydWU7XG5cbiAgcmV0dXJuIHN0YXRlO1xufVxuIiwiaW1wb3J0IHNldHVwRXZlbnRMaXN0ZW5lcnMgZnJvbSAnLi4vdXRpbHMvc2V0dXBFdmVudExpc3RlbmVycyc7XG5cbi8qKlxuICogSXQgd2lsbCBhZGQgcmVzaXplL3Njcm9sbCBldmVudHMgYW5kIHN0YXJ0IHJlY2FsY3VsYXRpbmdcbiAqIHBvc2l0aW9uIG9mIHRoZSBwb3BwZXIgZWxlbWVudCB3aGVuIHRoZXkgYXJlIHRyaWdnZXJlZC5cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXJcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZW5hYmxlRXZlbnRMaXN0ZW5lcnMoKSB7XG4gIGlmICghdGhpcy5zdGF0ZS5ldmVudHNFbmFibGVkKSB7XG4gICAgdGhpcy5zdGF0ZSA9IHNldHVwRXZlbnRMaXN0ZW5lcnMoXG4gICAgICB0aGlzLnJlZmVyZW5jZSxcbiAgICAgIHRoaXMub3B0aW9ucyxcbiAgICAgIHRoaXMuc3RhdGUsXG4gICAgICB0aGlzLnNjaGVkdWxlVXBkYXRlXG4gICAgKTtcbiAgfVxufVxuIiwiaW1wb3J0IGdldFdpbmRvdyBmcm9tICcuL2dldFdpbmRvdyc7XG5cbi8qKlxuICogUmVtb3ZlIGV2ZW50IGxpc3RlbmVycyB1c2VkIHRvIHVwZGF0ZSB0aGUgcG9wcGVyIHBvc2l0aW9uXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiByZW1vdmVFdmVudExpc3RlbmVycyhyZWZlcmVuY2UsIHN0YXRlKSB7XG4gIC8vIFJlbW92ZSByZXNpemUgZXZlbnQgbGlzdGVuZXIgb24gd2luZG93XG4gIGdldFdpbmRvdyhyZWZlcmVuY2UpLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHN0YXRlLnVwZGF0ZUJvdW5kKTtcblxuICAvLyBSZW1vdmUgc2Nyb2xsIGV2ZW50IGxpc3RlbmVyIG9uIHNjcm9sbCBwYXJlbnRzXG4gIHN0YXRlLnNjcm9sbFBhcmVudHMuZm9yRWFjaCh0YXJnZXQgPT4ge1xuICAgIHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBzdGF0ZS51cGRhdGVCb3VuZCk7XG4gIH0pO1xuXG4gIC8vIFJlc2V0IHN0YXRlXG4gIHN0YXRlLnVwZGF0ZUJvdW5kID0gbnVsbDtcbiAgc3RhdGUuc2Nyb2xsUGFyZW50cyA9IFtdO1xuICBzdGF0ZS5zY3JvbGxFbGVtZW50ID0gbnVsbDtcbiAgc3RhdGUuZXZlbnRzRW5hYmxlZCA9IGZhbHNlO1xuICByZXR1cm4gc3RhdGU7XG59XG4iLCJpbXBvcnQgcmVtb3ZlRXZlbnRMaXN0ZW5lcnMgZnJvbSAnLi4vdXRpbHMvcmVtb3ZlRXZlbnRMaXN0ZW5lcnMnO1xuXG4vKipcbiAqIEl0IHdpbGwgcmVtb3ZlIHJlc2l6ZS9zY3JvbGwgZXZlbnRzIGFuZCB3b24ndCByZWNhbGN1bGF0ZSBwb3BwZXIgcG9zaXRpb25cbiAqIHdoZW4gdGhleSBhcmUgdHJpZ2dlcmVkLiBJdCBhbHNvIHdvbid0IHRyaWdnZXIgYG9uVXBkYXRlYCBjYWxsYmFjayBhbnltb3JlLFxuICogdW5sZXNzIHlvdSBjYWxsIGB1cGRhdGVgIG1ldGhvZCBtYW51YWxseS5cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXJcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZGlzYWJsZUV2ZW50TGlzdGVuZXJzKCkge1xuICBpZiAodGhpcy5zdGF0ZS5ldmVudHNFbmFibGVkKSB7XG4gICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5zY2hlZHVsZVVwZGF0ZSk7XG4gICAgdGhpcy5zdGF0ZSA9IHJlbW92ZUV2ZW50TGlzdGVuZXJzKHRoaXMucmVmZXJlbmNlLCB0aGlzLnN0YXRlKTtcbiAgfVxufVxuIiwiLyoqXG4gKiBUZWxscyBpZiBhIGdpdmVuIGlucHV0IGlzIGEgbnVtYmVyXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcGFyYW0geyp9IGlucHV0IHRvIGNoZWNrXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpc051bWVyaWMobikge1xuICByZXR1cm4gbiAhPT0gJycgJiYgIWlzTmFOKHBhcnNlRmxvYXQobikpICYmIGlzRmluaXRlKG4pO1xufVxuIiwiaW1wb3J0IGlzTnVtZXJpYyBmcm9tICcuL2lzTnVtZXJpYyc7XG5cbi8qKlxuICogU2V0IHRoZSBzdHlsZSB0byB0aGUgZ2l2ZW4gcG9wcGVyXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnQgLSBFbGVtZW50IHRvIGFwcGx5IHRoZSBzdHlsZSB0b1xuICogQGFyZ3VtZW50IHtPYmplY3R9IHN0eWxlc1xuICogT2JqZWN0IHdpdGggYSBsaXN0IG9mIHByb3BlcnRpZXMgYW5kIHZhbHVlcyB3aGljaCB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIGVsZW1lbnRcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gc2V0U3R5bGVzKGVsZW1lbnQsIHN0eWxlcykge1xuICBPYmplY3Qua2V5cyhzdHlsZXMpLmZvckVhY2gocHJvcCA9PiB7XG4gICAgbGV0IHVuaXQgPSAnJztcbiAgICAvLyBhZGQgdW5pdCBpZiB0aGUgdmFsdWUgaXMgbnVtZXJpYyBhbmQgaXMgb25lIG9mIHRoZSBmb2xsb3dpbmdcbiAgICBpZiAoXG4gICAgICBbJ3dpZHRoJywgJ2hlaWdodCcsICd0b3AnLCAncmlnaHQnLCAnYm90dG9tJywgJ2xlZnQnXS5pbmRleE9mKHByb3ApICE9PVxuICAgICAgICAtMSAmJlxuICAgICAgaXNOdW1lcmljKHN0eWxlc1twcm9wXSlcbiAgICApIHtcbiAgICAgIHVuaXQgPSAncHgnO1xuICAgIH1cbiAgICBlbGVtZW50LnN0eWxlW3Byb3BdID0gc3R5bGVzW3Byb3BdICsgdW5pdDtcbiAgfSk7XG59XG4iLCIvKipcbiAqIFNldCB0aGUgYXR0cmlidXRlcyB0byB0aGUgZ2l2ZW4gcG9wcGVyXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnQgLSBFbGVtZW50IHRvIGFwcGx5IHRoZSBhdHRyaWJ1dGVzIHRvXG4gKiBAYXJndW1lbnQge09iamVjdH0gc3R5bGVzXG4gKiBPYmplY3Qgd2l0aCBhIGxpc3Qgb2YgcHJvcGVydGllcyBhbmQgdmFsdWVzIHdoaWNoIHdpbGwgYmUgYXBwbGllZCB0byB0aGUgZWxlbWVudFxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBzZXRBdHRyaWJ1dGVzKGVsZW1lbnQsIGF0dHJpYnV0ZXMpIHtcbiAgT2JqZWN0LmtleXMoYXR0cmlidXRlcykuZm9yRWFjaChmdW5jdGlvbihwcm9wKSB7XG4gICAgY29uc3QgdmFsdWUgPSBhdHRyaWJ1dGVzW3Byb3BdO1xuICAgIGlmICh2YWx1ZSAhPT0gZmFsc2UpIHtcbiAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKHByb3AsIGF0dHJpYnV0ZXNbcHJvcF0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShwcm9wKTtcbiAgICB9XG4gIH0pO1xufVxuIiwiaW1wb3J0IHNldFN0eWxlcyBmcm9tICcuLi91dGlscy9zZXRTdHlsZXMnO1xuaW1wb3J0IHNldEF0dHJpYnV0ZXMgZnJvbSAnLi4vdXRpbHMvc2V0QXR0cmlidXRlcyc7XG5pbXBvcnQgZ2V0UmVmZXJlbmNlT2Zmc2V0cyBmcm9tICcuLi91dGlscy9nZXRSZWZlcmVuY2VPZmZzZXRzJztcbmltcG9ydCBjb21wdXRlQXV0b1BsYWNlbWVudCBmcm9tICcuLi91dGlscy9jb21wdXRlQXV0b1BsYWNlbWVudCc7XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YgTW9kaWZpZXJzXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgYHVwZGF0ZWAgbWV0aG9kXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YS5zdHlsZXMgLSBMaXN0IG9mIHN0eWxlIHByb3BlcnRpZXMgLSB2YWx1ZXMgdG8gYXBwbHkgdG8gcG9wcGVyIGVsZW1lbnRcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhLmF0dHJpYnV0ZXMgLSBMaXN0IG9mIGF0dHJpYnV0ZSBwcm9wZXJ0aWVzIC0gdmFsdWVzIHRvIGFwcGx5IHRvIHBvcHBlciBlbGVtZW50XG4gKiBAYXJndW1lbnQge09iamVjdH0gb3B0aW9ucyAtIE1vZGlmaWVycyBjb25maWd1cmF0aW9uIGFuZCBvcHRpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgc2FtZSBkYXRhIG9iamVjdFxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBhcHBseVN0eWxlKGRhdGEpIHtcbiAgLy8gYW55IHByb3BlcnR5IHByZXNlbnQgaW4gYGRhdGEuc3R5bGVzYCB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIHBvcHBlcixcbiAgLy8gaW4gdGhpcyB3YXkgd2UgY2FuIG1ha2UgdGhlIDNyZCBwYXJ0eSBtb2RpZmllcnMgYWRkIGN1c3RvbSBzdHlsZXMgdG8gaXRcbiAgLy8gQmUgYXdhcmUsIG1vZGlmaWVycyBjb3VsZCBvdmVycmlkZSB0aGUgcHJvcGVydGllcyBkZWZpbmVkIGluIHRoZSBwcmV2aW91c1xuICAvLyBsaW5lcyBvZiB0aGlzIG1vZGlmaWVyIVxuICBzZXRTdHlsZXMoZGF0YS5pbnN0YW5jZS5wb3BwZXIsIGRhdGEuc3R5bGVzKTtcblxuICAvLyBhbnkgcHJvcGVydHkgcHJlc2VudCBpbiBgZGF0YS5hdHRyaWJ1dGVzYCB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIHBvcHBlcixcbiAgLy8gdGhleSB3aWxsIGJlIHNldCBhcyBIVE1MIGF0dHJpYnV0ZXMgb2YgdGhlIGVsZW1lbnRcbiAgc2V0QXR0cmlidXRlcyhkYXRhLmluc3RhbmNlLnBvcHBlciwgZGF0YS5hdHRyaWJ1dGVzKTtcblxuICAvLyBpZiBhcnJvd0VsZW1lbnQgaXMgZGVmaW5lZCBhbmQgYXJyb3dTdHlsZXMgaGFzIHNvbWUgcHJvcGVydGllc1xuICBpZiAoZGF0YS5hcnJvd0VsZW1lbnQgJiYgT2JqZWN0LmtleXMoZGF0YS5hcnJvd1N0eWxlcykubGVuZ3RoKSB7XG4gICAgc2V0U3R5bGVzKGRhdGEuYXJyb3dFbGVtZW50LCBkYXRhLmFycm93U3R5bGVzKTtcbiAgfVxuXG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIFNldCB0aGUgeC1wbGFjZW1lbnQgYXR0cmlidXRlIGJlZm9yZSBldmVyeXRoaW5nIGVsc2UgYmVjYXVzZSBpdCBjb3VsZCBiZSB1c2VkXG4gKiB0byBhZGQgbWFyZ2lucyB0byB0aGUgcG9wcGVyIG1hcmdpbnMgbmVlZHMgdG8gYmUgY2FsY3VsYXRlZCB0byBnZXQgdGhlXG4gKiBjb3JyZWN0IHBvcHBlciBvZmZzZXRzLlxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5tb2RpZmllcnNcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHJlZmVyZW5jZSAtIFRoZSByZWZlcmVuY2UgZWxlbWVudCB1c2VkIHRvIHBvc2l0aW9uIHRoZSBwb3BwZXJcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHBvcHBlciAtIFRoZSBIVE1MIGVsZW1lbnQgdXNlZCBhcyBwb3BwZXJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gUG9wcGVyLmpzIG9wdGlvbnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFwcGx5U3R5bGVPbkxvYWQoXG4gIHJlZmVyZW5jZSxcbiAgcG9wcGVyLFxuICBvcHRpb25zLFxuICBtb2RpZmllck9wdGlvbnMsXG4gIHN0YXRlXG4pIHtcbiAgLy8gY29tcHV0ZSByZWZlcmVuY2UgZWxlbWVudCBvZmZzZXRzXG4gIGNvbnN0IHJlZmVyZW5jZU9mZnNldHMgPSBnZXRSZWZlcmVuY2VPZmZzZXRzKHN0YXRlLCBwb3BwZXIsIHJlZmVyZW5jZSwgb3B0aW9ucy5wb3NpdGlvbkZpeGVkKTtcblxuICAvLyBjb21wdXRlIGF1dG8gcGxhY2VtZW50LCBzdG9yZSBwbGFjZW1lbnQgaW5zaWRlIHRoZSBkYXRhIG9iamVjdCxcbiAgLy8gbW9kaWZpZXJzIHdpbGwgYmUgYWJsZSB0byBlZGl0IGBwbGFjZW1lbnRgIGlmIG5lZWRlZFxuICAvLyBhbmQgcmVmZXIgdG8gb3JpZ2luYWxQbGFjZW1lbnQgdG8ga25vdyB0aGUgb3JpZ2luYWwgdmFsdWVcbiAgY29uc3QgcGxhY2VtZW50ID0gY29tcHV0ZUF1dG9QbGFjZW1lbnQoXG4gICAgb3B0aW9ucy5wbGFjZW1lbnQsXG4gICAgcmVmZXJlbmNlT2Zmc2V0cyxcbiAgICBwb3BwZXIsXG4gICAgcmVmZXJlbmNlLFxuICAgIG9wdGlvbnMubW9kaWZpZXJzLmZsaXAuYm91bmRhcmllc0VsZW1lbnQsXG4gICAgb3B0aW9ucy5tb2RpZmllcnMuZmxpcC5wYWRkaW5nXG4gICk7XG5cbiAgcG9wcGVyLnNldEF0dHJpYnV0ZSgneC1wbGFjZW1lbnQnLCBwbGFjZW1lbnQpO1xuXG4gIC8vIEFwcGx5IGBwb3NpdGlvbmAgdG8gcG9wcGVyIGJlZm9yZSBhbnl0aGluZyBlbHNlIGJlY2F1c2VcbiAgLy8gd2l0aG91dCB0aGUgcG9zaXRpb24gYXBwbGllZCB3ZSBjYW4ndCBndWFyYW50ZWUgY29ycmVjdCBjb21wdXRhdGlvbnNcbiAgc2V0U3R5bGVzKHBvcHBlciwgeyBwb3NpdGlvbjogb3B0aW9ucy5wb3NpdGlvbkZpeGVkID8gJ2ZpeGVkJyA6ICdhYnNvbHV0ZScgfSk7XG5cbiAgcmV0dXJuIG9wdGlvbnM7XG59XG4iLCIvKipcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IGB1cGRhdGVgIG1ldGhvZFxuICogQGFyZ3VtZW50IHtCb29sZWFufSBzaG91bGRSb3VuZCAtIElmIHRoZSBvZmZzZXRzIHNob3VsZCBiZSByb3VuZGVkIGF0IGFsbFxuICogQHJldHVybnMge09iamVjdH0gVGhlIHBvcHBlcidzIHBvc2l0aW9uIG9mZnNldHMgcm91bmRlZFxuICpcbiAqIFRoZSB0YWxlIG9mIHBpeGVsLXBlcmZlY3QgcG9zaXRpb25pbmcuIEl0J3Mgc3RpbGwgbm90IDEwMCUgcGVyZmVjdCwgYnV0IGFzXG4gKiBnb29kIGFzIGl0IGNhbiBiZSB3aXRoaW4gcmVhc29uLlxuICogRGlzY3Vzc2lvbiBoZXJlOiBodHRwczovL2dpdGh1Yi5jb20vRmV6VnJhc3RhL3BvcHBlci5qcy9wdWxsLzcxNVxuICpcbiAqIExvdyBEUEkgc2NyZWVucyBjYXVzZSBhIHBvcHBlciB0byBiZSBibHVycnkgaWYgbm90IHVzaW5nIGZ1bGwgcGl4ZWxzIChTYWZhcmlcbiAqIGFzIHdlbGwgb24gSGlnaCBEUEkgc2NyZWVucykuXG4gKlxuICogRmlyZWZveCBwcmVmZXJzIG5vIHJvdW5kaW5nIGZvciBwb3NpdGlvbmluZyBhbmQgZG9lcyBub3QgaGF2ZSBibHVycmluZXNzIG9uXG4gKiBoaWdoIERQSSBzY3JlZW5zLlxuICpcbiAqIE9ubHkgaG9yaXpvbnRhbCBwbGFjZW1lbnQgYW5kIGxlZnQvcmlnaHQgdmFsdWVzIG5lZWQgdG8gYmUgY29uc2lkZXJlZC5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0Um91bmRlZE9mZnNldHMoZGF0YSwgc2hvdWxkUm91bmQpIHtcbiAgY29uc3QgeyBwb3BwZXIsIHJlZmVyZW5jZSB9ID0gZGF0YS5vZmZzZXRzO1xuICBjb25zdCB7IHJvdW5kLCBmbG9vciB9ID0gTWF0aDtcbiAgY29uc3Qgbm9Sb3VuZCA9IHYgPT4gdjtcbiAgXG4gIGNvbnN0IHJlZmVyZW5jZVdpZHRoID0gcm91bmQocmVmZXJlbmNlLndpZHRoKTtcbiAgY29uc3QgcG9wcGVyV2lkdGggPSByb3VuZChwb3BwZXIud2lkdGgpO1xuICBcbiAgY29uc3QgaXNWZXJ0aWNhbCA9IFsnbGVmdCcsICdyaWdodCddLmluZGV4T2YoZGF0YS5wbGFjZW1lbnQpICE9PSAtMTtcbiAgY29uc3QgaXNWYXJpYXRpb24gPSBkYXRhLnBsYWNlbWVudC5pbmRleE9mKCctJykgIT09IC0xO1xuICBjb25zdCBzYW1lV2lkdGhQYXJpdHkgPSByZWZlcmVuY2VXaWR0aCAlIDIgPT09IHBvcHBlcldpZHRoICUgMjtcbiAgY29uc3QgYm90aE9kZFdpZHRoID0gcmVmZXJlbmNlV2lkdGggJSAyID09PSAxICYmIHBvcHBlcldpZHRoICUgMiA9PT0gMTtcblxuICBjb25zdCBob3Jpem9udGFsVG9JbnRlZ2VyID0gIXNob3VsZFJvdW5kXG4gICAgPyBub1JvdW5kXG4gICAgOiBpc1ZlcnRpY2FsIHx8IGlzVmFyaWF0aW9uIHx8IHNhbWVXaWR0aFBhcml0eVxuICAgID8gcm91bmRcbiAgICA6IGZsb29yO1xuICBjb25zdCB2ZXJ0aWNhbFRvSW50ZWdlciA9ICFzaG91bGRSb3VuZCA/IG5vUm91bmQgOiByb3VuZDtcblxuICByZXR1cm4ge1xuICAgIGxlZnQ6IGhvcml6b250YWxUb0ludGVnZXIoXG4gICAgICBib3RoT2RkV2lkdGggJiYgIWlzVmFyaWF0aW9uICYmIHNob3VsZFJvdW5kXG4gICAgICAgID8gcG9wcGVyLmxlZnQgLSAxXG4gICAgICAgIDogcG9wcGVyLmxlZnRcbiAgICApLFxuICAgIHRvcDogdmVydGljYWxUb0ludGVnZXIocG9wcGVyLnRvcCksXG4gICAgYm90dG9tOiB2ZXJ0aWNhbFRvSW50ZWdlcihwb3BwZXIuYm90dG9tKSxcbiAgICByaWdodDogaG9yaXpvbnRhbFRvSW50ZWdlcihwb3BwZXIucmlnaHQpLFxuICB9O1xufVxuIiwiaW1wb3J0IGdldFN1cHBvcnRlZFByb3BlcnR5TmFtZSBmcm9tICcuLi91dGlscy9nZXRTdXBwb3J0ZWRQcm9wZXJ0eU5hbWUnO1xuaW1wb3J0IGZpbmQgZnJvbSAnLi4vdXRpbHMvZmluZCc7XG5pbXBvcnQgZ2V0T2Zmc2V0UGFyZW50IGZyb20gJy4uL3V0aWxzL2dldE9mZnNldFBhcmVudCc7XG5pbXBvcnQgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IGZyb20gJy4uL3V0aWxzL2dldEJvdW5kaW5nQ2xpZW50UmVjdCc7XG5pbXBvcnQgZ2V0Um91bmRlZE9mZnNldHMgZnJvbSAnLi4vdXRpbHMvZ2V0Um91bmRlZE9mZnNldHMnO1xuaW1wb3J0IGlzQnJvd3NlciBmcm9tICcuLi91dGlscy9pc0Jyb3dzZXInO1xuXG5jb25zdCBpc0ZpcmVmb3ggPSBpc0Jyb3dzZXIgJiYgL0ZpcmVmb3gvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIE1vZGlmaWVyc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IGB1cGRhdGVgIG1ldGhvZFxuICogQGFyZ3VtZW50IHtPYmplY3R9IG9wdGlvbnMgLSBNb2RpZmllcnMgY29uZmlndXJhdGlvbiBhbmQgb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdH0gVGhlIGRhdGEgb2JqZWN0LCBwcm9wZXJseSBtb2RpZmllZFxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjb21wdXRlU3R5bGUoZGF0YSwgb3B0aW9ucykge1xuICBjb25zdCB7IHgsIHkgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IHsgcG9wcGVyIH0gPSBkYXRhLm9mZnNldHM7XG5cbiAgLy8gUmVtb3ZlIHRoaXMgbGVnYWN5IHN1cHBvcnQgaW4gUG9wcGVyLmpzIHYyXG4gIGNvbnN0IGxlZ2FjeUdwdUFjY2VsZXJhdGlvbk9wdGlvbiA9IGZpbmQoXG4gICAgZGF0YS5pbnN0YW5jZS5tb2RpZmllcnMsXG4gICAgbW9kaWZpZXIgPT4gbW9kaWZpZXIubmFtZSA9PT0gJ2FwcGx5U3R5bGUnXG4gICkuZ3B1QWNjZWxlcmF0aW9uO1xuICBpZiAobGVnYWN5R3B1QWNjZWxlcmF0aW9uT3B0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICBjb25zb2xlLndhcm4oXG4gICAgICAnV0FSTklORzogYGdwdUFjY2VsZXJhdGlvbmAgb3B0aW9uIG1vdmVkIHRvIGBjb21wdXRlU3R5bGVgIG1vZGlmaWVyIGFuZCB3aWxsIG5vdCBiZSBzdXBwb3J0ZWQgaW4gZnV0dXJlIHZlcnNpb25zIG9mIFBvcHBlci5qcyEnXG4gICAgKTtcbiAgfVxuICBjb25zdCBncHVBY2NlbGVyYXRpb24gPVxuICAgIGxlZ2FjeUdwdUFjY2VsZXJhdGlvbk9wdGlvbiAhPT0gdW5kZWZpbmVkXG4gICAgICA/IGxlZ2FjeUdwdUFjY2VsZXJhdGlvbk9wdGlvblxuICAgICAgOiBvcHRpb25zLmdwdUFjY2VsZXJhdGlvbjtcblxuICBjb25zdCBvZmZzZXRQYXJlbnQgPSBnZXRPZmZzZXRQYXJlbnQoZGF0YS5pbnN0YW5jZS5wb3BwZXIpO1xuICBjb25zdCBvZmZzZXRQYXJlbnRSZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KG9mZnNldFBhcmVudCk7XG5cbiAgLy8gU3R5bGVzXG4gIGNvbnN0IHN0eWxlcyA9IHtcbiAgICBwb3NpdGlvbjogcG9wcGVyLnBvc2l0aW9uLFxuICB9O1xuXG4gIGNvbnN0IG9mZnNldHMgPSBnZXRSb3VuZGVkT2Zmc2V0cyhcbiAgICBkYXRhLFxuICAgIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIDwgMiB8fCAhaXNGaXJlZm94XG4gICk7XG5cbiAgY29uc3Qgc2lkZUEgPSB4ID09PSAnYm90dG9tJyA/ICd0b3AnIDogJ2JvdHRvbSc7XG4gIGNvbnN0IHNpZGVCID0geSA9PT0gJ3JpZ2h0JyA/ICdsZWZ0JyA6ICdyaWdodCc7XG5cbiAgLy8gaWYgZ3B1QWNjZWxlcmF0aW9uIGlzIHNldCB0byBgdHJ1ZWAgYW5kIHRyYW5zZm9ybSBpcyBzdXBwb3J0ZWQsXG4gIC8vICB3ZSB1c2UgYHRyYW5zbGF0ZTNkYCB0byBhcHBseSB0aGUgcG9zaXRpb24gdG8gdGhlIHBvcHBlciB3ZVxuICAvLyBhdXRvbWF0aWNhbGx5IHVzZSB0aGUgc3VwcG9ydGVkIHByZWZpeGVkIHZlcnNpb24gaWYgbmVlZGVkXG4gIGNvbnN0IHByZWZpeGVkUHJvcGVydHkgPSBnZXRTdXBwb3J0ZWRQcm9wZXJ0eU5hbWUoJ3RyYW5zZm9ybScpO1xuXG4gIC8vIG5vdywgbGV0J3MgbWFrZSBhIHN0ZXAgYmFjayBhbmQgbG9vayBhdCB0aGlzIGNvZGUgY2xvc2VseSAod3RmPylcbiAgLy8gSWYgdGhlIGNvbnRlbnQgb2YgdGhlIHBvcHBlciBncm93cyBvbmNlIGl0J3MgYmVlbiBwb3NpdGlvbmVkLCBpdFxuICAvLyBtYXkgaGFwcGVuIHRoYXQgdGhlIHBvcHBlciBnZXRzIG1pc3BsYWNlZCBiZWNhdXNlIG9mIHRoZSBuZXcgY29udGVudFxuICAvLyBvdmVyZmxvd2luZyBpdHMgcmVmZXJlbmNlIGVsZW1lbnRcbiAgLy8gVG8gYXZvaWQgdGhpcyBwcm9ibGVtLCB3ZSBwcm92aWRlIHR3byBvcHRpb25zICh4IGFuZCB5KSwgd2hpY2ggYWxsb3dcbiAgLy8gdGhlIGNvbnN1bWVyIHRvIGRlZmluZSB0aGUgb2Zmc2V0IG9yaWdpbi5cbiAgLy8gSWYgd2UgcG9zaXRpb24gYSBwb3BwZXIgb24gdG9wIG9mIGEgcmVmZXJlbmNlIGVsZW1lbnQsIHdlIGNhbiBzZXRcbiAgLy8gYHhgIHRvIGB0b3BgIHRvIG1ha2UgdGhlIHBvcHBlciBncm93IHRvd2FyZHMgaXRzIHRvcCBpbnN0ZWFkIG9mXG4gIC8vIGl0cyBib3R0b20uXG4gIGxldCBsZWZ0LCB0b3A7XG4gIGlmIChzaWRlQSA9PT0gJ2JvdHRvbScpIHtcbiAgICAvLyB3aGVuIG9mZnNldFBhcmVudCBpcyA8aHRtbD4gdGhlIHBvc2l0aW9uaW5nIGlzIHJlbGF0aXZlIHRvIHRoZSBib3R0b20gb2YgdGhlIHNjcmVlbiAoZXhjbHVkaW5nIHRoZSBzY3JvbGxiYXIpXG4gICAgLy8gYW5kIG5vdCB0aGUgYm90dG9tIG9mIHRoZSBodG1sIGVsZW1lbnRcbiAgICBpZiAob2Zmc2V0UGFyZW50Lm5vZGVOYW1lID09PSAnSFRNTCcpIHtcbiAgICAgIHRvcCA9IC1vZmZzZXRQYXJlbnQuY2xpZW50SGVpZ2h0ICsgb2Zmc2V0cy5ib3R0b207XG4gICAgfSBlbHNlIHtcbiAgICAgIHRvcCA9IC1vZmZzZXRQYXJlbnRSZWN0LmhlaWdodCArIG9mZnNldHMuYm90dG9tO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0b3AgPSBvZmZzZXRzLnRvcDtcbiAgfVxuICBpZiAoc2lkZUIgPT09ICdyaWdodCcpIHtcbiAgICBpZiAob2Zmc2V0UGFyZW50Lm5vZGVOYW1lID09PSAnSFRNTCcpIHtcbiAgICAgIGxlZnQgPSAtb2Zmc2V0UGFyZW50LmNsaWVudFdpZHRoICsgb2Zmc2V0cy5yaWdodDtcbiAgICB9IGVsc2Uge1xuICAgICAgbGVmdCA9IC1vZmZzZXRQYXJlbnRSZWN0LndpZHRoICsgb2Zmc2V0cy5yaWdodDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbGVmdCA9IG9mZnNldHMubGVmdDtcbiAgfVxuICBpZiAoZ3B1QWNjZWxlcmF0aW9uICYmIHByZWZpeGVkUHJvcGVydHkpIHtcbiAgICBzdHlsZXNbcHJlZml4ZWRQcm9wZXJ0eV0gPSBgdHJhbnNsYXRlM2QoJHtsZWZ0fXB4LCAke3RvcH1weCwgMClgO1xuICAgIHN0eWxlc1tzaWRlQV0gPSAwO1xuICAgIHN0eWxlc1tzaWRlQl0gPSAwO1xuICAgIHN0eWxlcy53aWxsQ2hhbmdlID0gJ3RyYW5zZm9ybSc7XG4gIH0gZWxzZSB7XG4gICAgLy8gb3Rod2VyaXNlLCB3ZSB1c2UgdGhlIHN0YW5kYXJkIGB0b3BgLCBgbGVmdGAsIGBib3R0b21gIGFuZCBgcmlnaHRgIHByb3BlcnRpZXNcbiAgICBjb25zdCBpbnZlcnRUb3AgPSBzaWRlQSA9PT0gJ2JvdHRvbScgPyAtMSA6IDE7XG4gICAgY29uc3QgaW52ZXJ0TGVmdCA9IHNpZGVCID09PSAncmlnaHQnID8gLTEgOiAxO1xuICAgIHN0eWxlc1tzaWRlQV0gPSB0b3AgKiBpbnZlcnRUb3A7XG4gICAgc3R5bGVzW3NpZGVCXSA9IGxlZnQgKiBpbnZlcnRMZWZ0O1xuICAgIHN0eWxlcy53aWxsQ2hhbmdlID0gYCR7c2lkZUF9LCAke3NpZGVCfWA7XG4gIH1cblxuICAvLyBBdHRyaWJ1dGVzXG4gIGNvbnN0IGF0dHJpYnV0ZXMgPSB7XG4gICAgJ3gtcGxhY2VtZW50JzogZGF0YS5wbGFjZW1lbnQsXG4gIH07XG5cbiAgLy8gVXBkYXRlIGBkYXRhYCBhdHRyaWJ1dGVzLCBzdHlsZXMgYW5kIGFycm93U3R5bGVzXG4gIGRhdGEuYXR0cmlidXRlcyA9IHsgLi4uYXR0cmlidXRlcywgLi4uZGF0YS5hdHRyaWJ1dGVzIH07XG4gIGRhdGEuc3R5bGVzID0geyAuLi5zdHlsZXMsIC4uLmRhdGEuc3R5bGVzIH07XG4gIGRhdGEuYXJyb3dTdHlsZXMgPSB7IC4uLmRhdGEub2Zmc2V0cy5hcnJvdywgLi4uZGF0YS5hcnJvd1N0eWxlcyB9O1xuXG4gIHJldHVybiBkYXRhO1xufVxuIiwiaW1wb3J0IGZpbmQgZnJvbSAnLi9maW5kJztcblxuLyoqXG4gKiBIZWxwZXIgdXNlZCB0byBrbm93IGlmIHRoZSBnaXZlbiBtb2RpZmllciBkZXBlbmRzIGZyb20gYW5vdGhlciBvbmUuPGJyIC8+XG4gKiBJdCBjaGVja3MgaWYgdGhlIG5lZWRlZCBtb2RpZmllciBpcyBsaXN0ZWQgYW5kIGVuYWJsZWQuXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcGFyYW0ge0FycmF5fSBtb2RpZmllcnMgLSBsaXN0IG9mIG1vZGlmaWVyc1xuICogQHBhcmFtIHtTdHJpbmd9IHJlcXVlc3RpbmdOYW1lIC0gbmFtZSBvZiByZXF1ZXN0aW5nIG1vZGlmaWVyXG4gKiBAcGFyYW0ge1N0cmluZ30gcmVxdWVzdGVkTmFtZSAtIG5hbWUgb2YgcmVxdWVzdGVkIG1vZGlmaWVyXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaXNNb2RpZmllclJlcXVpcmVkKFxuICBtb2RpZmllcnMsXG4gIHJlcXVlc3RpbmdOYW1lLFxuICByZXF1ZXN0ZWROYW1lXG4pIHtcbiAgY29uc3QgcmVxdWVzdGluZyA9IGZpbmQobW9kaWZpZXJzLCAoeyBuYW1lIH0pID0+IG5hbWUgPT09IHJlcXVlc3RpbmdOYW1lKTtcblxuICBjb25zdCBpc1JlcXVpcmVkID1cbiAgICAhIXJlcXVlc3RpbmcgJiZcbiAgICBtb2RpZmllcnMuc29tZShtb2RpZmllciA9PiB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICBtb2RpZmllci5uYW1lID09PSByZXF1ZXN0ZWROYW1lICYmXG4gICAgICAgIG1vZGlmaWVyLmVuYWJsZWQgJiZcbiAgICAgICAgbW9kaWZpZXIub3JkZXIgPCByZXF1ZXN0aW5nLm9yZGVyXG4gICAgICApO1xuICAgIH0pO1xuXG4gIGlmICghaXNSZXF1aXJlZCkge1xuICAgIGNvbnN0IHJlcXVlc3RpbmcgPSBgXFxgJHtyZXF1ZXN0aW5nTmFtZX1cXGBgO1xuICAgIGNvbnN0IHJlcXVlc3RlZCA9IGBcXGAke3JlcXVlc3RlZE5hbWV9XFxgYDtcbiAgICBjb25zb2xlLndhcm4oXG4gICAgICBgJHtyZXF1ZXN0ZWR9IG1vZGlmaWVyIGlzIHJlcXVpcmVkIGJ5ICR7cmVxdWVzdGluZ30gbW9kaWZpZXIgaW4gb3JkZXIgdG8gd29yaywgYmUgc3VyZSB0byBpbmNsdWRlIGl0IGJlZm9yZSAke3JlcXVlc3Rpbmd9IWBcbiAgICApO1xuICB9XG4gIHJldHVybiBpc1JlcXVpcmVkO1xufVxuIiwiaW1wb3J0IGdldENsaWVudFJlY3QgZnJvbSAnLi4vdXRpbHMvZ2V0Q2xpZW50UmVjdCc7XG5pbXBvcnQgZ2V0T3V0ZXJTaXplcyBmcm9tICcuLi91dGlscy9nZXRPdXRlclNpemVzJztcbmltcG9ydCBpc01vZGlmaWVyUmVxdWlyZWQgZnJvbSAnLi4vdXRpbHMvaXNNb2RpZmllclJlcXVpcmVkJztcbmltcG9ydCBnZXRTdHlsZUNvbXB1dGVkUHJvcGVydHkgZnJvbSAnLi4vdXRpbHMvZ2V0U3R5bGVDb21wdXRlZFByb3BlcnR5JztcblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiBNb2RpZmllcnNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSB1cGRhdGUgbWV0aG9kXG4gKiBAYXJndW1lbnQge09iamVjdH0gb3B0aW9ucyAtIE1vZGlmaWVycyBjb25maWd1cmF0aW9uIGFuZCBvcHRpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgZGF0YSBvYmplY3QsIHByb3Blcmx5IG1vZGlmaWVkXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGFycm93KGRhdGEsIG9wdGlvbnMpIHtcbiAgLy8gYXJyb3cgZGVwZW5kcyBvbiBrZWVwVG9nZXRoZXIgaW4gb3JkZXIgdG8gd29ya1xuICBpZiAoIWlzTW9kaWZpZXJSZXF1aXJlZChkYXRhLmluc3RhbmNlLm1vZGlmaWVycywgJ2Fycm93JywgJ2tlZXBUb2dldGhlcicpKSB7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cblxuICBsZXQgYXJyb3dFbGVtZW50ID0gb3B0aW9ucy5lbGVtZW50O1xuXG4gIC8vIGlmIGFycm93RWxlbWVudCBpcyBhIHN0cmluZywgc3VwcG9zZSBpdCdzIGEgQ1NTIHNlbGVjdG9yXG4gIGlmICh0eXBlb2YgYXJyb3dFbGVtZW50ID09PSAnc3RyaW5nJykge1xuICAgIGFycm93RWxlbWVudCA9IGRhdGEuaW5zdGFuY2UucG9wcGVyLnF1ZXJ5U2VsZWN0b3IoYXJyb3dFbGVtZW50KTtcblxuICAgIC8vIGlmIGFycm93RWxlbWVudCBpcyBub3QgZm91bmQsIGRvbid0IHJ1biB0aGUgbW9kaWZpZXJcbiAgICBpZiAoIWFycm93RWxlbWVudCkge1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIGlmIHRoZSBhcnJvd0VsZW1lbnQgaXNuJ3QgYSBxdWVyeSBzZWxlY3RvciB3ZSBtdXN0IGNoZWNrIHRoYXQgdGhlXG4gICAgLy8gcHJvdmlkZWQgRE9NIG5vZGUgaXMgY2hpbGQgb2YgaXRzIHBvcHBlciBub2RlXG4gICAgaWYgKCFkYXRhLmluc3RhbmNlLnBvcHBlci5jb250YWlucyhhcnJvd0VsZW1lbnQpKSB7XG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICdXQVJOSU5HOiBgYXJyb3cuZWxlbWVudGAgbXVzdCBiZSBjaGlsZCBvZiBpdHMgcG9wcGVyIGVsZW1lbnQhJ1xuICAgICAgKTtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHBsYWNlbWVudCA9IGRhdGEucGxhY2VtZW50LnNwbGl0KCctJylbMF07XG4gIGNvbnN0IHsgcG9wcGVyLCByZWZlcmVuY2UgfSA9IGRhdGEub2Zmc2V0cztcbiAgY29uc3QgaXNWZXJ0aWNhbCA9IFsnbGVmdCcsICdyaWdodCddLmluZGV4T2YocGxhY2VtZW50KSAhPT0gLTE7XG5cbiAgY29uc3QgbGVuID0gaXNWZXJ0aWNhbCA/ICdoZWlnaHQnIDogJ3dpZHRoJztcbiAgY29uc3Qgc2lkZUNhcGl0YWxpemVkID0gaXNWZXJ0aWNhbCA/ICdUb3AnIDogJ0xlZnQnO1xuICBjb25zdCBzaWRlID0gc2lkZUNhcGl0YWxpemVkLnRvTG93ZXJDYXNlKCk7XG4gIGNvbnN0IGFsdFNpZGUgPSBpc1ZlcnRpY2FsID8gJ2xlZnQnIDogJ3RvcCc7XG4gIGNvbnN0IG9wU2lkZSA9IGlzVmVydGljYWwgPyAnYm90dG9tJyA6ICdyaWdodCc7XG4gIGNvbnN0IGFycm93RWxlbWVudFNpemUgPSBnZXRPdXRlclNpemVzKGFycm93RWxlbWVudClbbGVuXTtcblxuICAvL1xuICAvLyBleHRlbmRzIGtlZXBUb2dldGhlciBiZWhhdmlvciBtYWtpbmcgc3VyZSB0aGUgcG9wcGVyIGFuZCBpdHNcbiAgLy8gcmVmZXJlbmNlIGhhdmUgZW5vdWdoIHBpeGVscyBpbiBjb25qdW5jdGlvblxuICAvL1xuXG4gIC8vIHRvcC9sZWZ0IHNpZGVcbiAgaWYgKHJlZmVyZW5jZVtvcFNpZGVdIC0gYXJyb3dFbGVtZW50U2l6ZSA8IHBvcHBlcltzaWRlXSkge1xuICAgIGRhdGEub2Zmc2V0cy5wb3BwZXJbc2lkZV0gLT1cbiAgICAgIHBvcHBlcltzaWRlXSAtIChyZWZlcmVuY2Vbb3BTaWRlXSAtIGFycm93RWxlbWVudFNpemUpO1xuICB9XG4gIC8vIGJvdHRvbS9yaWdodCBzaWRlXG4gIGlmIChyZWZlcmVuY2Vbc2lkZV0gKyBhcnJvd0VsZW1lbnRTaXplID4gcG9wcGVyW29wU2lkZV0pIHtcbiAgICBkYXRhLm9mZnNldHMucG9wcGVyW3NpZGVdICs9XG4gICAgICByZWZlcmVuY2Vbc2lkZV0gKyBhcnJvd0VsZW1lbnRTaXplIC0gcG9wcGVyW29wU2lkZV07XG4gIH1cbiAgZGF0YS5vZmZzZXRzLnBvcHBlciA9IGdldENsaWVudFJlY3QoZGF0YS5vZmZzZXRzLnBvcHBlcik7XG5cbiAgLy8gY29tcHV0ZSBjZW50ZXIgb2YgdGhlIHBvcHBlclxuICBjb25zdCBjZW50ZXIgPSByZWZlcmVuY2Vbc2lkZV0gKyByZWZlcmVuY2VbbGVuXSAvIDIgLSBhcnJvd0VsZW1lbnRTaXplIC8gMjtcblxuICAvLyBDb21wdXRlIHRoZSBzaWRlVmFsdWUgdXNpbmcgdGhlIHVwZGF0ZWQgcG9wcGVyIG9mZnNldHNcbiAgLy8gdGFrZSBwb3BwZXIgbWFyZ2luIGluIGFjY291bnQgYmVjYXVzZSB3ZSBkb24ndCBoYXZlIHRoaXMgaW5mbyBhdmFpbGFibGVcbiAgY29uc3QgY3NzID0gZ2V0U3R5bGVDb21wdXRlZFByb3BlcnR5KGRhdGEuaW5zdGFuY2UucG9wcGVyKTtcbiAgY29uc3QgcG9wcGVyTWFyZ2luU2lkZSA9IHBhcnNlRmxvYXQoY3NzW2BtYXJnaW4ke3NpZGVDYXBpdGFsaXplZH1gXSk7XG4gIGNvbnN0IHBvcHBlckJvcmRlclNpZGUgPSBwYXJzZUZsb2F0KGNzc1tgYm9yZGVyJHtzaWRlQ2FwaXRhbGl6ZWR9V2lkdGhgXSk7XG4gIGxldCBzaWRlVmFsdWUgPVxuICAgIGNlbnRlciAtIGRhdGEub2Zmc2V0cy5wb3BwZXJbc2lkZV0gLSBwb3BwZXJNYXJnaW5TaWRlIC0gcG9wcGVyQm9yZGVyU2lkZTtcblxuICAvLyBwcmV2ZW50IGFycm93RWxlbWVudCBmcm9tIGJlaW5nIHBsYWNlZCBub3QgY29udGlndW91c2x5IHRvIGl0cyBwb3BwZXJcbiAgc2lkZVZhbHVlID0gTWF0aC5tYXgoTWF0aC5taW4ocG9wcGVyW2xlbl0gLSBhcnJvd0VsZW1lbnRTaXplLCBzaWRlVmFsdWUpLCAwKTtcblxuICBkYXRhLmFycm93RWxlbWVudCA9IGFycm93RWxlbWVudDtcbiAgZGF0YS5vZmZzZXRzLmFycm93ID0ge1xuICAgIFtzaWRlXTogTWF0aC5yb3VuZChzaWRlVmFsdWUpLFxuICAgIFthbHRTaWRlXTogJycsIC8vIG1ha2Ugc3VyZSB0byB1bnNldCBhbnkgZXZlbnR1YWwgYWx0U2lkZSB2YWx1ZSBmcm9tIHRoZSBET00gbm9kZVxuICB9O1xuXG4gIHJldHVybiBkYXRhO1xufVxuIiwiLyoqXG4gKiBHZXQgdGhlIG9wcG9zaXRlIHBsYWNlbWVudCB2YXJpYXRpb24gb2YgdGhlIGdpdmVuIG9uZVxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtTdHJpbmd9IHBsYWNlbWVudCB2YXJpYXRpb25cbiAqIEByZXR1cm5zIHtTdHJpbmd9IGZsaXBwZWQgcGxhY2VtZW50IHZhcmlhdGlvblxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRPcHBvc2l0ZVZhcmlhdGlvbih2YXJpYXRpb24pIHtcbiAgaWYgKHZhcmlhdGlvbiA9PT0gJ2VuZCcpIHtcbiAgICByZXR1cm4gJ3N0YXJ0JztcbiAgfSBlbHNlIGlmICh2YXJpYXRpb24gPT09ICdzdGFydCcpIHtcbiAgICByZXR1cm4gJ2VuZCc7XG4gIH1cbiAgcmV0dXJuIHZhcmlhdGlvbjtcbn1cbiIsIi8qKlxuICogTGlzdCBvZiBhY2NlcHRlZCBwbGFjZW1lbnRzIHRvIHVzZSBhcyB2YWx1ZXMgb2YgdGhlIGBwbGFjZW1lbnRgIG9wdGlvbi48YnIgLz5cbiAqIFZhbGlkIHBsYWNlbWVudHMgYXJlOlxuICogLSBgYXV0b2BcbiAqIC0gYHRvcGBcbiAqIC0gYHJpZ2h0YFxuICogLSBgYm90dG9tYFxuICogLSBgbGVmdGBcbiAqXG4gKiBFYWNoIHBsYWNlbWVudCBjYW4gaGF2ZSBhIHZhcmlhdGlvbiBmcm9tIHRoaXMgbGlzdDpcbiAqIC0gYC1zdGFydGBcbiAqIC0gYC1lbmRgXG4gKlxuICogVmFyaWF0aW9ucyBhcmUgaW50ZXJwcmV0ZWQgZWFzaWx5IGlmIHlvdSB0aGluayBvZiB0aGVtIGFzIHRoZSBsZWZ0IHRvIHJpZ2h0XG4gKiB3cml0dGVuIGxhbmd1YWdlcy4gSG9yaXpvbnRhbGx5IChgdG9wYCBhbmQgYGJvdHRvbWApLCBgc3RhcnRgIGlzIGxlZnQgYW5kIGBlbmRgXG4gKiBpcyByaWdodC48YnIgLz5cbiAqIFZlcnRpY2FsbHkgKGBsZWZ0YCBhbmQgYHJpZ2h0YCksIGBzdGFydGAgaXMgdG9wIGFuZCBgZW5kYCBpcyBib3R0b20uXG4gKlxuICogU29tZSB2YWxpZCBleGFtcGxlcyBhcmU6XG4gKiAtIGB0b3AtZW5kYCAob24gdG9wIG9mIHJlZmVyZW5jZSwgcmlnaHQgYWxpZ25lZClcbiAqIC0gYHJpZ2h0LXN0YXJ0YCAob24gcmlnaHQgb2YgcmVmZXJlbmNlLCB0b3AgYWxpZ25lZClcbiAqIC0gYGJvdHRvbWAgKG9uIGJvdHRvbSwgY2VudGVyZWQpXG4gKiAtIGBhdXRvLWVuZGAgKG9uIHRoZSBzaWRlIHdpdGggbW9yZSBzcGFjZSBhdmFpbGFibGUsIGFsaWdubWVudCBkZXBlbmRzIGJ5IHBsYWNlbWVudClcbiAqXG4gKiBAc3RhdGljXG4gKiBAdHlwZSB7QXJyYXl9XG4gKiBAZW51bSB7U3RyaW5nfVxuICogQHJlYWRvbmx5XG4gKiBAbWV0aG9kIHBsYWNlbWVudHNcbiAqIEBtZW1iZXJvZiBQb3BwZXJcbiAqL1xuZXhwb3J0IGRlZmF1bHQgW1xuICAnYXV0by1zdGFydCcsXG4gICdhdXRvJyxcbiAgJ2F1dG8tZW5kJyxcbiAgJ3RvcC1zdGFydCcsXG4gICd0b3AnLFxuICAndG9wLWVuZCcsXG4gICdyaWdodC1zdGFydCcsXG4gICdyaWdodCcsXG4gICdyaWdodC1lbmQnLFxuICAnYm90dG9tLWVuZCcsXG4gICdib3R0b20nLFxuICAnYm90dG9tLXN0YXJ0JyxcbiAgJ2xlZnQtZW5kJyxcbiAgJ2xlZnQnLFxuICAnbGVmdC1zdGFydCcsXG5dO1xuIiwiaW1wb3J0IHBsYWNlbWVudHMgZnJvbSAnLi4vbWV0aG9kcy9wbGFjZW1lbnRzJztcblxuLy8gR2V0IHJpZCBvZiBgYXV0b2AgYGF1dG8tc3RhcnRgIGFuZCBgYXV0by1lbmRgXG5jb25zdCB2YWxpZFBsYWNlbWVudHMgPSBwbGFjZW1lbnRzLnNsaWNlKDMpO1xuXG4vKipcbiAqIEdpdmVuIGFuIGluaXRpYWwgcGxhY2VtZW50LCByZXR1cm5zIGFsbCB0aGUgc3Vic2VxdWVudCBwbGFjZW1lbnRzXG4gKiBjbG9ja3dpc2UgKG9yIGNvdW50ZXItY2xvY2t3aXNlKS5cbiAqXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge1N0cmluZ30gcGxhY2VtZW50IC0gQSB2YWxpZCBwbGFjZW1lbnQgKGl0IGFjY2VwdHMgdmFyaWF0aW9ucylcbiAqIEBhcmd1bWVudCB7Qm9vbGVhbn0gY291bnRlciAtIFNldCB0byB0cnVlIHRvIHdhbGsgdGhlIHBsYWNlbWVudHMgY291bnRlcmNsb2Nrd2lzZVxuICogQHJldHVybnMge0FycmF5fSBwbGFjZW1lbnRzIGluY2x1ZGluZyB0aGVpciB2YXJpYXRpb25zXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNsb2Nrd2lzZShwbGFjZW1lbnQsIGNvdW50ZXIgPSBmYWxzZSkge1xuICBjb25zdCBpbmRleCA9IHZhbGlkUGxhY2VtZW50cy5pbmRleE9mKHBsYWNlbWVudCk7XG4gIGNvbnN0IGFyciA9IHZhbGlkUGxhY2VtZW50c1xuICAgIC5zbGljZShpbmRleCArIDEpXG4gICAgLmNvbmNhdCh2YWxpZFBsYWNlbWVudHMuc2xpY2UoMCwgaW5kZXgpKTtcbiAgcmV0dXJuIGNvdW50ZXIgPyBhcnIucmV2ZXJzZSgpIDogYXJyO1xufVxuIiwiaW1wb3J0IGdldE9wcG9zaXRlUGxhY2VtZW50IGZyb20gJy4uL3V0aWxzL2dldE9wcG9zaXRlUGxhY2VtZW50JztcbmltcG9ydCBnZXRPcHBvc2l0ZVZhcmlhdGlvbiBmcm9tICcuLi91dGlscy9nZXRPcHBvc2l0ZVZhcmlhdGlvbic7XG5pbXBvcnQgZ2V0UG9wcGVyT2Zmc2V0cyBmcm9tICcuLi91dGlscy9nZXRQb3BwZXJPZmZzZXRzJztcbmltcG9ydCBydW5Nb2RpZmllcnMgZnJvbSAnLi4vdXRpbHMvcnVuTW9kaWZpZXJzJztcbmltcG9ydCBnZXRCb3VuZGFyaWVzIGZyb20gJy4uL3V0aWxzL2dldEJvdW5kYXJpZXMnO1xuaW1wb3J0IGlzTW9kaWZpZXJFbmFibGVkIGZyb20gJy4uL3V0aWxzL2lzTW9kaWZpZXJFbmFibGVkJztcbmltcG9ydCBjbG9ja3dpc2UgZnJvbSAnLi4vdXRpbHMvY2xvY2t3aXNlJztcblxuY29uc3QgQkVIQVZJT1JTID0ge1xuICBGTElQOiAnZmxpcCcsXG4gIENMT0NLV0lTRTogJ2Nsb2Nrd2lzZScsXG4gIENPVU5URVJDTE9DS1dJU0U6ICdjb3VudGVyY2xvY2t3aXNlJyxcbn07XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YgTW9kaWZpZXJzXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgdXBkYXRlIG1ldGhvZFxuICogQGFyZ3VtZW50IHtPYmplY3R9IG9wdGlvbnMgLSBNb2RpZmllcnMgY29uZmlndXJhdGlvbiBhbmQgb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdH0gVGhlIGRhdGEgb2JqZWN0LCBwcm9wZXJseSBtb2RpZmllZFxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBmbGlwKGRhdGEsIG9wdGlvbnMpIHtcbiAgLy8gaWYgYGlubmVyYCBtb2RpZmllciBpcyBlbmFibGVkLCB3ZSBjYW4ndCB1c2UgdGhlIGBmbGlwYCBtb2RpZmllclxuICBpZiAoaXNNb2RpZmllckVuYWJsZWQoZGF0YS5pbnN0YW5jZS5tb2RpZmllcnMsICdpbm5lcicpKSB7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cblxuICBpZiAoZGF0YS5mbGlwcGVkICYmIGRhdGEucGxhY2VtZW50ID09PSBkYXRhLm9yaWdpbmFsUGxhY2VtZW50KSB7XG4gICAgLy8gc2VlbXMgbGlrZSBmbGlwIGlzIHRyeWluZyB0byBsb29wLCBwcm9iYWJseSB0aGVyZSdzIG5vdCBlbm91Z2ggc3BhY2Ugb24gYW55IG9mIHRoZSBmbGlwcGFibGUgc2lkZXNcbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuXG4gIGNvbnN0IGJvdW5kYXJpZXMgPSBnZXRCb3VuZGFyaWVzKFxuICAgIGRhdGEuaW5zdGFuY2UucG9wcGVyLFxuICAgIGRhdGEuaW5zdGFuY2UucmVmZXJlbmNlLFxuICAgIG9wdGlvbnMucGFkZGluZyxcbiAgICBvcHRpb25zLmJvdW5kYXJpZXNFbGVtZW50LFxuICAgIGRhdGEucG9zaXRpb25GaXhlZFxuICApO1xuXG4gIGxldCBwbGFjZW1lbnQgPSBkYXRhLnBsYWNlbWVudC5zcGxpdCgnLScpWzBdO1xuICBsZXQgcGxhY2VtZW50T3Bwb3NpdGUgPSBnZXRPcHBvc2l0ZVBsYWNlbWVudChwbGFjZW1lbnQpO1xuICBsZXQgdmFyaWF0aW9uID0gZGF0YS5wbGFjZW1lbnQuc3BsaXQoJy0nKVsxXSB8fCAnJztcblxuICBsZXQgZmxpcE9yZGVyID0gW107XG5cbiAgc3dpdGNoIChvcHRpb25zLmJlaGF2aW9yKSB7XG4gICAgY2FzZSBCRUhBVklPUlMuRkxJUDpcbiAgICAgIGZsaXBPcmRlciA9IFtwbGFjZW1lbnQsIHBsYWNlbWVudE9wcG9zaXRlXTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgQkVIQVZJT1JTLkNMT0NLV0lTRTpcbiAgICAgIGZsaXBPcmRlciA9IGNsb2Nrd2lzZShwbGFjZW1lbnQpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBCRUhBVklPUlMuQ09VTlRFUkNMT0NLV0lTRTpcbiAgICAgIGZsaXBPcmRlciA9IGNsb2Nrd2lzZShwbGFjZW1lbnQsIHRydWUpO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIGZsaXBPcmRlciA9IG9wdGlvbnMuYmVoYXZpb3I7XG4gIH1cblxuICBmbGlwT3JkZXIuZm9yRWFjaCgoc3RlcCwgaW5kZXgpID0+IHtcbiAgICBpZiAocGxhY2VtZW50ICE9PSBzdGVwIHx8IGZsaXBPcmRlci5sZW5ndGggPT09IGluZGV4ICsgMSkge1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuXG4gICAgcGxhY2VtZW50ID0gZGF0YS5wbGFjZW1lbnQuc3BsaXQoJy0nKVswXTtcbiAgICBwbGFjZW1lbnRPcHBvc2l0ZSA9IGdldE9wcG9zaXRlUGxhY2VtZW50KHBsYWNlbWVudCk7XG5cbiAgICBjb25zdCBwb3BwZXJPZmZzZXRzID0gZGF0YS5vZmZzZXRzLnBvcHBlcjtcbiAgICBjb25zdCByZWZPZmZzZXRzID0gZGF0YS5vZmZzZXRzLnJlZmVyZW5jZTtcblxuICAgIC8vIHVzaW5nIGZsb29yIGJlY2F1c2UgdGhlIHJlZmVyZW5jZSBvZmZzZXRzIG1heSBjb250YWluIGRlY2ltYWxzIHdlIGFyZSBub3QgZ29pbmcgdG8gY29uc2lkZXIgaGVyZVxuICAgIGNvbnN0IGZsb29yID0gTWF0aC5mbG9vcjtcbiAgICBjb25zdCBvdmVybGFwc1JlZiA9XG4gICAgICAocGxhY2VtZW50ID09PSAnbGVmdCcgJiZcbiAgICAgICAgZmxvb3IocG9wcGVyT2Zmc2V0cy5yaWdodCkgPiBmbG9vcihyZWZPZmZzZXRzLmxlZnQpKSB8fFxuICAgICAgKHBsYWNlbWVudCA9PT0gJ3JpZ2h0JyAmJlxuICAgICAgICBmbG9vcihwb3BwZXJPZmZzZXRzLmxlZnQpIDwgZmxvb3IocmVmT2Zmc2V0cy5yaWdodCkpIHx8XG4gICAgICAocGxhY2VtZW50ID09PSAndG9wJyAmJlxuICAgICAgICBmbG9vcihwb3BwZXJPZmZzZXRzLmJvdHRvbSkgPiBmbG9vcihyZWZPZmZzZXRzLnRvcCkpIHx8XG4gICAgICAocGxhY2VtZW50ID09PSAnYm90dG9tJyAmJlxuICAgICAgICBmbG9vcihwb3BwZXJPZmZzZXRzLnRvcCkgPCBmbG9vcihyZWZPZmZzZXRzLmJvdHRvbSkpO1xuXG4gICAgY29uc3Qgb3ZlcmZsb3dzTGVmdCA9IGZsb29yKHBvcHBlck9mZnNldHMubGVmdCkgPCBmbG9vcihib3VuZGFyaWVzLmxlZnQpO1xuICAgIGNvbnN0IG92ZXJmbG93c1JpZ2h0ID0gZmxvb3IocG9wcGVyT2Zmc2V0cy5yaWdodCkgPiBmbG9vcihib3VuZGFyaWVzLnJpZ2h0KTtcbiAgICBjb25zdCBvdmVyZmxvd3NUb3AgPSBmbG9vcihwb3BwZXJPZmZzZXRzLnRvcCkgPCBmbG9vcihib3VuZGFyaWVzLnRvcCk7XG4gICAgY29uc3Qgb3ZlcmZsb3dzQm90dG9tID1cbiAgICAgIGZsb29yKHBvcHBlck9mZnNldHMuYm90dG9tKSA+IGZsb29yKGJvdW5kYXJpZXMuYm90dG9tKTtcblxuICAgIGNvbnN0IG92ZXJmbG93c0JvdW5kYXJpZXMgPVxuICAgICAgKHBsYWNlbWVudCA9PT0gJ2xlZnQnICYmIG92ZXJmbG93c0xlZnQpIHx8XG4gICAgICAocGxhY2VtZW50ID09PSAncmlnaHQnICYmIG92ZXJmbG93c1JpZ2h0KSB8fFxuICAgICAgKHBsYWNlbWVudCA9PT0gJ3RvcCcgJiYgb3ZlcmZsb3dzVG9wKSB8fFxuICAgICAgKHBsYWNlbWVudCA9PT0gJ2JvdHRvbScgJiYgb3ZlcmZsb3dzQm90dG9tKTtcblxuICAgIC8vIGZsaXAgdGhlIHZhcmlhdGlvbiBpZiByZXF1aXJlZFxuICAgIGNvbnN0IGlzVmVydGljYWwgPSBbJ3RvcCcsICdib3R0b20nXS5pbmRleE9mKHBsYWNlbWVudCkgIT09IC0xO1xuXG4gICAgLy8gZmxpcHMgdmFyaWF0aW9uIGlmIHJlZmVyZW5jZSBlbGVtZW50IG92ZXJmbG93cyBib3VuZGFyaWVzXG4gICAgY29uc3QgZmxpcHBlZFZhcmlhdGlvbkJ5UmVmID1cbiAgICAgICEhb3B0aW9ucy5mbGlwVmFyaWF0aW9ucyAmJlxuICAgICAgKChpc1ZlcnRpY2FsICYmIHZhcmlhdGlvbiA9PT0gJ3N0YXJ0JyAmJiBvdmVyZmxvd3NMZWZ0KSB8fFxuICAgICAgICAoaXNWZXJ0aWNhbCAmJiB2YXJpYXRpb24gPT09ICdlbmQnICYmIG92ZXJmbG93c1JpZ2h0KSB8fFxuICAgICAgICAoIWlzVmVydGljYWwgJiYgdmFyaWF0aW9uID09PSAnc3RhcnQnICYmIG92ZXJmbG93c1RvcCkgfHxcbiAgICAgICAgKCFpc1ZlcnRpY2FsICYmIHZhcmlhdGlvbiA9PT0gJ2VuZCcgJiYgb3ZlcmZsb3dzQm90dG9tKSk7XG5cbiAgICAvLyBmbGlwcyB2YXJpYXRpb24gaWYgcG9wcGVyIGNvbnRlbnQgb3ZlcmZsb3dzIGJvdW5kYXJpZXNcbiAgICBjb25zdCBmbGlwcGVkVmFyaWF0aW9uQnlDb250ZW50ID1cbiAgICAgICEhb3B0aW9ucy5mbGlwVmFyaWF0aW9uc0J5Q29udGVudCAmJlxuICAgICAgKChpc1ZlcnRpY2FsICYmIHZhcmlhdGlvbiA9PT0gJ3N0YXJ0JyAmJiBvdmVyZmxvd3NSaWdodCkgfHxcbiAgICAgICAgKGlzVmVydGljYWwgJiYgdmFyaWF0aW9uID09PSAnZW5kJyAmJiBvdmVyZmxvd3NMZWZ0KSB8fFxuICAgICAgICAoIWlzVmVydGljYWwgJiYgdmFyaWF0aW9uID09PSAnc3RhcnQnICYmIG92ZXJmbG93c0JvdHRvbSkgfHxcbiAgICAgICAgKCFpc1ZlcnRpY2FsICYmIHZhcmlhdGlvbiA9PT0gJ2VuZCcgJiYgb3ZlcmZsb3dzVG9wKSk7XG5cbiAgICBjb25zdCBmbGlwcGVkVmFyaWF0aW9uID0gZmxpcHBlZFZhcmlhdGlvbkJ5UmVmIHx8IGZsaXBwZWRWYXJpYXRpb25CeUNvbnRlbnQ7XG5cbiAgICBpZiAob3ZlcmxhcHNSZWYgfHwgb3ZlcmZsb3dzQm91bmRhcmllcyB8fCBmbGlwcGVkVmFyaWF0aW9uKSB7XG4gICAgICAvLyB0aGlzIGJvb2xlYW4gdG8gZGV0ZWN0IGFueSBmbGlwIGxvb3BcbiAgICAgIGRhdGEuZmxpcHBlZCA9IHRydWU7XG5cbiAgICAgIGlmIChvdmVybGFwc1JlZiB8fCBvdmVyZmxvd3NCb3VuZGFyaWVzKSB7XG4gICAgICAgIHBsYWNlbWVudCA9IGZsaXBPcmRlcltpbmRleCArIDFdO1xuICAgICAgfVxuXG4gICAgICBpZiAoZmxpcHBlZFZhcmlhdGlvbikge1xuICAgICAgICB2YXJpYXRpb24gPSBnZXRPcHBvc2l0ZVZhcmlhdGlvbih2YXJpYXRpb24pO1xuICAgICAgfVxuXG4gICAgICBkYXRhLnBsYWNlbWVudCA9IHBsYWNlbWVudCArICh2YXJpYXRpb24gPyAnLScgKyB2YXJpYXRpb24gOiAnJyk7XG5cbiAgICAgIC8vIHRoaXMgb2JqZWN0IGNvbnRhaW5zIGBwb3NpdGlvbmAsIHdlIHdhbnQgdG8gcHJlc2VydmUgaXQgYWxvbmcgd2l0aFxuICAgICAgLy8gYW55IGFkZGl0aW9uYWwgcHJvcGVydHkgd2UgbWF5IGFkZCBpbiB0aGUgZnV0dXJlXG4gICAgICBkYXRhLm9mZnNldHMucG9wcGVyID0ge1xuICAgICAgICAuLi5kYXRhLm9mZnNldHMucG9wcGVyLFxuICAgICAgICAuLi5nZXRQb3BwZXJPZmZzZXRzKFxuICAgICAgICAgIGRhdGEuaW5zdGFuY2UucG9wcGVyLFxuICAgICAgICAgIGRhdGEub2Zmc2V0cy5yZWZlcmVuY2UsXG4gICAgICAgICAgZGF0YS5wbGFjZW1lbnRcbiAgICAgICAgKSxcbiAgICAgIH07XG5cbiAgICAgIGRhdGEgPSBydW5Nb2RpZmllcnMoZGF0YS5pbnN0YW5jZS5tb2RpZmllcnMsIGRhdGEsICdmbGlwJyk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGRhdGE7XG59XG4iLCIvKipcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIE1vZGlmaWVyc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IHVwZGF0ZSBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBkYXRhIG9iamVjdCwgcHJvcGVybHkgbW9kaWZpZWRcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24ga2VlcFRvZ2V0aGVyKGRhdGEpIHtcbiAgY29uc3QgeyBwb3BwZXIsIHJlZmVyZW5jZSB9ID0gZGF0YS5vZmZzZXRzO1xuICBjb25zdCBwbGFjZW1lbnQgPSBkYXRhLnBsYWNlbWVudC5zcGxpdCgnLScpWzBdO1xuICBjb25zdCBmbG9vciA9IE1hdGguZmxvb3I7XG4gIGNvbnN0IGlzVmVydGljYWwgPSBbJ3RvcCcsICdib3R0b20nXS5pbmRleE9mKHBsYWNlbWVudCkgIT09IC0xO1xuICBjb25zdCBzaWRlID0gaXNWZXJ0aWNhbCA/ICdyaWdodCcgOiAnYm90dG9tJztcbiAgY29uc3Qgb3BTaWRlID0gaXNWZXJ0aWNhbCA/ICdsZWZ0JyA6ICd0b3AnO1xuICBjb25zdCBtZWFzdXJlbWVudCA9IGlzVmVydGljYWwgPyAnd2lkdGgnIDogJ2hlaWdodCc7XG5cbiAgaWYgKHBvcHBlcltzaWRlXSA8IGZsb29yKHJlZmVyZW5jZVtvcFNpZGVdKSkge1xuICAgIGRhdGEub2Zmc2V0cy5wb3BwZXJbb3BTaWRlXSA9XG4gICAgICBmbG9vcihyZWZlcmVuY2Vbb3BTaWRlXSkgLSBwb3BwZXJbbWVhc3VyZW1lbnRdO1xuICB9XG4gIGlmIChwb3BwZXJbb3BTaWRlXSA+IGZsb29yKHJlZmVyZW5jZVtzaWRlXSkpIHtcbiAgICBkYXRhLm9mZnNldHMucG9wcGVyW29wU2lkZV0gPSBmbG9vcihyZWZlcmVuY2Vbc2lkZV0pO1xuICB9XG5cbiAgcmV0dXJuIGRhdGE7XG59XG4iLCJpbXBvcnQgaXNOdW1lcmljIGZyb20gJy4uL3V0aWxzL2lzTnVtZXJpYyc7XG5pbXBvcnQgZ2V0Q2xpZW50UmVjdCBmcm9tICcuLi91dGlscy9nZXRDbGllbnRSZWN0JztcbmltcG9ydCBmaW5kIGZyb20gJy4uL3V0aWxzL2ZpbmQnO1xuXG4vKipcbiAqIENvbnZlcnRzIGEgc3RyaW5nIGNvbnRhaW5pbmcgdmFsdWUgKyB1bml0IGludG8gYSBweCB2YWx1ZSBudW1iZXJcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIHttb2RpZmllcnN+b2Zmc2V0fVxuICogQHByaXZhdGVcbiAqIEBhcmd1bWVudCB7U3RyaW5nfSBzdHIgLSBWYWx1ZSArIHVuaXQgc3RyaW5nXG4gKiBAYXJndW1lbnQge1N0cmluZ30gbWVhc3VyZW1lbnQgLSBgaGVpZ2h0YCBvciBgd2lkdGhgXG4gKiBAYXJndW1lbnQge09iamVjdH0gcG9wcGVyT2Zmc2V0c1xuICogQGFyZ3VtZW50IHtPYmplY3R9IHJlZmVyZW5jZU9mZnNldHNcbiAqIEByZXR1cm5zIHtOdW1iZXJ8U3RyaW5nfVxuICogVmFsdWUgaW4gcGl4ZWxzLCBvciBvcmlnaW5hbCBzdHJpbmcgaWYgbm8gdmFsdWVzIHdlcmUgZXh0cmFjdGVkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b1ZhbHVlKHN0ciwgbWVhc3VyZW1lbnQsIHBvcHBlck9mZnNldHMsIHJlZmVyZW5jZU9mZnNldHMpIHtcbiAgLy8gc2VwYXJhdGUgdmFsdWUgZnJvbSB1bml0XG4gIGNvbnN0IHNwbGl0ID0gc3RyLm1hdGNoKC8oKD86XFwtfFxcKyk/XFxkKlxcLj9cXGQqKSguKikvKTtcbiAgY29uc3QgdmFsdWUgPSArc3BsaXRbMV07XG4gIGNvbnN0IHVuaXQgPSBzcGxpdFsyXTtcblxuICAvLyBJZiBpdCdzIG5vdCBhIG51bWJlciBpdCdzIGFuIG9wZXJhdG9yLCBJIGd1ZXNzXG4gIGlmICghdmFsdWUpIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG5cbiAgaWYgKHVuaXQuaW5kZXhPZignJScpID09PSAwKSB7XG4gICAgbGV0IGVsZW1lbnQ7XG4gICAgc3dpdGNoICh1bml0KSB7XG4gICAgICBjYXNlICclcCc6XG4gICAgICAgIGVsZW1lbnQgPSBwb3BwZXJPZmZzZXRzO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJyUnOlxuICAgICAgY2FzZSAnJXInOlxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgZWxlbWVudCA9IHJlZmVyZW5jZU9mZnNldHM7XG4gICAgfVxuXG4gICAgY29uc3QgcmVjdCA9IGdldENsaWVudFJlY3QoZWxlbWVudCk7XG4gICAgcmV0dXJuIHJlY3RbbWVhc3VyZW1lbnRdIC8gMTAwICogdmFsdWU7XG4gIH0gZWxzZSBpZiAodW5pdCA9PT0gJ3ZoJyB8fCB1bml0ID09PSAndncnKSB7XG4gICAgLy8gaWYgaXMgYSB2aCBvciB2dywgd2UgY2FsY3VsYXRlIHRoZSBzaXplIGJhc2VkIG9uIHRoZSB2aWV3cG9ydFxuICAgIGxldCBzaXplO1xuICAgIGlmICh1bml0ID09PSAndmgnKSB7XG4gICAgICBzaXplID0gTWF0aC5tYXgoXG4gICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQsXG4gICAgICAgIHdpbmRvdy5pbm5lckhlaWdodCB8fCAwXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBzaXplID0gTWF0aC5tYXgoXG4gICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aCxcbiAgICAgICAgd2luZG93LmlubmVyV2lkdGggfHwgMFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHNpemUgLyAxMDAgKiB2YWx1ZTtcbiAgfSBlbHNlIHtcbiAgICAvLyBpZiBpcyBhbiBleHBsaWNpdCBwaXhlbCB1bml0LCB3ZSBnZXQgcmlkIG9mIHRoZSB1bml0IGFuZCBrZWVwIHRoZSB2YWx1ZVxuICAgIC8vIGlmIGlzIGFuIGltcGxpY2l0IHVuaXQsIGl0J3MgcHgsIGFuZCB3ZSByZXR1cm4ganVzdCB0aGUgdmFsdWVcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbn1cblxuLyoqXG4gKiBQYXJzZSBhbiBgb2Zmc2V0YCBzdHJpbmcgdG8gZXh0cmFwb2xhdGUgYHhgIGFuZCBgeWAgbnVtZXJpYyBvZmZzZXRzLlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2Yge21vZGlmaWVyc35vZmZzZXR9XG4gKiBAcHJpdmF0ZVxuICogQGFyZ3VtZW50IHtTdHJpbmd9IG9mZnNldFxuICogQGFyZ3VtZW50IHtPYmplY3R9IHBvcHBlck9mZnNldHNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSByZWZlcmVuY2VPZmZzZXRzXG4gKiBAYXJndW1lbnQge1N0cmluZ30gYmFzZVBsYWNlbWVudFxuICogQHJldHVybnMge0FycmF5fSBhIHR3byBjZWxscyBhcnJheSB3aXRoIHggYW5kIHkgb2Zmc2V0cyBpbiBudW1iZXJzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZU9mZnNldChcbiAgb2Zmc2V0LFxuICBwb3BwZXJPZmZzZXRzLFxuICByZWZlcmVuY2VPZmZzZXRzLFxuICBiYXNlUGxhY2VtZW50XG4pIHtcbiAgY29uc3Qgb2Zmc2V0cyA9IFswLCAwXTtcblxuICAvLyBVc2UgaGVpZ2h0IGlmIHBsYWNlbWVudCBpcyBsZWZ0IG9yIHJpZ2h0IGFuZCBpbmRleCBpcyAwIG90aGVyd2lzZSB1c2Ugd2lkdGhcbiAgLy8gaW4gdGhpcyB3YXkgdGhlIGZpcnN0IG9mZnNldCB3aWxsIHVzZSBhbiBheGlzIGFuZCB0aGUgc2Vjb25kIG9uZVxuICAvLyB3aWxsIHVzZSB0aGUgb3RoZXIgb25lXG4gIGNvbnN0IHVzZUhlaWdodCA9IFsncmlnaHQnLCAnbGVmdCddLmluZGV4T2YoYmFzZVBsYWNlbWVudCkgIT09IC0xO1xuXG4gIC8vIFNwbGl0IHRoZSBvZmZzZXQgc3RyaW5nIHRvIG9idGFpbiBhIGxpc3Qgb2YgdmFsdWVzIGFuZCBvcGVyYW5kc1xuICAvLyBUaGUgcmVnZXggYWRkcmVzc2VzIHZhbHVlcyB3aXRoIHRoZSBwbHVzIG9yIG1pbnVzIHNpZ24gaW4gZnJvbnQgKCsxMCwgLTIwLCBldGMpXG4gIGNvbnN0IGZyYWdtZW50cyA9IG9mZnNldC5zcGxpdCgvKFxcK3xcXC0pLykubWFwKGZyYWcgPT4gZnJhZy50cmltKCkpO1xuXG4gIC8vIERldGVjdCBpZiB0aGUgb2Zmc2V0IHN0cmluZyBjb250YWlucyBhIHBhaXIgb2YgdmFsdWVzIG9yIGEgc2luZ2xlIG9uZVxuICAvLyB0aGV5IGNvdWxkIGJlIHNlcGFyYXRlZCBieSBjb21tYSBvciBzcGFjZVxuICBjb25zdCBkaXZpZGVyID0gZnJhZ21lbnRzLmluZGV4T2YoXG4gICAgZmluZChmcmFnbWVudHMsIGZyYWcgPT4gZnJhZy5zZWFyY2goLyx8XFxzLykgIT09IC0xKVxuICApO1xuXG4gIGlmIChmcmFnbWVudHNbZGl2aWRlcl0gJiYgZnJhZ21lbnRzW2RpdmlkZXJdLmluZGV4T2YoJywnKSA9PT0gLTEpIHtcbiAgICBjb25zb2xlLndhcm4oXG4gICAgICAnT2Zmc2V0cyBzZXBhcmF0ZWQgYnkgd2hpdGUgc3BhY2UocykgYXJlIGRlcHJlY2F0ZWQsIHVzZSBhIGNvbW1hICgsKSBpbnN0ZWFkLidcbiAgICApO1xuICB9XG5cbiAgLy8gSWYgZGl2aWRlciBpcyBmb3VuZCwgd2UgZGl2aWRlIHRoZSBsaXN0IG9mIHZhbHVlcyBhbmQgb3BlcmFuZHMgdG8gZGl2aWRlXG4gIC8vIHRoZW0gYnkgb2ZzZXQgWCBhbmQgWS5cbiAgY29uc3Qgc3BsaXRSZWdleCA9IC9cXHMqLFxccyp8XFxzKy87XG4gIGxldCBvcHMgPSBkaXZpZGVyICE9PSAtMVxuICAgID8gW1xuICAgICAgICBmcmFnbWVudHNcbiAgICAgICAgICAuc2xpY2UoMCwgZGl2aWRlcilcbiAgICAgICAgICAuY29uY2F0KFtmcmFnbWVudHNbZGl2aWRlcl0uc3BsaXQoc3BsaXRSZWdleClbMF1dKSxcbiAgICAgICAgW2ZyYWdtZW50c1tkaXZpZGVyXS5zcGxpdChzcGxpdFJlZ2V4KVsxXV0uY29uY2F0KFxuICAgICAgICAgIGZyYWdtZW50cy5zbGljZShkaXZpZGVyICsgMSlcbiAgICAgICAgKSxcbiAgICAgIF1cbiAgICA6IFtmcmFnbWVudHNdO1xuXG4gIC8vIENvbnZlcnQgdGhlIHZhbHVlcyB3aXRoIHVuaXRzIHRvIGFic29sdXRlIHBpeGVscyB0byBhbGxvdyBvdXIgY29tcHV0YXRpb25zXG4gIG9wcyA9IG9wcy5tYXAoKG9wLCBpbmRleCkgPT4ge1xuICAgIC8vIE1vc3Qgb2YgdGhlIHVuaXRzIHJlbHkgb24gdGhlIG9yaWVudGF0aW9uIG9mIHRoZSBwb3BwZXJcbiAgICBjb25zdCBtZWFzdXJlbWVudCA9IChpbmRleCA9PT0gMSA/ICF1c2VIZWlnaHQgOiB1c2VIZWlnaHQpXG4gICAgICA/ICdoZWlnaHQnXG4gICAgICA6ICd3aWR0aCc7XG4gICAgbGV0IG1lcmdlV2l0aFByZXZpb3VzID0gZmFsc2U7XG4gICAgcmV0dXJuIChcbiAgICAgIG9wXG4gICAgICAgIC8vIFRoaXMgYWdncmVnYXRlcyBhbnkgYCtgIG9yIGAtYCBzaWduIHRoYXQgYXJlbid0IGNvbnNpZGVyZWQgb3BlcmF0b3JzXG4gICAgICAgIC8vIGUuZy46IDEwICsgKzUgPT4gWzEwLCArLCArNV1cbiAgICAgICAgLnJlZHVjZSgoYSwgYikgPT4ge1xuICAgICAgICAgIGlmIChhW2EubGVuZ3RoIC0gMV0gPT09ICcnICYmIFsnKycsICctJ10uaW5kZXhPZihiKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIGFbYS5sZW5ndGggLSAxXSA9IGI7XG4gICAgICAgICAgICBtZXJnZVdpdGhQcmV2aW91cyA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gYTtcbiAgICAgICAgICB9IGVsc2UgaWYgKG1lcmdlV2l0aFByZXZpb3VzKSB7XG4gICAgICAgICAgICBhW2EubGVuZ3RoIC0gMV0gKz0gYjtcbiAgICAgICAgICAgIG1lcmdlV2l0aFByZXZpb3VzID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gYTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGEuY29uY2F0KGIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgW10pXG4gICAgICAgIC8vIEhlcmUgd2UgY29udmVydCB0aGUgc3RyaW5nIHZhbHVlcyBpbnRvIG51bWJlciB2YWx1ZXMgKGluIHB4KVxuICAgICAgICAubWFwKHN0ciA9PiB0b1ZhbHVlKHN0ciwgbWVhc3VyZW1lbnQsIHBvcHBlck9mZnNldHMsIHJlZmVyZW5jZU9mZnNldHMpKVxuICAgICk7XG4gIH0pO1xuXG4gIC8vIExvb3AgdHJvdWdoIHRoZSBvZmZzZXRzIGFycmF5cyBhbmQgZXhlY3V0ZSB0aGUgb3BlcmF0aW9uc1xuICBvcHMuZm9yRWFjaCgob3AsIGluZGV4KSA9PiB7XG4gICAgb3AuZm9yRWFjaCgoZnJhZywgaW5kZXgyKSA9PiB7XG4gICAgICBpZiAoaXNOdW1lcmljKGZyYWcpKSB7XG4gICAgICAgIG9mZnNldHNbaW5kZXhdICs9IGZyYWcgKiAob3BbaW5kZXgyIC0gMV0gPT09ICctJyA/IC0xIDogMSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gb2Zmc2V0cztcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiBNb2RpZmllcnNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSB1cGRhdGUgbWV0aG9kXG4gKiBAYXJndW1lbnQge09iamVjdH0gb3B0aW9ucyAtIE1vZGlmaWVycyBjb25maWd1cmF0aW9uIGFuZCBvcHRpb25zXG4gKiBAYXJndW1lbnQge051bWJlcnxTdHJpbmd9IG9wdGlvbnMub2Zmc2V0PTBcbiAqIFRoZSBvZmZzZXQgdmFsdWUgYXMgZGVzY3JpYmVkIGluIHRoZSBtb2RpZmllciBkZXNjcmlwdGlvblxuICogQHJldHVybnMge09iamVjdH0gVGhlIGRhdGEgb2JqZWN0LCBwcm9wZXJseSBtb2RpZmllZFxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBvZmZzZXQoZGF0YSwgeyBvZmZzZXQgfSkge1xuICBjb25zdCB7IHBsYWNlbWVudCwgb2Zmc2V0czogeyBwb3BwZXIsIHJlZmVyZW5jZSB9IH0gPSBkYXRhO1xuICBjb25zdCBiYXNlUGxhY2VtZW50ID0gcGxhY2VtZW50LnNwbGl0KCctJylbMF07XG5cbiAgbGV0IG9mZnNldHM7XG4gIGlmIChpc051bWVyaWMoK29mZnNldCkpIHtcbiAgICBvZmZzZXRzID0gWytvZmZzZXQsIDBdO1xuICB9IGVsc2Uge1xuICAgIG9mZnNldHMgPSBwYXJzZU9mZnNldChvZmZzZXQsIHBvcHBlciwgcmVmZXJlbmNlLCBiYXNlUGxhY2VtZW50KTtcbiAgfVxuXG4gIGlmIChiYXNlUGxhY2VtZW50ID09PSAnbGVmdCcpIHtcbiAgICBwb3BwZXIudG9wICs9IG9mZnNldHNbMF07XG4gICAgcG9wcGVyLmxlZnQgLT0gb2Zmc2V0c1sxXTtcbiAgfSBlbHNlIGlmIChiYXNlUGxhY2VtZW50ID09PSAncmlnaHQnKSB7XG4gICAgcG9wcGVyLnRvcCArPSBvZmZzZXRzWzBdO1xuICAgIHBvcHBlci5sZWZ0ICs9IG9mZnNldHNbMV07XG4gIH0gZWxzZSBpZiAoYmFzZVBsYWNlbWVudCA9PT0gJ3RvcCcpIHtcbiAgICBwb3BwZXIubGVmdCArPSBvZmZzZXRzWzBdO1xuICAgIHBvcHBlci50b3AgLT0gb2Zmc2V0c1sxXTtcbiAgfSBlbHNlIGlmIChiYXNlUGxhY2VtZW50ID09PSAnYm90dG9tJykge1xuICAgIHBvcHBlci5sZWZ0ICs9IG9mZnNldHNbMF07XG4gICAgcG9wcGVyLnRvcCArPSBvZmZzZXRzWzFdO1xuICB9XG5cbiAgZGF0YS5wb3BwZXIgPSBwb3BwZXI7XG4gIHJldHVybiBkYXRhO1xufVxuIiwiaW1wb3J0IGdldE9mZnNldFBhcmVudCBmcm9tICcuLi91dGlscy9nZXRPZmZzZXRQYXJlbnQnO1xuaW1wb3J0IGdldEJvdW5kYXJpZXMgZnJvbSAnLi4vdXRpbHMvZ2V0Qm91bmRhcmllcyc7XG5pbXBvcnQgZ2V0U3VwcG9ydGVkUHJvcGVydHlOYW1lIGZyb20gJy4uL3V0aWxzL2dldFN1cHBvcnRlZFByb3BlcnR5TmFtZSc7XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YgTW9kaWZpZXJzXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgYHVwZGF0ZWAgbWV0aG9kXG4gKiBAYXJndW1lbnQge09iamVjdH0gb3B0aW9ucyAtIE1vZGlmaWVycyBjb25maWd1cmF0aW9uIGFuZCBvcHRpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgZGF0YSBvYmplY3QsIHByb3Blcmx5IG1vZGlmaWVkXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHByZXZlbnRPdmVyZmxvdyhkYXRhLCBvcHRpb25zKSB7XG4gIGxldCBib3VuZGFyaWVzRWxlbWVudCA9XG4gICAgb3B0aW9ucy5ib3VuZGFyaWVzRWxlbWVudCB8fCBnZXRPZmZzZXRQYXJlbnQoZGF0YS5pbnN0YW5jZS5wb3BwZXIpO1xuXG4gIC8vIElmIG9mZnNldFBhcmVudCBpcyB0aGUgcmVmZXJlbmNlIGVsZW1lbnQsIHdlIHJlYWxseSB3YW50IHRvXG4gIC8vIGdvIG9uZSBzdGVwIHVwIGFuZCB1c2UgdGhlIG5leHQgb2Zmc2V0UGFyZW50IGFzIHJlZmVyZW5jZSB0b1xuICAvLyBhdm9pZCB0byBtYWtlIHRoaXMgbW9kaWZpZXIgY29tcGxldGVseSB1c2VsZXNzIGFuZCBsb29rIGxpa2UgYnJva2VuXG4gIGlmIChkYXRhLmluc3RhbmNlLnJlZmVyZW5jZSA9PT0gYm91bmRhcmllc0VsZW1lbnQpIHtcbiAgICBib3VuZGFyaWVzRWxlbWVudCA9IGdldE9mZnNldFBhcmVudChib3VuZGFyaWVzRWxlbWVudCk7XG4gIH1cblxuICAvLyBOT1RFOiBET00gYWNjZXNzIGhlcmVcbiAgLy8gcmVzZXRzIHRoZSBwb3BwZXIncyBwb3NpdGlvbiBzbyB0aGF0IHRoZSBkb2N1bWVudCBzaXplIGNhbiBiZSBjYWxjdWxhdGVkIGV4Y2x1ZGluZ1xuICAvLyB0aGUgc2l6ZSBvZiB0aGUgcG9wcGVyIGVsZW1lbnQgaXRzZWxmXG4gIGNvbnN0IHRyYW5zZm9ybVByb3AgPSBnZXRTdXBwb3J0ZWRQcm9wZXJ0eU5hbWUoJ3RyYW5zZm9ybScpO1xuICBjb25zdCBwb3BwZXJTdHlsZXMgPSBkYXRhLmluc3RhbmNlLnBvcHBlci5zdHlsZTsgLy8gYXNzaWdubWVudCB0byBoZWxwIG1pbmlmaWNhdGlvblxuICBjb25zdCB7IHRvcCwgbGVmdCwgW3RyYW5zZm9ybVByb3BdOiB0cmFuc2Zvcm0gfSA9IHBvcHBlclN0eWxlcztcbiAgcG9wcGVyU3R5bGVzLnRvcCA9ICcnO1xuICBwb3BwZXJTdHlsZXMubGVmdCA9ICcnO1xuICBwb3BwZXJTdHlsZXNbdHJhbnNmb3JtUHJvcF0gPSAnJztcblxuICBjb25zdCBib3VuZGFyaWVzID0gZ2V0Qm91bmRhcmllcyhcbiAgICBkYXRhLmluc3RhbmNlLnBvcHBlcixcbiAgICBkYXRhLmluc3RhbmNlLnJlZmVyZW5jZSxcbiAgICBvcHRpb25zLnBhZGRpbmcsXG4gICAgYm91bmRhcmllc0VsZW1lbnQsXG4gICAgZGF0YS5wb3NpdGlvbkZpeGVkXG4gICk7XG5cbiAgLy8gTk9URTogRE9NIGFjY2VzcyBoZXJlXG4gIC8vIHJlc3RvcmVzIHRoZSBvcmlnaW5hbCBzdHlsZSBwcm9wZXJ0aWVzIGFmdGVyIHRoZSBvZmZzZXRzIGhhdmUgYmVlbiBjb21wdXRlZFxuICBwb3BwZXJTdHlsZXMudG9wID0gdG9wO1xuICBwb3BwZXJTdHlsZXMubGVmdCA9IGxlZnQ7XG4gIHBvcHBlclN0eWxlc1t0cmFuc2Zvcm1Qcm9wXSA9IHRyYW5zZm9ybTtcblxuICBvcHRpb25zLmJvdW5kYXJpZXMgPSBib3VuZGFyaWVzO1xuXG4gIGNvbnN0IG9yZGVyID0gb3B0aW9ucy5wcmlvcml0eTtcbiAgbGV0IHBvcHBlciA9IGRhdGEub2Zmc2V0cy5wb3BwZXI7XG5cbiAgY29uc3QgY2hlY2sgPSB7XG4gICAgcHJpbWFyeShwbGFjZW1lbnQpIHtcbiAgICAgIGxldCB2YWx1ZSA9IHBvcHBlcltwbGFjZW1lbnRdO1xuICAgICAgaWYgKFxuICAgICAgICBwb3BwZXJbcGxhY2VtZW50XSA8IGJvdW5kYXJpZXNbcGxhY2VtZW50XSAmJlxuICAgICAgICAhb3B0aW9ucy5lc2NhcGVXaXRoUmVmZXJlbmNlXG4gICAgICApIHtcbiAgICAgICAgdmFsdWUgPSBNYXRoLm1heChwb3BwZXJbcGxhY2VtZW50XSwgYm91bmRhcmllc1twbGFjZW1lbnRdKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IFtwbGFjZW1lbnRdOiB2YWx1ZSB9O1xuICAgIH0sXG4gICAgc2Vjb25kYXJ5KHBsYWNlbWVudCkge1xuICAgICAgY29uc3QgbWFpblNpZGUgPSBwbGFjZW1lbnQgPT09ICdyaWdodCcgPyAnbGVmdCcgOiAndG9wJztcbiAgICAgIGxldCB2YWx1ZSA9IHBvcHBlclttYWluU2lkZV07XG4gICAgICBpZiAoXG4gICAgICAgIHBvcHBlcltwbGFjZW1lbnRdID4gYm91bmRhcmllc1twbGFjZW1lbnRdICYmXG4gICAgICAgICFvcHRpb25zLmVzY2FwZVdpdGhSZWZlcmVuY2VcbiAgICAgICkge1xuICAgICAgICB2YWx1ZSA9IE1hdGgubWluKFxuICAgICAgICAgIHBvcHBlclttYWluU2lkZV0sXG4gICAgICAgICAgYm91bmRhcmllc1twbGFjZW1lbnRdIC1cbiAgICAgICAgICAgIChwbGFjZW1lbnQgPT09ICdyaWdodCcgPyBwb3BwZXIud2lkdGggOiBwb3BwZXIuaGVpZ2h0KVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHsgW21haW5TaWRlXTogdmFsdWUgfTtcbiAgICB9LFxuICB9O1xuXG4gIG9yZGVyLmZvckVhY2gocGxhY2VtZW50ID0+IHtcbiAgICBjb25zdCBzaWRlID1cbiAgICAgIFsnbGVmdCcsICd0b3AnXS5pbmRleE9mKHBsYWNlbWVudCkgIT09IC0xID8gJ3ByaW1hcnknIDogJ3NlY29uZGFyeSc7XG4gICAgcG9wcGVyID0geyAuLi5wb3BwZXIsIC4uLmNoZWNrW3NpZGVdKHBsYWNlbWVudCkgfTtcbiAgfSk7XG5cbiAgZGF0YS5vZmZzZXRzLnBvcHBlciA9IHBvcHBlcjtcblxuICByZXR1cm4gZGF0YTtcbn1cbiIsIi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YgTW9kaWZpZXJzXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgYHVwZGF0ZWAgbWV0aG9kXG4gKiBAYXJndW1lbnQge09iamVjdH0gb3B0aW9ucyAtIE1vZGlmaWVycyBjb25maWd1cmF0aW9uIGFuZCBvcHRpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgZGF0YSBvYmplY3QsIHByb3Blcmx5IG1vZGlmaWVkXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHNoaWZ0KGRhdGEpIHtcbiAgY29uc3QgcGxhY2VtZW50ID0gZGF0YS5wbGFjZW1lbnQ7XG4gIGNvbnN0IGJhc2VQbGFjZW1lbnQgPSBwbGFjZW1lbnQuc3BsaXQoJy0nKVswXTtcbiAgY29uc3Qgc2hpZnR2YXJpYXRpb24gPSBwbGFjZW1lbnQuc3BsaXQoJy0nKVsxXTtcblxuICAvLyBpZiBzaGlmdCBzaGlmdHZhcmlhdGlvbiBpcyBzcGVjaWZpZWQsIHJ1biB0aGUgbW9kaWZpZXJcbiAgaWYgKHNoaWZ0dmFyaWF0aW9uKSB7XG4gICAgY29uc3QgeyByZWZlcmVuY2UsIHBvcHBlciB9ID0gZGF0YS5vZmZzZXRzO1xuICAgIGNvbnN0IGlzVmVydGljYWwgPSBbJ2JvdHRvbScsICd0b3AnXS5pbmRleE9mKGJhc2VQbGFjZW1lbnQpICE9PSAtMTtcbiAgICBjb25zdCBzaWRlID0gaXNWZXJ0aWNhbCA/ICdsZWZ0JyA6ICd0b3AnO1xuICAgIGNvbnN0IG1lYXN1cmVtZW50ID0gaXNWZXJ0aWNhbCA/ICd3aWR0aCcgOiAnaGVpZ2h0JztcblxuICAgIGNvbnN0IHNoaWZ0T2Zmc2V0cyA9IHtcbiAgICAgIHN0YXJ0OiB7IFtzaWRlXTogcmVmZXJlbmNlW3NpZGVdIH0sXG4gICAgICBlbmQ6IHtcbiAgICAgICAgW3NpZGVdOiByZWZlcmVuY2Vbc2lkZV0gKyByZWZlcmVuY2VbbWVhc3VyZW1lbnRdIC0gcG9wcGVyW21lYXN1cmVtZW50XSxcbiAgICAgIH0sXG4gICAgfTtcblxuICAgIGRhdGEub2Zmc2V0cy5wb3BwZXIgPSB7IC4uLnBvcHBlciwgLi4uc2hpZnRPZmZzZXRzW3NoaWZ0dmFyaWF0aW9uXSB9O1xuICB9XG5cbiAgcmV0dXJuIGRhdGE7XG59XG4iLCJpbXBvcnQgaXNNb2RpZmllclJlcXVpcmVkIGZyb20gJy4uL3V0aWxzL2lzTW9kaWZpZXJSZXF1aXJlZCc7XG5pbXBvcnQgZmluZCBmcm9tICcuLi91dGlscy9maW5kJztcblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiBNb2RpZmllcnNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSB1cGRhdGUgbWV0aG9kXG4gKiBAYXJndW1lbnQge09iamVjdH0gb3B0aW9ucyAtIE1vZGlmaWVycyBjb25maWd1cmF0aW9uIGFuZCBvcHRpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgZGF0YSBvYmplY3QsIHByb3Blcmx5IG1vZGlmaWVkXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGhpZGUoZGF0YSkge1xuICBpZiAoIWlzTW9kaWZpZXJSZXF1aXJlZChkYXRhLmluc3RhbmNlLm1vZGlmaWVycywgJ2hpZGUnLCAncHJldmVudE92ZXJmbG93JykpIHtcbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuXG4gIGNvbnN0IHJlZlJlY3QgPSBkYXRhLm9mZnNldHMucmVmZXJlbmNlO1xuICBjb25zdCBib3VuZCA9IGZpbmQoXG4gICAgZGF0YS5pbnN0YW5jZS5tb2RpZmllcnMsXG4gICAgbW9kaWZpZXIgPT4gbW9kaWZpZXIubmFtZSA9PT0gJ3ByZXZlbnRPdmVyZmxvdydcbiAgKS5ib3VuZGFyaWVzO1xuXG4gIGlmIChcbiAgICByZWZSZWN0LmJvdHRvbSA8IGJvdW5kLnRvcCB8fFxuICAgIHJlZlJlY3QubGVmdCA+IGJvdW5kLnJpZ2h0IHx8XG4gICAgcmVmUmVjdC50b3AgPiBib3VuZC5ib3R0b20gfHxcbiAgICByZWZSZWN0LnJpZ2h0IDwgYm91bmQubGVmdFxuICApIHtcbiAgICAvLyBBdm9pZCB1bm5lY2Vzc2FyeSBET00gYWNjZXNzIGlmIHZpc2liaWxpdHkgaGFzbid0IGNoYW5nZWRcbiAgICBpZiAoZGF0YS5oaWRlID09PSB0cnVlKSB7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG5cbiAgICBkYXRhLmhpZGUgPSB0cnVlO1xuICAgIGRhdGEuYXR0cmlidXRlc1sneC1vdXQtb2YtYm91bmRhcmllcyddID0gJyc7XG4gIH0gZWxzZSB7XG4gICAgLy8gQXZvaWQgdW5uZWNlc3NhcnkgRE9NIGFjY2VzcyBpZiB2aXNpYmlsaXR5IGhhc24ndCBjaGFuZ2VkXG4gICAgaWYgKGRhdGEuaGlkZSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cblxuICAgIGRhdGEuaGlkZSA9IGZhbHNlO1xuICAgIGRhdGEuYXR0cmlidXRlc1sneC1vdXQtb2YtYm91bmRhcmllcyddID0gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gZGF0YTtcbn1cbiIsImltcG9ydCBnZXRDbGllbnRSZWN0IGZyb20gJy4uL3V0aWxzL2dldENsaWVudFJlY3QnO1xuaW1wb3J0IGdldE9wcG9zaXRlUGxhY2VtZW50IGZyb20gJy4uL3V0aWxzL2dldE9wcG9zaXRlUGxhY2VtZW50JztcblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiBNb2RpZmllcnNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSBgdXBkYXRlYCBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBkYXRhIG9iamVjdCwgcHJvcGVybHkgbW9kaWZpZWRcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaW5uZXIoZGF0YSkge1xuICBjb25zdCBwbGFjZW1lbnQgPSBkYXRhLnBsYWNlbWVudDtcbiAgY29uc3QgYmFzZVBsYWNlbWVudCA9IHBsYWNlbWVudC5zcGxpdCgnLScpWzBdO1xuICBjb25zdCB7IHBvcHBlciwgcmVmZXJlbmNlIH0gPSBkYXRhLm9mZnNldHM7XG4gIGNvbnN0IGlzSG9yaXogPSBbJ2xlZnQnLCAncmlnaHQnXS5pbmRleE9mKGJhc2VQbGFjZW1lbnQpICE9PSAtMTtcblxuICBjb25zdCBzdWJ0cmFjdExlbmd0aCA9IFsndG9wJywgJ2xlZnQnXS5pbmRleE9mKGJhc2VQbGFjZW1lbnQpID09PSAtMTtcblxuICBwb3BwZXJbaXNIb3JpeiA/ICdsZWZ0JyA6ICd0b3AnXSA9XG4gICAgcmVmZXJlbmNlW2Jhc2VQbGFjZW1lbnRdIC1cbiAgICAoc3VidHJhY3RMZW5ndGggPyBwb3BwZXJbaXNIb3JpeiA/ICd3aWR0aCcgOiAnaGVpZ2h0J10gOiAwKTtcblxuICBkYXRhLnBsYWNlbWVudCA9IGdldE9wcG9zaXRlUGxhY2VtZW50KHBsYWNlbWVudCk7XG4gIGRhdGEub2Zmc2V0cy5wb3BwZXIgPSBnZXRDbGllbnRSZWN0KHBvcHBlcik7XG5cbiAgcmV0dXJuIGRhdGE7XG59XG4iLCJpbXBvcnQgYXBwbHlTdHlsZSwgeyBhcHBseVN0eWxlT25Mb2FkIH0gZnJvbSAnLi9hcHBseVN0eWxlJztcbmltcG9ydCBjb21wdXRlU3R5bGUgZnJvbSAnLi9jb21wdXRlU3R5bGUnO1xuaW1wb3J0IGFycm93IGZyb20gJy4vYXJyb3cnO1xuaW1wb3J0IGZsaXAgZnJvbSAnLi9mbGlwJztcbmltcG9ydCBrZWVwVG9nZXRoZXIgZnJvbSAnLi9rZWVwVG9nZXRoZXInO1xuaW1wb3J0IG9mZnNldCBmcm9tICcuL29mZnNldCc7XG5pbXBvcnQgcHJldmVudE92ZXJmbG93IGZyb20gJy4vcHJldmVudE92ZXJmbG93JztcbmltcG9ydCBzaGlmdCBmcm9tICcuL3NoaWZ0JztcbmltcG9ydCBoaWRlIGZyb20gJy4vaGlkZSc7XG5pbXBvcnQgaW5uZXIgZnJvbSAnLi9pbm5lcic7XG5cbi8qKlxuICogTW9kaWZpZXIgZnVuY3Rpb24sIGVhY2ggbW9kaWZpZXIgY2FuIGhhdmUgYSBmdW5jdGlvbiBvZiB0aGlzIHR5cGUgYXNzaWduZWRcbiAqIHRvIGl0cyBgZm5gIHByb3BlcnR5LjxiciAvPlxuICogVGhlc2UgZnVuY3Rpb25zIHdpbGwgYmUgY2FsbGVkIG9uIGVhY2ggdXBkYXRlLCB0aGlzIG1lYW5zIHRoYXQgeW91IG11c3RcbiAqIG1ha2Ugc3VyZSB0aGV5IGFyZSBwZXJmb3JtYW50IGVub3VnaCB0byBhdm9pZCBwZXJmb3JtYW5jZSBib3R0bGVuZWNrcy5cbiAqXG4gKiBAZnVuY3Rpb24gTW9kaWZpZXJGblxuICogQGFyZ3VtZW50IHtkYXRhT2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSBgdXBkYXRlYCBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtkYXRhT2JqZWN0fSBUaGUgZGF0YSBvYmplY3QsIHByb3Blcmx5IG1vZGlmaWVkXG4gKi9cblxuLyoqXG4gKiBNb2RpZmllcnMgYXJlIHBsdWdpbnMgdXNlZCB0byBhbHRlciB0aGUgYmVoYXZpb3Igb2YgeW91ciBwb3BwZXJzLjxiciAvPlxuICogUG9wcGVyLmpzIHVzZXMgYSBzZXQgb2YgOSBtb2RpZmllcnMgdG8gcHJvdmlkZSBhbGwgdGhlIGJhc2ljIGZ1bmN0aW9uYWxpdGllc1xuICogbmVlZGVkIGJ5IHRoZSBsaWJyYXJ5LlxuICpcbiAqIFVzdWFsbHkgeW91IGRvbid0IHdhbnQgdG8gb3ZlcnJpZGUgdGhlIGBvcmRlcmAsIGBmbmAgYW5kIGBvbkxvYWRgIHByb3BzLlxuICogQWxsIHRoZSBvdGhlciBwcm9wZXJ0aWVzIGFyZSBjb25maWd1cmF0aW9ucyB0aGF0IGNvdWxkIGJlIHR3ZWFrZWQuXG4gKiBAbmFtZXNwYWNlIG1vZGlmaWVyc1xuICovXG5leHBvcnQgZGVmYXVsdCB7XG4gIC8qKlxuICAgKiBNb2RpZmllciB1c2VkIHRvIHNoaWZ0IHRoZSBwb3BwZXIgb24gdGhlIHN0YXJ0IG9yIGVuZCBvZiBpdHMgcmVmZXJlbmNlXG4gICAqIGVsZW1lbnQuPGJyIC8+XG4gICAqIEl0IHdpbGwgcmVhZCB0aGUgdmFyaWF0aW9uIG9mIHRoZSBgcGxhY2VtZW50YCBwcm9wZXJ0eS48YnIgLz5cbiAgICogSXQgY2FuIGJlIG9uZSBlaXRoZXIgYC1lbmRgIG9yIGAtc3RhcnRgLlxuICAgKiBAbWVtYmVyb2YgbW9kaWZpZXJzXG4gICAqIEBpbm5lclxuICAgKi9cbiAgc2hpZnQ6IHtcbiAgICAvKiogQHByb3Age251bWJlcn0gb3JkZXI9MTAwIC0gSW5kZXggdXNlZCB0byBkZWZpbmUgdGhlIG9yZGVyIG9mIGV4ZWN1dGlvbiAqL1xuICAgIG9yZGVyOiAxMDAsXG4gICAgLyoqIEBwcm9wIHtCb29sZWFufSBlbmFibGVkPXRydWUgLSBXaGV0aGVyIHRoZSBtb2RpZmllciBpcyBlbmFibGVkIG9yIG5vdCAqL1xuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgLyoqIEBwcm9wIHtNb2RpZmllckZufSAqL1xuICAgIGZuOiBzaGlmdCxcbiAgfSxcblxuICAvKipcbiAgICogVGhlIGBvZmZzZXRgIG1vZGlmaWVyIGNhbiBzaGlmdCB5b3VyIHBvcHBlciBvbiBib3RoIGl0cyBheGlzLlxuICAgKlxuICAgKiBJdCBhY2NlcHRzIHRoZSBmb2xsb3dpbmcgdW5pdHM6XG4gICAqIC0gYHB4YCBvciB1bml0LWxlc3MsIGludGVycHJldGVkIGFzIHBpeGVsc1xuICAgKiAtIGAlYCBvciBgJXJgLCBwZXJjZW50YWdlIHJlbGF0aXZlIHRvIHRoZSBsZW5ndGggb2YgdGhlIHJlZmVyZW5jZSBlbGVtZW50XG4gICAqIC0gYCVwYCwgcGVyY2VudGFnZSByZWxhdGl2ZSB0byB0aGUgbGVuZ3RoIG9mIHRoZSBwb3BwZXIgZWxlbWVudFxuICAgKiAtIGB2d2AsIENTUyB2aWV3cG9ydCB3aWR0aCB1bml0XG4gICAqIC0gYHZoYCwgQ1NTIHZpZXdwb3J0IGhlaWdodCB1bml0XG4gICAqXG4gICAqIEZvciBsZW5ndGggaXMgaW50ZW5kZWQgdGhlIG1haW4gYXhpcyByZWxhdGl2ZSB0byB0aGUgcGxhY2VtZW50IG9mIHRoZSBwb3BwZXIuPGJyIC8+XG4gICAqIFRoaXMgbWVhbnMgdGhhdCBpZiB0aGUgcGxhY2VtZW50IGlzIGB0b3BgIG9yIGBib3R0b21gLCB0aGUgbGVuZ3RoIHdpbGwgYmUgdGhlXG4gICAqIGB3aWR0aGAuIEluIGNhc2Ugb2YgYGxlZnRgIG9yIGByaWdodGAsIGl0IHdpbGwgYmUgdGhlIGBoZWlnaHRgLlxuICAgKlxuICAgKiBZb3UgY2FuIHByb3ZpZGUgYSBzaW5nbGUgdmFsdWUgKGFzIGBOdW1iZXJgIG9yIGBTdHJpbmdgKSwgb3IgYSBwYWlyIG9mIHZhbHVlc1xuICAgKiBhcyBgU3RyaW5nYCBkaXZpZGVkIGJ5IGEgY29tbWEgb3Igb25lIChvciBtb3JlKSB3aGl0ZSBzcGFjZXMuPGJyIC8+XG4gICAqIFRoZSBsYXR0ZXIgaXMgYSBkZXByZWNhdGVkIG1ldGhvZCBiZWNhdXNlIGl0IGxlYWRzIHRvIGNvbmZ1c2lvbiBhbmQgd2lsbCBiZVxuICAgKiByZW1vdmVkIGluIHYyLjxiciAvPlxuICAgKiBBZGRpdGlvbmFsbHksIGl0IGFjY2VwdHMgYWRkaXRpb25zIGFuZCBzdWJ0cmFjdGlvbnMgYmV0d2VlbiBkaWZmZXJlbnQgdW5pdHMuXG4gICAqIE5vdGUgdGhhdCBtdWx0aXBsaWNhdGlvbnMgYW5kIGRpdmlzaW9ucyBhcmVuJ3Qgc3VwcG9ydGVkLlxuICAgKlxuICAgKiBWYWxpZCBleGFtcGxlcyBhcmU6XG4gICAqIGBgYFxuICAgKiAxMFxuICAgKiAnMTAlJ1xuICAgKiAnMTAsIDEwJ1xuICAgKiAnMTAlLCAxMCdcbiAgICogJzEwICsgMTAlJ1xuICAgKiAnMTAgLSA1dmggKyAzJSdcbiAgICogJy0xMHB4ICsgNXZoLCA1cHggLSA2JSdcbiAgICogYGBgXG4gICAqID4gKipOQioqOiBJZiB5b3UgZGVzaXJlIHRvIGFwcGx5IG9mZnNldHMgdG8geW91ciBwb3BwZXJzIGluIGEgd2F5IHRoYXQgbWF5IG1ha2UgdGhlbSBvdmVybGFwXG4gICAqID4gd2l0aCB0aGVpciByZWZlcmVuY2UgZWxlbWVudCwgdW5mb3J0dW5hdGVseSwgeW91IHdpbGwgaGF2ZSB0byBkaXNhYmxlIHRoZSBgZmxpcGAgbW9kaWZpZXIuXG4gICAqID4gWW91IGNhbiByZWFkIG1vcmUgb24gdGhpcyBhdCB0aGlzIFtpc3N1ZV0oaHR0cHM6Ly9naXRodWIuY29tL0ZlelZyYXN0YS9wb3BwZXIuanMvaXNzdWVzLzM3MykuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBtb2RpZmllcnNcbiAgICogQGlubmVyXG4gICAqL1xuICBvZmZzZXQ6IHtcbiAgICAvKiogQHByb3Age251bWJlcn0gb3JkZXI9MjAwIC0gSW5kZXggdXNlZCB0byBkZWZpbmUgdGhlIG9yZGVyIG9mIGV4ZWN1dGlvbiAqL1xuICAgIG9yZGVyOiAyMDAsXG4gICAgLyoqIEBwcm9wIHtCb29sZWFufSBlbmFibGVkPXRydWUgLSBXaGV0aGVyIHRoZSBtb2RpZmllciBpcyBlbmFibGVkIG9yIG5vdCAqL1xuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgLyoqIEBwcm9wIHtNb2RpZmllckZufSAqL1xuICAgIGZuOiBvZmZzZXQsXG4gICAgLyoqIEBwcm9wIHtOdW1iZXJ8U3RyaW5nfSBvZmZzZXQ9MFxuICAgICAqIFRoZSBvZmZzZXQgdmFsdWUgYXMgZGVzY3JpYmVkIGluIHRoZSBtb2RpZmllciBkZXNjcmlwdGlvblxuICAgICAqL1xuICAgIG9mZnNldDogMCxcbiAgfSxcblxuICAvKipcbiAgICogTW9kaWZpZXIgdXNlZCB0byBwcmV2ZW50IHRoZSBwb3BwZXIgZnJvbSBiZWluZyBwb3NpdGlvbmVkIG91dHNpZGUgdGhlIGJvdW5kYXJ5LlxuICAgKlxuICAgKiBBIHNjZW5hcmlvIGV4aXN0cyB3aGVyZSB0aGUgcmVmZXJlbmNlIGl0c2VsZiBpcyBub3Qgd2l0aGluIHRoZSBib3VuZGFyaWVzLjxiciAvPlxuICAgKiBXZSBjYW4gc2F5IGl0IGhhcyBcImVzY2FwZWQgdGhlIGJvdW5kYXJpZXNcIiDigJQgb3IganVzdCBcImVzY2FwZWRcIi48YnIgLz5cbiAgICogSW4gdGhpcyBjYXNlIHdlIG5lZWQgdG8gZGVjaWRlIHdoZXRoZXIgdGhlIHBvcHBlciBzaG91bGQgZWl0aGVyOlxuICAgKlxuICAgKiAtIGRldGFjaCBmcm9tIHRoZSByZWZlcmVuY2UgYW5kIHJlbWFpbiBcInRyYXBwZWRcIiBpbiB0aGUgYm91bmRhcmllcywgb3JcbiAgICogLSBpZiBpdCBzaG91bGQgaWdub3JlIHRoZSBib3VuZGFyeSBhbmQgXCJlc2NhcGUgd2l0aCBpdHMgcmVmZXJlbmNlXCJcbiAgICpcbiAgICogV2hlbiBgZXNjYXBlV2l0aFJlZmVyZW5jZWAgaXMgc2V0IHRvYHRydWVgIGFuZCByZWZlcmVuY2UgaXMgY29tcGxldGVseVxuICAgKiBvdXRzaWRlIGl0cyBib3VuZGFyaWVzLCB0aGUgcG9wcGVyIHdpbGwgb3ZlcmZsb3cgKG9yIGNvbXBsZXRlbHkgbGVhdmUpXG4gICAqIHRoZSBib3VuZGFyaWVzIGluIG9yZGVyIHRvIHJlbWFpbiBhdHRhY2hlZCB0byB0aGUgZWRnZSBvZiB0aGUgcmVmZXJlbmNlLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgbW9kaWZpZXJzXG4gICAqIEBpbm5lclxuICAgKi9cbiAgcHJldmVudE92ZXJmbG93OiB7XG4gICAgLyoqIEBwcm9wIHtudW1iZXJ9IG9yZGVyPTMwMCAtIEluZGV4IHVzZWQgdG8gZGVmaW5lIHRoZSBvcmRlciBvZiBleGVjdXRpb24gKi9cbiAgICBvcmRlcjogMzAwLFxuICAgIC8qKiBAcHJvcCB7Qm9vbGVhbn0gZW5hYmxlZD10cnVlIC0gV2hldGhlciB0aGUgbW9kaWZpZXIgaXMgZW5hYmxlZCBvciBub3QgKi9cbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIC8qKiBAcHJvcCB7TW9kaWZpZXJGbn0gKi9cbiAgICBmbjogcHJldmVudE92ZXJmbG93LFxuICAgIC8qKlxuICAgICAqIEBwcm9wIHtBcnJheX0gW3ByaW9yaXR5PVsnbGVmdCcsJ3JpZ2h0JywndG9wJywnYm90dG9tJ11dXG4gICAgICogUG9wcGVyIHdpbGwgdHJ5IHRvIHByZXZlbnQgb3ZlcmZsb3cgZm9sbG93aW5nIHRoZXNlIHByaW9yaXRpZXMgYnkgZGVmYXVsdCxcbiAgICAgKiB0aGVuLCBpdCBjb3VsZCBvdmVyZmxvdyBvbiB0aGUgbGVmdCBhbmQgb24gdG9wIG9mIHRoZSBgYm91bmRhcmllc0VsZW1lbnRgXG4gICAgICovXG4gICAgcHJpb3JpdHk6IFsnbGVmdCcsICdyaWdodCcsICd0b3AnLCAnYm90dG9tJ10sXG4gICAgLyoqXG4gICAgICogQHByb3Age251bWJlcn0gcGFkZGluZz01XG4gICAgICogQW1vdW50IG9mIHBpeGVsIHVzZWQgdG8gZGVmaW5lIGEgbWluaW11bSBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBib3VuZGFyaWVzXG4gICAgICogYW5kIHRoZSBwb3BwZXIuIFRoaXMgbWFrZXMgc3VyZSB0aGUgcG9wcGVyIGFsd2F5cyBoYXMgYSBsaXR0bGUgcGFkZGluZ1xuICAgICAqIGJldHdlZW4gdGhlIGVkZ2VzIG9mIGl0cyBjb250YWluZXJcbiAgICAgKi9cbiAgICBwYWRkaW5nOiA1LFxuICAgIC8qKlxuICAgICAqIEBwcm9wIHtTdHJpbmd8SFRNTEVsZW1lbnR9IGJvdW5kYXJpZXNFbGVtZW50PSdzY3JvbGxQYXJlbnQnXG4gICAgICogQm91bmRhcmllcyB1c2VkIGJ5IHRoZSBtb2RpZmllci4gQ2FuIGJlIGBzY3JvbGxQYXJlbnRgLCBgd2luZG93YCxcbiAgICAgKiBgdmlld3BvcnRgIG9yIGFueSBET00gZWxlbWVudC5cbiAgICAgKi9cbiAgICBib3VuZGFyaWVzRWxlbWVudDogJ3Njcm9sbFBhcmVudCcsXG4gIH0sXG5cbiAgLyoqXG4gICAqIE1vZGlmaWVyIHVzZWQgdG8gbWFrZSBzdXJlIHRoZSByZWZlcmVuY2UgYW5kIGl0cyBwb3BwZXIgc3RheSBuZWFyIGVhY2ggb3RoZXJcbiAgICogd2l0aG91dCBsZWF2aW5nIGFueSBnYXAgYmV0d2VlbiB0aGUgdHdvLiBFc3BlY2lhbGx5IHVzZWZ1bCB3aGVuIHRoZSBhcnJvdyBpc1xuICAgKiBlbmFibGVkIGFuZCB5b3Ugd2FudCB0byBlbnN1cmUgdGhhdCBpdCBwb2ludHMgdG8gaXRzIHJlZmVyZW5jZSBlbGVtZW50LlxuICAgKiBJdCBjYXJlcyBvbmx5IGFib3V0IHRoZSBmaXJzdCBheGlzLiBZb3UgY2FuIHN0aWxsIGhhdmUgcG9wcGVycyB3aXRoIG1hcmdpblxuICAgKiBiZXR3ZWVuIHRoZSBwb3BwZXIgYW5kIGl0cyByZWZlcmVuY2UgZWxlbWVudC5cbiAgICogQG1lbWJlcm9mIG1vZGlmaWVyc1xuICAgKiBAaW5uZXJcbiAgICovXG4gIGtlZXBUb2dldGhlcjoge1xuICAgIC8qKiBAcHJvcCB7bnVtYmVyfSBvcmRlcj00MDAgLSBJbmRleCB1c2VkIHRvIGRlZmluZSB0aGUgb3JkZXIgb2YgZXhlY3V0aW9uICovXG4gICAgb3JkZXI6IDQwMCxcbiAgICAvKiogQHByb3Age0Jvb2xlYW59IGVuYWJsZWQ9dHJ1ZSAtIFdoZXRoZXIgdGhlIG1vZGlmaWVyIGlzIGVuYWJsZWQgb3Igbm90ICovXG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAvKiogQHByb3Age01vZGlmaWVyRm59ICovXG4gICAgZm46IGtlZXBUb2dldGhlcixcbiAgfSxcblxuICAvKipcbiAgICogVGhpcyBtb2RpZmllciBpcyB1c2VkIHRvIG1vdmUgdGhlIGBhcnJvd0VsZW1lbnRgIG9mIHRoZSBwb3BwZXIgdG8gbWFrZVxuICAgKiBzdXJlIGl0IGlzIHBvc2l0aW9uZWQgYmV0d2VlbiB0aGUgcmVmZXJlbmNlIGVsZW1lbnQgYW5kIGl0cyBwb3BwZXIgZWxlbWVudC5cbiAgICogSXQgd2lsbCByZWFkIHRoZSBvdXRlciBzaXplIG9mIHRoZSBgYXJyb3dFbGVtZW50YCBub2RlIHRvIGRldGVjdCBob3cgbWFueVxuICAgKiBwaXhlbHMgb2YgY29uanVuY3Rpb24gYXJlIG5lZWRlZC5cbiAgICpcbiAgICogSXQgaGFzIG5vIGVmZmVjdCBpZiBubyBgYXJyb3dFbGVtZW50YCBpcyBwcm92aWRlZC5cbiAgICogQG1lbWJlcm9mIG1vZGlmaWVyc1xuICAgKiBAaW5uZXJcbiAgICovXG4gIGFycm93OiB7XG4gICAgLyoqIEBwcm9wIHtudW1iZXJ9IG9yZGVyPTUwMCAtIEluZGV4IHVzZWQgdG8gZGVmaW5lIHRoZSBvcmRlciBvZiBleGVjdXRpb24gKi9cbiAgICBvcmRlcjogNTAwLFxuICAgIC8qKiBAcHJvcCB7Qm9vbGVhbn0gZW5hYmxlZD10cnVlIC0gV2hldGhlciB0aGUgbW9kaWZpZXIgaXMgZW5hYmxlZCBvciBub3QgKi9cbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIC8qKiBAcHJvcCB7TW9kaWZpZXJGbn0gKi9cbiAgICBmbjogYXJyb3csXG4gICAgLyoqIEBwcm9wIHtTdHJpbmd8SFRNTEVsZW1lbnR9IGVsZW1lbnQ9J1t4LWFycm93XScgLSBTZWxlY3RvciBvciBub2RlIHVzZWQgYXMgYXJyb3cgKi9cbiAgICBlbGVtZW50OiAnW3gtYXJyb3ddJyxcbiAgfSxcblxuICAvKipcbiAgICogTW9kaWZpZXIgdXNlZCB0byBmbGlwIHRoZSBwb3BwZXIncyBwbGFjZW1lbnQgd2hlbiBpdCBzdGFydHMgdG8gb3ZlcmxhcCBpdHNcbiAgICogcmVmZXJlbmNlIGVsZW1lbnQuXG4gICAqXG4gICAqIFJlcXVpcmVzIHRoZSBgcHJldmVudE92ZXJmbG93YCBtb2RpZmllciBiZWZvcmUgaXQgaW4gb3JkZXIgdG8gd29yay5cbiAgICpcbiAgICogKipOT1RFOioqIHRoaXMgbW9kaWZpZXIgd2lsbCBpbnRlcnJ1cHQgdGhlIGN1cnJlbnQgdXBkYXRlIGN5Y2xlIGFuZCB3aWxsXG4gICAqIHJlc3RhcnQgaXQgaWYgaXQgZGV0ZWN0cyB0aGUgbmVlZCB0byBmbGlwIHRoZSBwbGFjZW1lbnQuXG4gICAqIEBtZW1iZXJvZiBtb2RpZmllcnNcbiAgICogQGlubmVyXG4gICAqL1xuICBmbGlwOiB7XG4gICAgLyoqIEBwcm9wIHtudW1iZXJ9IG9yZGVyPTYwMCAtIEluZGV4IHVzZWQgdG8gZGVmaW5lIHRoZSBvcmRlciBvZiBleGVjdXRpb24gKi9cbiAgICBvcmRlcjogNjAwLFxuICAgIC8qKiBAcHJvcCB7Qm9vbGVhbn0gZW5hYmxlZD10cnVlIC0gV2hldGhlciB0aGUgbW9kaWZpZXIgaXMgZW5hYmxlZCBvciBub3QgKi9cbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIC8qKiBAcHJvcCB7TW9kaWZpZXJGbn0gKi9cbiAgICBmbjogZmxpcCxcbiAgICAvKipcbiAgICAgKiBAcHJvcCB7U3RyaW5nfEFycmF5fSBiZWhhdmlvcj0nZmxpcCdcbiAgICAgKiBUaGUgYmVoYXZpb3IgdXNlZCB0byBjaGFuZ2UgdGhlIHBvcHBlcidzIHBsYWNlbWVudC4gSXQgY2FuIGJlIG9uZSBvZlxuICAgICAqIGBmbGlwYCwgYGNsb2Nrd2lzZWAsIGBjb3VudGVyY2xvY2t3aXNlYCBvciBhbiBhcnJheSB3aXRoIGEgbGlzdCBvZiB2YWxpZFxuICAgICAqIHBsYWNlbWVudHMgKHdpdGggb3B0aW9uYWwgdmFyaWF0aW9ucylcbiAgICAgKi9cbiAgICBiZWhhdmlvcjogJ2ZsaXAnLFxuICAgIC8qKlxuICAgICAqIEBwcm9wIHtudW1iZXJ9IHBhZGRpbmc9NVxuICAgICAqIFRoZSBwb3BwZXIgd2lsbCBmbGlwIGlmIGl0IGhpdHMgdGhlIGVkZ2VzIG9mIHRoZSBgYm91bmRhcmllc0VsZW1lbnRgXG4gICAgICovXG4gICAgcGFkZGluZzogNSxcbiAgICAvKipcbiAgICAgKiBAcHJvcCB7U3RyaW5nfEhUTUxFbGVtZW50fSBib3VuZGFyaWVzRWxlbWVudD0ndmlld3BvcnQnXG4gICAgICogVGhlIGVsZW1lbnQgd2hpY2ggd2lsbCBkZWZpbmUgdGhlIGJvdW5kYXJpZXMgb2YgdGhlIHBvcHBlciBwb3NpdGlvbi5cbiAgICAgKiBUaGUgcG9wcGVyIHdpbGwgbmV2ZXIgYmUgcGxhY2VkIG91dHNpZGUgb2YgdGhlIGRlZmluZWQgYm91bmRhcmllc1xuICAgICAqIChleGNlcHQgaWYgYGtlZXBUb2dldGhlcmAgaXMgZW5hYmxlZClcbiAgICAgKi9cbiAgICBib3VuZGFyaWVzRWxlbWVudDogJ3ZpZXdwb3J0JyxcbiAgICAvKipcbiAgICAgKiBAcHJvcCB7Qm9vbGVhbn0gZmxpcFZhcmlhdGlvbnM9ZmFsc2VcbiAgICAgKiBUaGUgcG9wcGVyIHdpbGwgc3dpdGNoIHBsYWNlbWVudCB2YXJpYXRpb24gYmV0d2VlbiBgLXN0YXJ0YCBhbmQgYC1lbmRgIHdoZW5cbiAgICAgKiB0aGUgcmVmZXJlbmNlIGVsZW1lbnQgb3ZlcmxhcHMgaXRzIGJvdW5kYXJpZXMuXG4gICAgICpcbiAgICAgKiBUaGUgb3JpZ2luYWwgcGxhY2VtZW50IHNob3VsZCBoYXZlIGEgc2V0IHZhcmlhdGlvbi5cbiAgICAgKi9cbiAgICBmbGlwVmFyaWF0aW9uczogZmFsc2UsXG4gICAgLyoqXG4gICAgICogQHByb3Age0Jvb2xlYW59IGZsaXBWYXJpYXRpb25zQnlDb250ZW50PWZhbHNlXG4gICAgICogVGhlIHBvcHBlciB3aWxsIHN3aXRjaCBwbGFjZW1lbnQgdmFyaWF0aW9uIGJldHdlZW4gYC1zdGFydGAgYW5kIGAtZW5kYCB3aGVuXG4gICAgICogdGhlIHBvcHBlciBlbGVtZW50IG92ZXJsYXBzIGl0cyByZWZlcmVuY2UgYm91bmRhcmllcy5cbiAgICAgKlxuICAgICAqIFRoZSBvcmlnaW5hbCBwbGFjZW1lbnQgc2hvdWxkIGhhdmUgYSBzZXQgdmFyaWF0aW9uLlxuICAgICAqL1xuICAgIGZsaXBWYXJpYXRpb25zQnlDb250ZW50OiBmYWxzZSxcbiAgfSxcblxuICAvKipcbiAgICogTW9kaWZpZXIgdXNlZCB0byBtYWtlIHRoZSBwb3BwZXIgZmxvdyB0b3dhcmQgdGhlIGlubmVyIG9mIHRoZSByZWZlcmVuY2UgZWxlbWVudC5cbiAgICogQnkgZGVmYXVsdCwgd2hlbiB0aGlzIG1vZGlmaWVyIGlzIGRpc2FibGVkLCB0aGUgcG9wcGVyIHdpbGwgYmUgcGxhY2VkIG91dHNpZGVcbiAgICogdGhlIHJlZmVyZW5jZSBlbGVtZW50LlxuICAgKiBAbWVtYmVyb2YgbW9kaWZpZXJzXG4gICAqIEBpbm5lclxuICAgKi9cbiAgaW5uZXI6IHtcbiAgICAvKiogQHByb3Age251bWJlcn0gb3JkZXI9NzAwIC0gSW5kZXggdXNlZCB0byBkZWZpbmUgdGhlIG9yZGVyIG9mIGV4ZWN1dGlvbiAqL1xuICAgIG9yZGVyOiA3MDAsXG4gICAgLyoqIEBwcm9wIHtCb29sZWFufSBlbmFibGVkPWZhbHNlIC0gV2hldGhlciB0aGUgbW9kaWZpZXIgaXMgZW5hYmxlZCBvciBub3QgKi9cbiAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAvKiogQHByb3Age01vZGlmaWVyRm59ICovXG4gICAgZm46IGlubmVyLFxuICB9LFxuXG4gIC8qKlxuICAgKiBNb2RpZmllciB1c2VkIHRvIGhpZGUgdGhlIHBvcHBlciB3aGVuIGl0cyByZWZlcmVuY2UgZWxlbWVudCBpcyBvdXRzaWRlIG9mIHRoZVxuICAgKiBwb3BwZXIgYm91bmRhcmllcy4gSXQgd2lsbCBzZXQgYSBgeC1vdXQtb2YtYm91bmRhcmllc2AgYXR0cmlidXRlIHdoaWNoIGNhblxuICAgKiBiZSB1c2VkIHRvIGhpZGUgd2l0aCBhIENTUyBzZWxlY3RvciB0aGUgcG9wcGVyIHdoZW4gaXRzIHJlZmVyZW5jZSBpc1xuICAgKiBvdXQgb2YgYm91bmRhcmllcy5cbiAgICpcbiAgICogUmVxdWlyZXMgdGhlIGBwcmV2ZW50T3ZlcmZsb3dgIG1vZGlmaWVyIGJlZm9yZSBpdCBpbiBvcmRlciB0byB3b3JrLlxuICAgKiBAbWVtYmVyb2YgbW9kaWZpZXJzXG4gICAqIEBpbm5lclxuICAgKi9cbiAgaGlkZToge1xuICAgIC8qKiBAcHJvcCB7bnVtYmVyfSBvcmRlcj04MDAgLSBJbmRleCB1c2VkIHRvIGRlZmluZSB0aGUgb3JkZXIgb2YgZXhlY3V0aW9uICovXG4gICAgb3JkZXI6IDgwMCxcbiAgICAvKiogQHByb3Age0Jvb2xlYW59IGVuYWJsZWQ9dHJ1ZSAtIFdoZXRoZXIgdGhlIG1vZGlmaWVyIGlzIGVuYWJsZWQgb3Igbm90ICovXG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAvKiogQHByb3Age01vZGlmaWVyRm59ICovXG4gICAgZm46IGhpZGUsXG4gIH0sXG5cbiAgLyoqXG4gICAqIENvbXB1dGVzIHRoZSBzdHlsZSB0aGF0IHdpbGwgYmUgYXBwbGllZCB0byB0aGUgcG9wcGVyIGVsZW1lbnQgdG8gZ2V0c1xuICAgKiBwcm9wZXJseSBwb3NpdGlvbmVkLlxuICAgKlxuICAgKiBOb3RlIHRoYXQgdGhpcyBtb2RpZmllciB3aWxsIG5vdCB0b3VjaCB0aGUgRE9NLCBpdCBqdXN0IHByZXBhcmVzIHRoZSBzdHlsZXNcbiAgICogc28gdGhhdCBgYXBwbHlTdHlsZWAgbW9kaWZpZXIgY2FuIGFwcGx5IGl0LiBUaGlzIHNlcGFyYXRpb24gaXMgdXNlZnVsXG4gICAqIGluIGNhc2UgeW91IG5lZWQgdG8gcmVwbGFjZSBgYXBwbHlTdHlsZWAgd2l0aCBhIGN1c3RvbSBpbXBsZW1lbnRhdGlvbi5cbiAgICpcbiAgICogVGhpcyBtb2RpZmllciBoYXMgYDg1MGAgYXMgYG9yZGVyYCB2YWx1ZSB0byBtYWludGFpbiBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XG4gICAqIHdpdGggcHJldmlvdXMgdmVyc2lvbnMgb2YgUG9wcGVyLmpzLiBFeHBlY3QgdGhlIG1vZGlmaWVycyBvcmRlcmluZyBtZXRob2RcbiAgICogdG8gY2hhbmdlIGluIGZ1dHVyZSBtYWpvciB2ZXJzaW9ucyBvZiB0aGUgbGlicmFyeS5cbiAgICpcbiAgICogQG1lbWJlcm9mIG1vZGlmaWVyc1xuICAgKiBAaW5uZXJcbiAgICovXG4gIGNvbXB1dGVTdHlsZToge1xuICAgIC8qKiBAcHJvcCB7bnVtYmVyfSBvcmRlcj04NTAgLSBJbmRleCB1c2VkIHRvIGRlZmluZSB0aGUgb3JkZXIgb2YgZXhlY3V0aW9uICovXG4gICAgb3JkZXI6IDg1MCxcbiAgICAvKiogQHByb3Age0Jvb2xlYW59IGVuYWJsZWQ9dHJ1ZSAtIFdoZXRoZXIgdGhlIG1vZGlmaWVyIGlzIGVuYWJsZWQgb3Igbm90ICovXG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAvKiogQHByb3Age01vZGlmaWVyRm59ICovXG4gICAgZm46IGNvbXB1dGVTdHlsZSxcbiAgICAvKipcbiAgICAgKiBAcHJvcCB7Qm9vbGVhbn0gZ3B1QWNjZWxlcmF0aW9uPXRydWVcbiAgICAgKiBJZiB0cnVlLCBpdCB1c2VzIHRoZSBDU1MgM0QgdHJhbnNmb3JtYXRpb24gdG8gcG9zaXRpb24gdGhlIHBvcHBlci5cbiAgICAgKiBPdGhlcndpc2UsIGl0IHdpbGwgdXNlIHRoZSBgdG9wYCBhbmQgYGxlZnRgIHByb3BlcnRpZXNcbiAgICAgKi9cbiAgICBncHVBY2NlbGVyYXRpb246IHRydWUsXG4gICAgLyoqXG4gICAgICogQHByb3Age3N0cmluZ30gW3g9J2JvdHRvbSddXG4gICAgICogV2hlcmUgdG8gYW5jaG9yIHRoZSBYIGF4aXMgKGBib3R0b21gIG9yIGB0b3BgKS4gQUtBIFggb2Zmc2V0IG9yaWdpbi5cbiAgICAgKiBDaGFuZ2UgdGhpcyBpZiB5b3VyIHBvcHBlciBzaG91bGQgZ3JvdyBpbiBhIGRpcmVjdGlvbiBkaWZmZXJlbnQgZnJvbSBgYm90dG9tYFxuICAgICAqL1xuICAgIHg6ICdib3R0b20nLFxuICAgIC8qKlxuICAgICAqIEBwcm9wIHtzdHJpbmd9IFt4PSdsZWZ0J11cbiAgICAgKiBXaGVyZSB0byBhbmNob3IgdGhlIFkgYXhpcyAoYGxlZnRgIG9yIGByaWdodGApLiBBS0EgWSBvZmZzZXQgb3JpZ2luLlxuICAgICAqIENoYW5nZSB0aGlzIGlmIHlvdXIgcG9wcGVyIHNob3VsZCBncm93IGluIGEgZGlyZWN0aW9uIGRpZmZlcmVudCBmcm9tIGByaWdodGBcbiAgICAgKi9cbiAgICB5OiAncmlnaHQnLFxuICB9LFxuXG4gIC8qKlxuICAgKiBBcHBsaWVzIHRoZSBjb21wdXRlZCBzdHlsZXMgdG8gdGhlIHBvcHBlciBlbGVtZW50LlxuICAgKlxuICAgKiBBbGwgdGhlIERPTSBtYW5pcHVsYXRpb25zIGFyZSBsaW1pdGVkIHRvIHRoaXMgbW9kaWZpZXIuIFRoaXMgaXMgdXNlZnVsIGluIGNhc2VcbiAgICogeW91IHdhbnQgdG8gaW50ZWdyYXRlIFBvcHBlci5qcyBpbnNpZGUgYSBmcmFtZXdvcmsgb3IgdmlldyBsaWJyYXJ5IGFuZCB5b3VcbiAgICogd2FudCB0byBkZWxlZ2F0ZSBhbGwgdGhlIERPTSBtYW5pcHVsYXRpb25zIHRvIGl0LlxuICAgKlxuICAgKiBOb3RlIHRoYXQgaWYgeW91IGRpc2FibGUgdGhpcyBtb2RpZmllciwgeW91IG11c3QgbWFrZSBzdXJlIHRoZSBwb3BwZXIgZWxlbWVudFxuICAgKiBoYXMgaXRzIHBvc2l0aW9uIHNldCB0byBgYWJzb2x1dGVgIGJlZm9yZSBQb3BwZXIuanMgY2FuIGRvIGl0cyB3b3JrIVxuICAgKlxuICAgKiBKdXN0IGRpc2FibGUgdGhpcyBtb2RpZmllciBhbmQgZGVmaW5lIHlvdXIgb3duIHRvIGFjaGlldmUgdGhlIGRlc2lyZWQgZWZmZWN0LlxuICAgKlxuICAgKiBAbWVtYmVyb2YgbW9kaWZpZXJzXG4gICAqIEBpbm5lclxuICAgKi9cbiAgYXBwbHlTdHlsZToge1xuICAgIC8qKiBAcHJvcCB7bnVtYmVyfSBvcmRlcj05MDAgLSBJbmRleCB1c2VkIHRvIGRlZmluZSB0aGUgb3JkZXIgb2YgZXhlY3V0aW9uICovXG4gICAgb3JkZXI6IDkwMCxcbiAgICAvKiogQHByb3Age0Jvb2xlYW59IGVuYWJsZWQ9dHJ1ZSAtIFdoZXRoZXIgdGhlIG1vZGlmaWVyIGlzIGVuYWJsZWQgb3Igbm90ICovXG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAvKiogQHByb3Age01vZGlmaWVyRm59ICovXG4gICAgZm46IGFwcGx5U3R5bGUsXG4gICAgLyoqIEBwcm9wIHtGdW5jdGlvbn0gKi9cbiAgICBvbkxvYWQ6IGFwcGx5U3R5bGVPbkxvYWQsXG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAxLjEwLjAsIHRoZSBwcm9wZXJ0eSBtb3ZlZCB0byBgY29tcHV0ZVN0eWxlYCBtb2RpZmllclxuICAgICAqIEBwcm9wIHtCb29sZWFufSBncHVBY2NlbGVyYXRpb249dHJ1ZVxuICAgICAqIElmIHRydWUsIGl0IHVzZXMgdGhlIENTUyAzRCB0cmFuc2Zvcm1hdGlvbiB0byBwb3NpdGlvbiB0aGUgcG9wcGVyLlxuICAgICAqIE90aGVyd2lzZSwgaXQgd2lsbCB1c2UgdGhlIGB0b3BgIGFuZCBgbGVmdGAgcHJvcGVydGllc1xuICAgICAqL1xuICAgIGdwdUFjY2VsZXJhdGlvbjogdW5kZWZpbmVkLFxuICB9LFxufTtcblxuLyoqXG4gKiBUaGUgYGRhdGFPYmplY3RgIGlzIGFuIG9iamVjdCBjb250YWluaW5nIGFsbCB0aGUgaW5mb3JtYXRpb24gdXNlZCBieSBQb3BwZXIuanMuXG4gKiBUaGlzIG9iamVjdCBpcyBwYXNzZWQgdG8gbW9kaWZpZXJzIGFuZCB0byB0aGUgYG9uQ3JlYXRlYCBhbmQgYG9uVXBkYXRlYCBjYWxsYmFja3MuXG4gKiBAbmFtZSBkYXRhT2JqZWN0XG4gKiBAcHJvcGVydHkge09iamVjdH0gZGF0YS5pbnN0YW5jZSBUaGUgUG9wcGVyLmpzIGluc3RhbmNlXG4gKiBAcHJvcGVydHkge1N0cmluZ30gZGF0YS5wbGFjZW1lbnQgUGxhY2VtZW50IGFwcGxpZWQgdG8gcG9wcGVyXG4gKiBAcHJvcGVydHkge1N0cmluZ30gZGF0YS5vcmlnaW5hbFBsYWNlbWVudCBQbGFjZW1lbnQgb3JpZ2luYWxseSBkZWZpbmVkIG9uIGluaXRcbiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gZGF0YS5mbGlwcGVkIFRydWUgaWYgcG9wcGVyIGhhcyBiZWVuIGZsaXBwZWQgYnkgZmxpcCBtb2RpZmllclxuICogQHByb3BlcnR5IHtCb29sZWFufSBkYXRhLmhpZGUgVHJ1ZSBpZiB0aGUgcmVmZXJlbmNlIGVsZW1lbnQgaXMgb3V0IG9mIGJvdW5kYXJpZXMsIHVzZWZ1bCB0byBrbm93IHdoZW4gdG8gaGlkZSB0aGUgcG9wcGVyXG4gKiBAcHJvcGVydHkge0hUTUxFbGVtZW50fSBkYXRhLmFycm93RWxlbWVudCBOb2RlIHVzZWQgYXMgYXJyb3cgYnkgYXJyb3cgbW9kaWZpZXJcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBkYXRhLnN0eWxlcyBBbnkgQ1NTIHByb3BlcnR5IGRlZmluZWQgaGVyZSB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIHBvcHBlci4gSXQgZXhwZWN0cyB0aGUgSmF2YVNjcmlwdCBub21lbmNsYXR1cmUgKGVnLiBgbWFyZ2luQm90dG9tYClcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBkYXRhLmFycm93U3R5bGVzIEFueSBDU1MgcHJvcGVydHkgZGVmaW5lZCBoZXJlIHdpbGwgYmUgYXBwbGllZCB0byB0aGUgcG9wcGVyIGFycm93LiBJdCBleHBlY3RzIHRoZSBKYXZhU2NyaXB0IG5vbWVuY2xhdHVyZSAoZWcuIGBtYXJnaW5Cb3R0b21gKVxuICogQHByb3BlcnR5IHtPYmplY3R9IGRhdGEuYm91bmRhcmllcyBPZmZzZXRzIG9mIHRoZSBwb3BwZXIgYm91bmRhcmllc1xuICogQHByb3BlcnR5IHtPYmplY3R9IGRhdGEub2Zmc2V0cyBUaGUgbWVhc3VyZW1lbnRzIG9mIHBvcHBlciwgcmVmZXJlbmNlIGFuZCBhcnJvdyBlbGVtZW50c1xuICogQHByb3BlcnR5IHtPYmplY3R9IGRhdGEub2Zmc2V0cy5wb3BwZXIgYHRvcGAsIGBsZWZ0YCwgYHdpZHRoYCwgYGhlaWdodGAgdmFsdWVzXG4gKiBAcHJvcGVydHkge09iamVjdH0gZGF0YS5vZmZzZXRzLnJlZmVyZW5jZSBgdG9wYCwgYGxlZnRgLCBgd2lkdGhgLCBgaGVpZ2h0YCB2YWx1ZXNcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBkYXRhLm9mZnNldHMuYXJyb3ddIGB0b3BgIGFuZCBgbGVmdGAgb2Zmc2V0cywgb25seSBvbmUgb2YgdGhlbSB3aWxsIGJlIGRpZmZlcmVudCBmcm9tIDBcbiAqL1xuIiwiaW1wb3J0IG1vZGlmaWVycyBmcm9tICcuLi9tb2RpZmllcnMvaW5kZXgnO1xuXG4vKipcbiAqIERlZmF1bHQgb3B0aW9ucyBwcm92aWRlZCB0byBQb3BwZXIuanMgY29uc3RydWN0b3IuPGJyIC8+XG4gKiBUaGVzZSBjYW4gYmUgb3ZlcnJpZGRlbiB1c2luZyB0aGUgYG9wdGlvbnNgIGFyZ3VtZW50IG9mIFBvcHBlci5qcy48YnIgLz5cbiAqIFRvIG92ZXJyaWRlIGFuIG9wdGlvbiwgc2ltcGx5IHBhc3MgYW4gb2JqZWN0IHdpdGggdGhlIHNhbWVcbiAqIHN0cnVjdHVyZSBvZiB0aGUgYG9wdGlvbnNgIG9iamVjdCwgYXMgdGhlIDNyZCBhcmd1bWVudC4gRm9yIGV4YW1wbGU6XG4gKiBgYGBcbiAqIG5ldyBQb3BwZXIocmVmLCBwb3AsIHtcbiAqICAgbW9kaWZpZXJzOiB7XG4gKiAgICAgcHJldmVudE92ZXJmbG93OiB7IGVuYWJsZWQ6IGZhbHNlIH1cbiAqICAgfVxuICogfSlcbiAqIGBgYFxuICogQHR5cGUge09iamVjdH1cbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJvZiBQb3BwZXJcbiAqL1xuZXhwb3J0IGRlZmF1bHQge1xuICAvKipcbiAgICogUG9wcGVyJ3MgcGxhY2VtZW50LlxuICAgKiBAcHJvcCB7UG9wcGVyLnBsYWNlbWVudHN9IHBsYWNlbWVudD0nYm90dG9tJ1xuICAgKi9cbiAgcGxhY2VtZW50OiAnYm90dG9tJyxcblxuICAvKipcbiAgICogU2V0IHRoaXMgdG8gdHJ1ZSBpZiB5b3Ugd2FudCBwb3BwZXIgdG8gcG9zaXRpb24gaXQgc2VsZiBpbiAnZml4ZWQnIG1vZGVcbiAgICogQHByb3Age0Jvb2xlYW59IHBvc2l0aW9uRml4ZWQ9ZmFsc2VcbiAgICovXG4gIHBvc2l0aW9uRml4ZWQ6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIGV2ZW50cyAocmVzaXplLCBzY3JvbGwpIGFyZSBpbml0aWFsbHkgZW5hYmxlZC5cbiAgICogQHByb3Age0Jvb2xlYW59IGV2ZW50c0VuYWJsZWQ9dHJ1ZVxuICAgKi9cbiAgZXZlbnRzRW5hYmxlZDogdHJ1ZSxcblxuICAvKipcbiAgICogU2V0IHRvIHRydWUgaWYgeW91IHdhbnQgdG8gYXV0b21hdGljYWxseSByZW1vdmUgdGhlIHBvcHBlciB3aGVuXG4gICAqIHlvdSBjYWxsIHRoZSBgZGVzdHJveWAgbWV0aG9kLlxuICAgKiBAcHJvcCB7Qm9vbGVhbn0gcmVtb3ZlT25EZXN0cm95PWZhbHNlXG4gICAqL1xuICByZW1vdmVPbkRlc3Ryb3k6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBDYWxsYmFjayBjYWxsZWQgd2hlbiB0aGUgcG9wcGVyIGlzIGNyZWF0ZWQuPGJyIC8+XG4gICAqIEJ5IGRlZmF1bHQsIGl0IGlzIHNldCB0byBuby1vcC48YnIgLz5cbiAgICogQWNjZXNzIFBvcHBlci5qcyBpbnN0YW5jZSB3aXRoIGBkYXRhLmluc3RhbmNlYC5cbiAgICogQHByb3Age29uQ3JlYXRlfVxuICAgKi9cbiAgb25DcmVhdGU6ICgpID0+IHt9LFxuXG4gIC8qKlxuICAgKiBDYWxsYmFjayBjYWxsZWQgd2hlbiB0aGUgcG9wcGVyIGlzIHVwZGF0ZWQuIFRoaXMgY2FsbGJhY2sgaXMgbm90IGNhbGxlZFxuICAgKiBvbiB0aGUgaW5pdGlhbGl6YXRpb24vY3JlYXRpb24gb2YgdGhlIHBvcHBlciwgYnV0IG9ubHkgb24gc3Vic2VxdWVudFxuICAgKiB1cGRhdGVzLjxiciAvPlxuICAgKiBCeSBkZWZhdWx0LCBpdCBpcyBzZXQgdG8gbm8tb3AuPGJyIC8+XG4gICAqIEFjY2VzcyBQb3BwZXIuanMgaW5zdGFuY2Ugd2l0aCBgZGF0YS5pbnN0YW5jZWAuXG4gICAqIEBwcm9wIHtvblVwZGF0ZX1cbiAgICovXG4gIG9uVXBkYXRlOiAoKSA9PiB7fSxcblxuICAvKipcbiAgICogTGlzdCBvZiBtb2RpZmllcnMgdXNlZCB0byBtb2RpZnkgdGhlIG9mZnNldHMgYmVmb3JlIHRoZXkgYXJlIGFwcGxpZWQgdG8gdGhlIHBvcHBlci5cbiAgICogVGhleSBwcm92aWRlIG1vc3Qgb2YgdGhlIGZ1bmN0aW9uYWxpdGllcyBvZiBQb3BwZXIuanMuXG4gICAqIEBwcm9wIHttb2RpZmllcnN9XG4gICAqL1xuICBtb2RpZmllcnMsXG59O1xuXG4vKipcbiAqIEBjYWxsYmFjayBvbkNyZWF0ZVxuICogQHBhcmFtIHtkYXRhT2JqZWN0fSBkYXRhXG4gKi9cblxuLyoqXG4gKiBAY2FsbGJhY2sgb25VcGRhdGVcbiAqIEBwYXJhbSB7ZGF0YU9iamVjdH0gZGF0YVxuICovXG4iLCIvLyBVdGlsc1xuaW1wb3J0IGRlYm91bmNlIGZyb20gJy4vdXRpbHMvZGVib3VuY2UnO1xuaW1wb3J0IGlzRnVuY3Rpb24gZnJvbSAnLi91dGlscy9pc0Z1bmN0aW9uJztcblxuLy8gTWV0aG9kc1xuaW1wb3J0IHVwZGF0ZSBmcm9tICcuL21ldGhvZHMvdXBkYXRlJztcbmltcG9ydCBkZXN0cm95IGZyb20gJy4vbWV0aG9kcy9kZXN0cm95JztcbmltcG9ydCBlbmFibGVFdmVudExpc3RlbmVycyBmcm9tICcuL21ldGhvZHMvZW5hYmxlRXZlbnRMaXN0ZW5lcnMnO1xuaW1wb3J0IGRpc2FibGVFdmVudExpc3RlbmVycyBmcm9tICcuL21ldGhvZHMvZGlzYWJsZUV2ZW50TGlzdGVuZXJzJztcbmltcG9ydCBEZWZhdWx0cyBmcm9tICcuL21ldGhvZHMvZGVmYXVsdHMnO1xuaW1wb3J0IHBsYWNlbWVudHMgZnJvbSAnLi9tZXRob2RzL3BsYWNlbWVudHMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQb3BwZXIge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBQb3BwZXIuanMgaW5zdGFuY2UuXG4gICAqIEBjbGFzcyBQb3BwZXJcbiAgICogQHBhcmFtIHtFbGVtZW50fHJlZmVyZW5jZU9iamVjdH0gcmVmZXJlbmNlIC0gVGhlIHJlZmVyZW5jZSBlbGVtZW50IHVzZWQgdG8gcG9zaXRpb24gdGhlIHBvcHBlclxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IHBvcHBlciAtIFRoZSBIVE1MIC8gWE1MIGVsZW1lbnQgdXNlZCBhcyB0aGUgcG9wcGVyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gWW91ciBjdXN0b20gb3B0aW9ucyB0byBvdmVycmlkZSB0aGUgb25lcyBkZWZpbmVkIGluIFtEZWZhdWx0c10oI2RlZmF1bHRzKVxuICAgKiBAcmV0dXJuIHtPYmplY3R9IGluc3RhbmNlIC0gVGhlIGdlbmVyYXRlZCBQb3BwZXIuanMgaW5zdGFuY2VcbiAgICovXG4gIGNvbnN0cnVjdG9yKHJlZmVyZW5jZSwgcG9wcGVyLCBvcHRpb25zID0ge30pIHtcbiAgICAvLyBtYWtlIHVwZGF0ZSgpIGRlYm91bmNlZCwgc28gdGhhdCBpdCBvbmx5IHJ1bnMgYXQgbW9zdCBvbmNlLXBlci10aWNrXG4gICAgdGhpcy51cGRhdGUgPSBkZWJvdW5jZSh0aGlzLnVwZGF0ZS5iaW5kKHRoaXMpKTtcblxuICAgIC8vIHdpdGgge30gd2UgY3JlYXRlIGEgbmV3IG9iamVjdCB3aXRoIHRoZSBvcHRpb25zIGluc2lkZSBpdFxuICAgIHRoaXMub3B0aW9ucyA9IHsgLi4uUG9wcGVyLkRlZmF1bHRzLCAuLi5vcHRpb25zIH07XG5cbiAgICAvLyBpbml0IHN0YXRlXG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIGlzRGVzdHJveWVkOiBmYWxzZSxcbiAgICAgIGlzQ3JlYXRlZDogZmFsc2UsXG4gICAgICBzY3JvbGxQYXJlbnRzOiBbXSxcbiAgICB9O1xuXG4gICAgLy8gZ2V0IHJlZmVyZW5jZSBhbmQgcG9wcGVyIGVsZW1lbnRzIChhbGxvdyBqUXVlcnkgd3JhcHBlcnMpXG4gICAgdGhpcy5yZWZlcmVuY2UgPSByZWZlcmVuY2UgJiYgcmVmZXJlbmNlLmpxdWVyeSA/IHJlZmVyZW5jZVswXSA6IHJlZmVyZW5jZTtcbiAgICB0aGlzLnBvcHBlciA9IHBvcHBlciAmJiBwb3BwZXIuanF1ZXJ5ID8gcG9wcGVyWzBdIDogcG9wcGVyO1xuXG4gICAgLy8gRGVlcCBtZXJnZSBtb2RpZmllcnMgb3B0aW9uc1xuICAgIHRoaXMub3B0aW9ucy5tb2RpZmllcnMgPSB7fTtcbiAgICBPYmplY3Qua2V5cyh7XG4gICAgICAuLi5Qb3BwZXIuRGVmYXVsdHMubW9kaWZpZXJzLFxuICAgICAgLi4ub3B0aW9ucy5tb2RpZmllcnMsXG4gICAgfSkuZm9yRWFjaChuYW1lID0+IHtcbiAgICAgIHRoaXMub3B0aW9ucy5tb2RpZmllcnNbbmFtZV0gPSB7XG4gICAgICAgIC8vIElmIGl0J3MgYSBidWlsdC1pbiBtb2RpZmllciwgdXNlIGl0IGFzIGJhc2VcbiAgICAgICAgLi4uKFBvcHBlci5EZWZhdWx0cy5tb2RpZmllcnNbbmFtZV0gfHwge30pLFxuICAgICAgICAvLyBJZiB0aGVyZSBhcmUgY3VzdG9tIG9wdGlvbnMsIG92ZXJyaWRlIGFuZCBtZXJnZSB3aXRoIGRlZmF1bHQgb25lc1xuICAgICAgICAuLi4ob3B0aW9ucy5tb2RpZmllcnMgPyBvcHRpb25zLm1vZGlmaWVyc1tuYW1lXSA6IHt9KSxcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICAvLyBSZWZhY3RvcmluZyBtb2RpZmllcnMnIGxpc3QgKE9iamVjdCA9PiBBcnJheSlcbiAgICB0aGlzLm1vZGlmaWVycyA9IE9iamVjdC5rZXlzKHRoaXMub3B0aW9ucy5tb2RpZmllcnMpXG4gICAgICAubWFwKG5hbWUgPT4gKHtcbiAgICAgICAgbmFtZSxcbiAgICAgICAgLi4udGhpcy5vcHRpb25zLm1vZGlmaWVyc1tuYW1lXSxcbiAgICAgIH0pKVxuICAgICAgLy8gc29ydCB0aGUgbW9kaWZpZXJzIGJ5IG9yZGVyXG4gICAgICAuc29ydCgoYSwgYikgPT4gYS5vcmRlciAtIGIub3JkZXIpO1xuXG4gICAgLy8gbW9kaWZpZXJzIGhhdmUgdGhlIGFiaWxpdHkgdG8gZXhlY3V0ZSBhcmJpdHJhcnkgY29kZSB3aGVuIFBvcHBlci5qcyBnZXQgaW5pdGVkXG4gICAgLy8gc3VjaCBjb2RlIGlzIGV4ZWN1dGVkIGluIHRoZSBzYW1lIG9yZGVyIG9mIGl0cyBtb2RpZmllclxuICAgIC8vIHRoZXkgY291bGQgYWRkIG5ldyBwcm9wZXJ0aWVzIHRvIHRoZWlyIG9wdGlvbnMgY29uZmlndXJhdGlvblxuICAgIC8vIEJFIEFXQVJFOiBkb24ndCBhZGQgb3B0aW9ucyB0byBgb3B0aW9ucy5tb2RpZmllcnMubmFtZWAgYnV0IHRvIGBtb2RpZmllck9wdGlvbnNgIVxuICAgIHRoaXMubW9kaWZpZXJzLmZvckVhY2gobW9kaWZpZXJPcHRpb25zID0+IHtcbiAgICAgIGlmIChtb2RpZmllck9wdGlvbnMuZW5hYmxlZCAmJiBpc0Z1bmN0aW9uKG1vZGlmaWVyT3B0aW9ucy5vbkxvYWQpKSB7XG4gICAgICAgIG1vZGlmaWVyT3B0aW9ucy5vbkxvYWQoXG4gICAgICAgICAgdGhpcy5yZWZlcmVuY2UsXG4gICAgICAgICAgdGhpcy5wb3BwZXIsXG4gICAgICAgICAgdGhpcy5vcHRpb25zLFxuICAgICAgICAgIG1vZGlmaWVyT3B0aW9ucyxcbiAgICAgICAgICB0aGlzLnN0YXRlXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBmaXJlIHRoZSBmaXJzdCB1cGRhdGUgdG8gcG9zaXRpb24gdGhlIHBvcHBlciBpbiB0aGUgcmlnaHQgcGxhY2VcbiAgICB0aGlzLnVwZGF0ZSgpO1xuXG4gICAgY29uc3QgZXZlbnRzRW5hYmxlZCA9IHRoaXMub3B0aW9ucy5ldmVudHNFbmFibGVkO1xuICAgIGlmIChldmVudHNFbmFibGVkKSB7XG4gICAgICAvLyBzZXR1cCBldmVudCBsaXN0ZW5lcnMsIHRoZXkgd2lsbCB0YWtlIGNhcmUgb2YgdXBkYXRlIHRoZSBwb3NpdGlvbiBpbiBzcGVjaWZpYyBzaXR1YXRpb25zXG4gICAgICB0aGlzLmVuYWJsZUV2ZW50TGlzdGVuZXJzKCk7XG4gICAgfVxuXG4gICAgdGhpcy5zdGF0ZS5ldmVudHNFbmFibGVkID0gZXZlbnRzRW5hYmxlZDtcbiAgfVxuXG4gIC8vIFdlIGNhbid0IHVzZSBjbGFzcyBwcm9wZXJ0aWVzIGJlY2F1c2UgdGhleSBkb24ndCBnZXQgbGlzdGVkIGluIHRoZVxuICAvLyBjbGFzcyBwcm90b3R5cGUgYW5kIGJyZWFrIHN0dWZmIGxpa2UgU2lub24gc3R1YnNcbiAgdXBkYXRlKCkge1xuICAgIHJldHVybiB1cGRhdGUuY2FsbCh0aGlzKTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHJldHVybiBkZXN0cm95LmNhbGwodGhpcyk7XG4gIH1cbiAgZW5hYmxlRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgcmV0dXJuIGVuYWJsZUV2ZW50TGlzdGVuZXJzLmNhbGwodGhpcyk7XG4gIH1cbiAgZGlzYWJsZUV2ZW50TGlzdGVuZXJzKCkge1xuICAgIHJldHVybiBkaXNhYmxlRXZlbnRMaXN0ZW5lcnMuY2FsbCh0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTY2hlZHVsZXMgYW4gdXBkYXRlLiBJdCB3aWxsIHJ1biBvbiB0aGUgbmV4dCBVSSB1cGRhdGUgYXZhaWxhYmxlLlxuICAgKiBAbWV0aG9kIHNjaGVkdWxlVXBkYXRlXG4gICAqIEBtZW1iZXJvZiBQb3BwZXJcbiAgICovXG4gIHNjaGVkdWxlVXBkYXRlID0gKCkgPT4gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMudXBkYXRlKTtcblxuICAvKipcbiAgICogQ29sbGVjdGlvbiBvZiB1dGlsaXRpZXMgdXNlZnVsIHdoZW4gd3JpdGluZyBjdXN0b20gbW9kaWZpZXJzLlxuICAgKiBTdGFydGluZyBmcm9tIHZlcnNpb24gMS43LCB0aGlzIG1ldGhvZCBpcyBhdmFpbGFibGUgb25seSBpZiB5b3VcbiAgICogaW5jbHVkZSBgcG9wcGVyLXV0aWxzLmpzYCBiZWZvcmUgYHBvcHBlci5qc2AuXG4gICAqXG4gICAqICoqREVQUkVDQVRJT04qKjogVGhpcyB3YXkgdG8gYWNjZXNzIFBvcHBlclV0aWxzIGlzIGRlcHJlY2F0ZWRcbiAgICogYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiB2MiEgVXNlIHRoZSBQb3BwZXJVdGlscyBtb2R1bGUgZGlyZWN0bHkgaW5zdGVhZC5cbiAgICogRHVlIHRvIHRoZSBoaWdoIGluc3RhYmlsaXR5IG9mIHRoZSBtZXRob2RzIGNvbnRhaW5lZCBpbiBVdGlscywgd2UgY2FuJ3RcbiAgICogZ3VhcmFudGVlIHRoZW0gdG8gZm9sbG93IHNlbXZlci4gVXNlIHRoZW0gYXQgeW91ciBvd24gcmlzayFcbiAgICogQHN0YXRpY1xuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDEuOFxuICAgKiBAbWVtYmVyIFV0aWxzXG4gICAqIEBtZW1iZXJvZiBQb3BwZXJcbiAgICovXG4gIHN0YXRpYyBVdGlscyA9ICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IGdsb2JhbCkuUG9wcGVyVXRpbHM7XG5cbiAgc3RhdGljIHBsYWNlbWVudHMgPSBwbGFjZW1lbnRzO1xuXG4gIHN0YXRpYyBEZWZhdWx0cyA9IERlZmF1bHRzO1xufVxuXG4vKipcbiAqIFRoZSBgcmVmZXJlbmNlT2JqZWN0YCBpcyBhbiBvYmplY3QgdGhhdCBwcm92aWRlcyBhbiBpbnRlcmZhY2UgY29tcGF0aWJsZSB3aXRoIFBvcHBlci5qc1xuICogYW5kIGxldHMgeW91IHVzZSBpdCBhcyByZXBsYWNlbWVudCBvZiBhIHJlYWwgRE9NIG5vZGUuPGJyIC8+XG4gKiBZb3UgY2FuIHVzZSB0aGlzIG1ldGhvZCB0byBwb3NpdGlvbiBhIHBvcHBlciByZWxhdGl2ZWx5IHRvIGEgc2V0IG9mIGNvb3JkaW5hdGVzXG4gKiBpbiBjYXNlIHlvdSBkb24ndCBoYXZlIGEgRE9NIG5vZGUgdG8gdXNlIGFzIHJlZmVyZW5jZS5cbiAqXG4gKiBgYGBcbiAqIG5ldyBQb3BwZXIocmVmZXJlbmNlT2JqZWN0LCBwb3BwZXJOb2RlKTtcbiAqIGBgYFxuICpcbiAqIE5COiBUaGlzIGZlYXR1cmUgaXNuJ3Qgc3VwcG9ydGVkIGluIEludGVybmV0IEV4cGxvcmVyIDEwLlxuICogQG5hbWUgcmVmZXJlbmNlT2JqZWN0XG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBkYXRhLmdldEJvdW5kaW5nQ2xpZW50UmVjdFxuICogQSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBzZXQgb2YgY29vcmRpbmF0ZXMgY29tcGF0aWJsZSB3aXRoIHRoZSBuYXRpdmUgYGdldEJvdW5kaW5nQ2xpZW50UmVjdGAgbWV0aG9kLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IGRhdGEuY2xpZW50V2lkdGhcbiAqIEFuIEVTNiBnZXR0ZXIgdGhhdCB3aWxsIHJldHVybiB0aGUgd2lkdGggb2YgdGhlIHZpcnR1YWwgcmVmZXJlbmNlIGVsZW1lbnQuXG4gKiBAcHJvcGVydHkge251bWJlcn0gZGF0YS5jbGllbnRIZWlnaHRcbiAqIEFuIEVTNiBnZXR0ZXIgdGhhdCB3aWxsIHJldHVybiB0aGUgaGVpZ2h0IG9mIHRoZSB2aXJ0dWFsIHJlZmVyZW5jZSBlbGVtZW50LlxuICovXG4iLCJpbXBvcnQgJy4vc2Nzcy9zaGlwdGltaXplLWFkbWluLnNjc3MnO1xuaW1wb3J0IFBvcHBlciBmcm9tICdwb3BwZXIuanMnOyAgXG5cbmNsYXNzIFNoaXB0aW1pemUge1xuXG4gIGNvbnN0cnVjdG9yKCl7XG4gICAgY29uc29sZS5sb2coXCJJJ20gYWxpdmUhXCIpOyBcbiAgICB0aGlzLmJvb3N0cmFwKCk7IFxuICB9XG5cbiAgLyoqIFxuICAgKiAgXG4gICAqLyBcbiAgYm9vc3RyYXAoKSB7XG4gICAgaWYgKGpRdWVyeShcIi5zaGlwdGltaXplLXRvb2x0aXAtbWVzc2FnZVwiKS5zaXplKCkgID09IDAgKSB7XG4gICAgICAgIHNldFRpbWVvdXQoKCk9PnsgdGhpcy5ib29zdHJhcCgpOyB9LCA1MDApOyAgXG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zb2xlLmxvZyhqUXVlcnkoXCIuc2hpcHRpbWl6ZS10b29sdGlwLW1lc3NhZ2VcIikuc2l6ZSgpKTtcblxuICAgIHRoaXMudG9vbHRpcHMoKTsgICBcbiAgICB0aGlzLmxvYWRBbmFseXRpY3MoKTsgICBcbiAgfVxuXG4gIHRvb2x0aXBzKCApe1xuICAgIGxldCB0b2x0aXAgPSBqUXVlcnkoXCIuc2hpcHRpbWl6ZS10b29sdGlwLW1lc3NhZ2VcIik7IFxuXG4gICAgaWYoIHRvbHRpcC5zaXplKCkgPT0gMCApe1xuICAgICAgcmV0dXJuOyBcbiAgICB9XG5cbiAgICBsZXQgbWUgPSB0aGlzOyBcbiAgICB0b2x0aXAuZWFjaCggZnVuY3Rpb24gKCBpZHgsIGVsZW0gKSB7XG4gICAgICBtZS5hdHRhY2hQb3BwZXIoZWxlbSxjb250YWluZXIpOyAgXG4gICAgfSk7ICAgICAgXG4gIH1cblxuICBhdHRhY2hQb3BwZXIodG9sdGlwLCBjb250YWluZXIpeyAgXG4gICAgbGV0IGVUb2x0aXAgPSBqUXVlcnkodG9sdGlwKTsgXG4gICAgbGV0IHRvbHRpcFJlZmVyZW5jZSA9IGVUb2x0aXAuc2libGluZ3MoXCIuc2hpcHRpbWl6ZS10b29sdGlwLXJlZmVyZW5jZVwiKTtcbiAgICBsZXQgYXJyb3cgPSBlVG9sdGlwLmNoaWxkcmVuKCcuc2hpcHRpbWl6ZS10b29sdGlwLW1lc3NhZ2VfX2Fycm93JykuZ2V0KDApOyBcblxuICAgIHZhciBwb3BwZXIgPSBuZXcgUG9wcGVyKHRvbHRpcFJlZmVyZW5jZS5nZXQoMCksIHRvbHRpcCwge1xuICAgICAgcGxhY2VtZW50OiAnbGVmdCcsXG4gICAgICBtb2RpZmllcnM6IHtcbiAgICAgICAgICBmbGlwOiB7XG4gICAgICAgICAgICAgIGJlaGF2aW9yOiBbJ3RvcCcsJ2xlZnQnLCAnYm90dG9tJ11cbiAgICAgICAgICB9LFxuICAgICAgICAgIHByZXZlbnRPdmVyZmxvdzoge1xuICAgICAgICAgICAgICBib3VuZGFyaWVzRWxlbWVudDogY29udGFpbmVyLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgb2Zmc2V0OiB7IFxuICAgICAgICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICAgICAgICBvZmZzZXQ6ICcxMCwxMCdcbiAgICAgICAgICB9LFxuICAgICAgICAgIGFycm93OiB7XG4gICAgICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICAgICAgZWxlbWVudDogYXJyb3dcbiAgICAgICAgICB9XG4gICAgICB9LCBcbiAgICB9KTsgIFxuICAgIHNldFRpbWVvdXQgKCAoKSA9PiB7IHBvcHBlci51cGRhdGUoKTsgfSAsIDIwMCk7ICAgICBcbiAgfVxuXG4gIGV4cG9ydFN1Y2Nlc3MoYXBwTGluayl7XG4gICAgdGhpcy5wbGF0Zm9ybS5leHBvcnRTdWNjZXNzKGFwcExpbmspO1xuICB9XG5cbiAgLyoqIFxuICAgKiBAcGFyYW0gc3RyaW5nIGNhdGVnb3J5IFxuICAgKiBAcGFyYW0gc3RyaW5nIGFjdGlvbiBcbiAgICogQHBhcmFtIHN0cmluZyBsYWJlbCBcbiAgICovXG4gIHNlbmRBbmFseXRpY3NFdmVudChjYXRlZ29yeSwgYWN0aW9uLCBsYWJlbCkge1xuICAgICAgZ2EoJ3NoaXB0aW1pemUuc2VuZCcsICdldmVudCcsIGNhdGVnb3J5LCBhY3Rpb24sIGxhYmVsLCB7IHRyYW5zcG9ydDogJ2JlYWNvbicgfSk7XG4gIH1cblxuICBsb2FkQW5hbHl0aWNzKCkge1xuICAgICAgaWYgKHR5cGVvZihnYSkgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAoZnVuY3Rpb24oaSwgcywgbywgZywgciwgYSwgbSkge1xuICAgICAgICAgICAgICBpWydHb29nbGVBbmFseXRpY3NPYmplY3QnXSA9IHI7XG4gICAgICAgICAgICAgIGlbcl0gPSBpW3JdIHx8IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgKGlbcl0ucSA9IGlbcl0ucSB8fCBbXSkucHVzaChhcmd1bWVudHMpXG4gICAgICAgICAgICAgIH0sIGlbcl0ubCA9IDEgKiBuZXcgRGF0ZSgpO1xuICAgICAgICAgICAgICBhID0gcy5jcmVhdGVFbGVtZW50KG8pLFxuICAgICAgICAgICAgICAgICAgbSA9IHMuZ2V0RWxlbWVudHNCeVRhZ05hbWUobylbMF07XG4gICAgICAgICAgICAgIGEuYXN5bmMgPSAxO1xuICAgICAgICAgICAgICBhLnNyYyA9IGc7XG4gICAgICAgICAgICAgIG0ucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoYSwgbSlcbiAgICAgICAgICB9KSh3aW5kb3csIGRvY3VtZW50LCAnc2NyaXB0JywgJ2h0dHBzOi8vd3d3Lmdvb2dsZS1hbmFseXRpY3MuY29tL2FuYWx5dGljcy5qcycsICdnYScpO1xuICAgICAgICAgIGNvbnNvbGUubG9nKFwiaW5zZXJ0aW5nIGFuYWx5dGljcyBcIik7XG4gICAgICB9IFxuICAgICAgZ2EoJ2NyZWF0ZScsICdVQS0xMDE0ODU2NDMtMScsICdhdXRvJywgJ3NoaXB0aW1pemUnKTtcbiAgICAgIGdhKCdzaGlwdGltaXplLnNldCcsICdhbm9ueW1pemVJcCcsIHRydWUpO1xuICAgICAgY29uc29sZS5sb2coXCJjcmVhdGluZyB0cmFja2VyXCIpO1xuICB9XG5cblxuICAvKipcbiAgICogUmVxdWVzdCB0aGUgbGFiZWwgc3RhdHVzIGV2ZXJ5IDFzIFxuICAgKi9cbiAgbW9uaXRvckxhYmVsU3RhdHVzKGNhbGxiYWNrVXJsKSB7XG4gICAgdmFyIGRhdGEgPSB7XG4gICAgICAnYWN0aW9uJzogJ3NoaXB0aW1pemVfbGFiZWxfc3RhdHVzJyxcbiAgICAgICdjYWxsYmFja1VybCc6IGNhbGxiYWNrVXJsXG4gICAgfTsgXG4gICAgXG4gICAgY29uc29sZS5sb2coXCJNb25pdG9yIGxhYmVsIHN0YXR1cyB3aXRoIGRhdGEgXCIgLCBkYXRhICk7IFxuXG4gICAgalF1ZXJ5LnBvc3QobGFiZWxtb25pdG9ydXJsLCBkYXRhLCAoZGF0YSkgPT4ge1xuICAgICAgY29uc29sZS5sb2coZGF0YSk7IFxuXG4gICAgICBpZih0eXBlb2YoZGF0YS5yZXNwb25zZSkhPSAndW5kZWZpbmVkJykge1xuXG4gICAgICAgIC8vIENoZWNrIGZvciBmYWx0YSBlcnJvcnMgXG4gICAgICAgIGlmKGRhdGEuaHR0cENvZGUgPT0gJzIwMCcpIHtcbiAgICAgICAgICB0aGlzLmxvYWRlck1zZyhzaGlwdGltaXplX2xhYmVsX3JlcXVlc3QgKyAnICcgKyBkYXRhLnJlc3BvbnNlLkZpbmlzaGVkICsgJyUnKTsgICAgICAgICBcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB0aGlzLmxvYWRlck1zZyhcIkZhdGFsIEFQSSBlcnJvciBcIiArIGRhdGEuaHR0cENvZGUpO1xuICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4geyB0aGlzLmNsb3NlTG9hZGVyKCk7IH0sIDUwMDApO1xuICAgICAgICAgIHJldHVybjsgXG4gICAgICAgIH1cblxuICAgICAgICAvLyBQcmludCBBUEkgZXJyb3JzXG4gICAgICAgIGlmIChkYXRhLnJlc3BvbnNlLkVycm9yLklkID4gMCkge1xuICAgICAgICAgIHRoaXMubG9hZGVyTXNnKGRhdGEucmVzcG9uc2UuRXJyb3IuSW5mbyk7IFxuICAgICAgICB9XG5cbiAgICAgICAgaWYoZGF0YS5yZXNwb25zZS5FcnJvci5JZCA9PSA5MDIpIHsgLy9ObyBwcm9jZXNzIHJ1bm5pbmcgXG4gICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgIHRoaXMuY2xvc2VMb2FkZXIoKVxuICAgICAgICAgIH0sIDIwMDApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoZGF0YS5yZXNwb25zZS5GaW5pc2hlZCA9PSAxMDAgKSB7XG4gICAgICAgICAgaWYgKCBkYXRhLnJlc3BvbnNlLkxhYmVsRmlsZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBsZXQgbGFiZWxpbmZvID0gc2hpcHRpbWl6ZV9sYWJlbF9jbGljay5yZXBsYWNlKCclJyxgPGEgaHJlZj1cIiR7ZGF0YS5yZXNwb25zZS5MYWJlbEZpbGV9XCIgdGFyZ2V0PSdfYmxhbmsnPiR7c2hpcHRpbWl6ZV9sYWJlbF9sYWJlbH08L2E+YCk7XG4gICAgICAgICAgICBqUXVlcnkoXCIjc2hpcHRpbWl6ZV9sYWJlbF9zdGF0dXNcIikuaHRtbChgPGRpdiBjbGFzcz1cIm5vdGljZSBub3RpY2UtaW5mbyBpcy1kaXNtaXNzaWJsZSB1cGRhdGVkXCI+JHtsYWJlbGluZm99PC9kaXY+YCk7XG4gICAgICAgICAgICB3aW5kb3cub3BlbihkYXRhLnJlc3BvbnNlLkxhYmVsRmlsZSwnX2JsYW5rJyk7IFxuICAgICAgICAgICAgdGhpcy5jbG9zZUxvYWRlcigpO1xuXG4gICAgICAgICAgICAvKiogXG4gICAgICAgICAgICAgKiBNYWtlIHN1cmUgdGhlIGluZm8gaXMgdXBkYXRlZCB3aXRob3V0IHRoZSBuZWVkIHRvIHJlbG9hZCB0aGUgcGFnZSBcbiAgICAgICAgICAgICAqLyBcbiAgICAgICAgICAgIGZvcih2YXIgeCA9MDsgeCA8IGRhdGEucmVzcG9uc2UuQ2xpZW50UmVmZXJlbmNlQ29kZUxpc3QubGVuZ3RoOyArK3gpIHtcbiAgICAgICAgICAgICAgdmFyIGxhYmVscmVzdWx0ID0gZGF0YS5yZXNwb25zZS5DbGllbnRSZWZlcmVuY2VDb2RlTGlzdFt4XTsgXG4gICAgICAgICAgICAgIGlmKGxhYmVscmVzdWx0LkVycm9yLklkID09IDApIHsgXG4gICAgICAgICAgICAgICAgalF1ZXJ5KFwiI3NoaXB0aW1pemUtbGFiZWxcIiArIGxhYmVscmVzdWx0LlJlZmVyZW5jZUNvZGUpLmFkZENsYXNzKCdzaGlwdGltaXplLWljb24tcHJpbnQtcHJpbnRlZCcpOyAgIFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGpRdWVyeShcIiNzaGlwdGltaXplLWxhYmVsXCIgKyBsYWJlbHJlc3VsdC5SZWZlcmVuY2VDb2RlKS5hZGRDbGFzcyhcInNoaXB0aW1pemUtaWNvbi1wcmludC1lcnJvclwiKTsgIFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICBqUXVlcnkoXCIjc2hpcHRpbWl6ZS10b29sdGlwXCIgKyBsYWJlbHJlc3VsdC5SZWZlcmVuY2VDb2RlKS5odG1sKGxhYmVscmVzdWx0Lm1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBtc2cgPSAnJzsgXG4gICAgICAgICAgICBmb3IgKCB2YXIgeD0wOyB4IDwgZGF0YS5yZXNwb25zZS5DbGllbnRSZWZlcmVuY2VDb2RlTGlzdC5sZW5ndGg7ICsreCApIHtcbiAgICAgICAgICAgICAgbGV0IGxhYmVscmVzdWx0ID0gZGF0YS5yZXNwb25zZS5DbGllbnRSZWZlcmVuY2VDb2RlTGlzdFswXTsgXG4gICAgICAgICAgICAgIGlmKGxhYmVscmVzdWx0LkVycm9yLklkID4gMCkge1xuICAgICAgICAgICAgICAgIG1zZyArPSBcIjxkaXYgY2xhc3M9J3NoaXB0aW1pemUtbGFiZWwtZXJyb3IgZXJyb3InPlwiICsgbGFiZWxyZXN1bHQuRXJyb3IuSW5mbyArIFwiPC9kaXY+XCI7IFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGpRdWVyeShcIiNzaGlwdGltaXplLWxhYmVsXCIgKyBsYWJlbHJlc3VsdC5SZWZlcmVuY2VDb2RlKS5hZGRDbGFzcyhcInNoaXB0aW1pemUtaWNvbi1wcmludC1lcnJvclwiKTsgIFxuICAgICAgICAgICAgICBqUXVlcnkoXCIjc2hpcHRpbWl6ZS10b29sdGlwXCIgKyBsYWJlbHJlc3VsdC5SZWZlcmVuY2VDb2RlKS5odG1sKGxhYmVscmVzdWx0Lm1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmxvYWRlck1zZyhtc2cpOyBcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4geyB0aGlzLmNsb3NlTG9hZGVyKCk7IH0sIDEwMDAwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZihkYXRhLnJlc3BvbnNlLkZpbmlzaGVkIDwgMTAwKSB7XG4gICAgICAgICAgc2V0VGltZW91dCggKCkgPT4geyB0aGlzLm1vbml0b3JMYWJlbFN0YXR1cyhjYWxsYmFja1VybCk7IH0sIDIwMDApOyBcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgfSwgXCJqc29uXCIpO1xuICB9XG5cbiAgbG9hZGVyTXNnKG1lc3NhZ2UpIHtcbiAgICBqUXVlcnkoXCIuc2hpcHRpbWl6ZS1sb2FkZXItbWVzc2FnZVwiKS5odG1sKG1lc3NhZ2UpOyBcbiAgfVxuXG4gIG9wZW5Mb2FkZXIobWVzc2FnZSkge1xuICAgIGpRdWVyeSgnYm9keScpLmFwcGVuZCgnPGRpdiBjbGFzcz1cInNoaXB0aW1pemUtbG9hZGVyLXdyYXBwZXJcIj48ZGl2IGNsYXNzPVwic2hpcHRpbWl6ZS1sb2FkZXJcIj48ZGl2PjwvZGl2PjxkaXY+PC9kaXY+PGRpdj48L2Rpdj48L2Rpdj48ZGl2IGNsYXNzPVwic2hpcHRpbWl6ZS1sb2FkZXItbWVzc2FnZVwiPicgKyBtZXNzYWdlICArICc8L2Rpdj48L2Rpdj4nKTsgXG4gIH1cblxuICBjbG9zZUxvYWRlcigpe1xuICAgIGpRdWVyeShcIi5zaGlwdGltaXplLWxvYWRlci13cmFwcGVyXCIpLnJlbW92ZSgpOyBcbiAgfVxufVxuXG5qUXVlcnkoZnVuY3Rpb24gKCkge1xuICB3aW5kb3cuc2hpcHRpbWl6ZSA9IG5ldyBTaGlwdGltaXplKCk7XG4gIHdpbmRvdy5Qb3BwZXIgPSBQb3BwZXI7XG59KTtcblxuIl0sIm5hbWVzIjpbImlzQnJvd3NlciIsIndpbmRvdyIsImRvY3VtZW50IiwibmF2aWdhdG9yIiwidGltZW91dER1cmF0aW9uIiwibG9uZ2VyVGltZW91dEJyb3dzZXJzIiwiaSIsImxlbmd0aCIsInVzZXJBZ2VudCIsImluZGV4T2YiLCJtaWNyb3Rhc2tEZWJvdW5jZSIsImZuIiwiY2FsbGVkIiwiUHJvbWlzZSIsInJlc29sdmUiLCJ0aGVuIiwidGFza0RlYm91bmNlIiwic2NoZWR1bGVkIiwic3VwcG9ydHNNaWNyb1Rhc2tzIiwiZGVib3VuY2UiLCJpc0Z1bmN0aW9uIiwiZnVuY3Rpb25Ub0NoZWNrIiwiZ2V0VHlwZSIsInRvU3RyaW5nIiwiY2FsbCIsImdldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eSIsImVsZW1lbnQiLCJwcm9wZXJ0eSIsIm5vZGVUeXBlIiwib3duZXJEb2N1bWVudCIsImRlZmF1bHRWaWV3IiwiY3NzIiwiZ2V0Q29tcHV0ZWRTdHlsZSIsImdldFBhcmVudE5vZGUiLCJub2RlTmFtZSIsInBhcmVudE5vZGUiLCJob3N0IiwiZ2V0U2Nyb2xsUGFyZW50IiwiYm9keSIsIm92ZXJmbG93IiwiX2dldFN0eWxlQ29tcHV0ZWRQcm9wIiwib3ZlcmZsb3dYIiwib3ZlcmZsb3dZIiwidGVzdCIsImdldFJlZmVyZW5jZU5vZGUiLCJyZWZlcmVuY2UiLCJyZWZlcmVuY2VOb2RlIiwiaXNJRTExIiwiTVNJbnB1dE1ldGhvZENvbnRleHQiLCJkb2N1bWVudE1vZGUiLCJpc0lFMTAiLCJpc0lFIiwidmVyc2lvbiIsImdldE9mZnNldFBhcmVudCIsImRvY3VtZW50RWxlbWVudCIsIm5vT2Zmc2V0UGFyZW50Iiwib2Zmc2V0UGFyZW50IiwibmV4dEVsZW1lbnRTaWJsaW5nIiwiaXNPZmZzZXRDb250YWluZXIiLCJmaXJzdEVsZW1lbnRDaGlsZCIsImdldFJvb3QiLCJub2RlIiwiZmluZENvbW1vbk9mZnNldFBhcmVudCIsImVsZW1lbnQxIiwiZWxlbWVudDIiLCJvcmRlciIsImNvbXBhcmVEb2N1bWVudFBvc2l0aW9uIiwiTm9kZSIsIkRPQ1VNRU5UX1BPU0lUSU9OX0ZPTExPV0lORyIsInN0YXJ0IiwiZW5kIiwicmFuZ2UiLCJjcmVhdGVSYW5nZSIsInNldFN0YXJ0Iiwic2V0RW5kIiwiY29tbW9uQW5jZXN0b3JDb250YWluZXIiLCJjb250YWlucyIsImVsZW1lbnQxcm9vdCIsImdldFNjcm9sbCIsInNpZGUiLCJhcmd1bWVudHMiLCJ1bmRlZmluZWQiLCJ1cHBlclNpZGUiLCJodG1sIiwic2Nyb2xsaW5nRWxlbWVudCIsImluY2x1ZGVTY3JvbGwiLCJyZWN0Iiwic3VidHJhY3QiLCJzY3JvbGxUb3AiLCJzY3JvbGxMZWZ0IiwibW9kaWZpZXIiLCJ0b3AiLCJib3R0b20iLCJsZWZ0IiwicmlnaHQiLCJnZXRCb3JkZXJzU2l6ZSIsInN0eWxlcyIsImF4aXMiLCJzaWRlQSIsInNpZGVCIiwicGFyc2VGbG9hdCIsImdldFNpemUiLCJjb21wdXRlZFN0eWxlIiwiTWF0aCIsIm1heCIsInBhcnNlSW50IiwiZ2V0V2luZG93U2l6ZXMiLCJnZXRDbGllbnRSZWN0Iiwib2Zmc2V0cyIsIndpZHRoIiwiaGVpZ2h0IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwiZSIsInJlc3VsdCIsInNpemVzIiwiY2xpZW50V2lkdGgiLCJjbGllbnRIZWlnaHQiLCJob3JpelNjcm9sbGJhciIsIm9mZnNldFdpZHRoIiwidmVydFNjcm9sbGJhciIsIm9mZnNldEhlaWdodCIsImdldE9mZnNldFJlY3RSZWxhdGl2ZVRvQXJiaXRyYXJ5Tm9kZSIsImNoaWxkcmVuIiwicGFyZW50IiwiZml4ZWRQb3NpdGlvbiIsImlzSFRNTCIsImNoaWxkcmVuUmVjdCIsInBhcmVudFJlY3QiLCJzY3JvbGxQYXJlbnQiLCJib3JkZXJUb3BXaWR0aCIsImJvcmRlckxlZnRXaWR0aCIsIm1hcmdpblRvcCIsIm1hcmdpbkxlZnQiLCJnZXRWaWV3cG9ydE9mZnNldFJlY3RSZWxhdGl2ZVRvQXJ0Yml0cmFyeU5vZGUiLCJleGNsdWRlU2Nyb2xsIiwicmVsYXRpdmVPZmZzZXQiLCJpbm5lcldpZHRoIiwiaW5uZXJIZWlnaHQiLCJvZmZzZXQiLCJpc0ZpeGVkIiwiZ2V0Rml4ZWRQb3NpdGlvbk9mZnNldFBhcmVudCIsInBhcmVudEVsZW1lbnQiLCJlbCIsImdldEJvdW5kYXJpZXMiLCJwb3BwZXIiLCJwYWRkaW5nIiwiYm91bmRhcmllc0VsZW1lbnQiLCJib3VuZGFyaWVzIiwiYm91bmRhcmllc05vZGUiLCJfZ2V0V2luZG93U2l6ZXMiLCJpc1BhZGRpbmdOdW1iZXIiLCJnZXRBcmVhIiwiX3JlZiIsImNvbXB1dGVBdXRvUGxhY2VtZW50IiwicGxhY2VtZW50IiwicmVmUmVjdCIsInJlY3RzIiwic29ydGVkQXJlYXMiLCJPYmplY3QiLCJrZXlzIiwibWFwIiwia2V5Iiwic29ydCIsImEiLCJiIiwiYXJlYSIsImZpbHRlcmVkQXJlYXMiLCJmaWx0ZXIiLCJfcmVmMiIsImNvbXB1dGVkUGxhY2VtZW50IiwidmFyaWF0aW9uIiwic3BsaXQiLCJnZXRSZWZlcmVuY2VPZmZzZXRzIiwic3RhdGUiLCJjb21tb25PZmZzZXRQYXJlbnQiLCJnZXRPdXRlclNpemVzIiwieCIsIm1hcmdpbkJvdHRvbSIsInkiLCJtYXJnaW5SaWdodCIsImdldE9wcG9zaXRlUGxhY2VtZW50IiwiaGFzaCIsInJlcGxhY2UiLCJtYXRjaGVkIiwiZ2V0UG9wcGVyT2Zmc2V0cyIsInJlZmVyZW5jZU9mZnNldHMiLCJwb3BwZXJSZWN0IiwicG9wcGVyT2Zmc2V0cyIsImlzSG9yaXoiLCJtYWluU2lkZSIsInNlY29uZGFyeVNpZGUiLCJtZWFzdXJlbWVudCIsInNlY29uZGFyeU1lYXN1cmVtZW50IiwiZmluZCIsImFyciIsImNoZWNrIiwiQXJyYXkiLCJwcm90b3R5cGUiLCJmaW5kSW5kZXgiLCJwcm9wIiwidmFsdWUiLCJjdXIiLCJtYXRjaCIsIm9iaiIsInJ1bk1vZGlmaWVycyIsIm1vZGlmaWVycyIsImRhdGEiLCJlbmRzIiwibW9kaWZpZXJzVG9SdW4iLCJzbGljZSIsImZvckVhY2giLCJ3YXJuIiwiZW5hYmxlZCIsInVwZGF0ZSIsImlzRGVzdHJveWVkIiwib3B0aW9ucyIsInBvc2l0aW9uRml4ZWQiLCJmbGlwIiwib3JpZ2luYWxQbGFjZW1lbnQiLCJwb3NpdGlvbiIsImlzQ3JlYXRlZCIsIm9uQ3JlYXRlIiwib25VcGRhdGUiLCJpc01vZGlmaWVyRW5hYmxlZCIsIm1vZGlmaWVyTmFtZSIsInNvbWUiLCJuYW1lIiwiZ2V0U3VwcG9ydGVkUHJvcGVydHlOYW1lIiwicHJlZml4ZXMiLCJ1cHBlclByb3AiLCJjaGFyQXQiLCJ0b1VwcGVyQ2FzZSIsInByZWZpeCIsInRvQ2hlY2siLCJzdHlsZSIsImRlc3Ryb3kiLCJyZW1vdmVBdHRyaWJ1dGUiLCJ3aWxsQ2hhbmdlIiwiZGlzYWJsZUV2ZW50TGlzdGVuZXJzIiwicmVtb3ZlT25EZXN0cm95IiwicmVtb3ZlQ2hpbGQiLCJnZXRXaW5kb3ciLCJhdHRhY2hUb1Njcm9sbFBhcmVudHMiLCJldmVudCIsImNhbGxiYWNrIiwic2Nyb2xsUGFyZW50cyIsImlzQm9keSIsInRhcmdldCIsImFkZEV2ZW50TGlzdGVuZXIiLCJwYXNzaXZlIiwicHVzaCIsInNldHVwRXZlbnRMaXN0ZW5lcnMiLCJ1cGRhdGVCb3VuZCIsInNjcm9sbEVsZW1lbnQiLCJldmVudHNFbmFibGVkIiwiZW5hYmxlRXZlbnRMaXN0ZW5lcnMiLCJzY2hlZHVsZVVwZGF0ZSIsInJlbW92ZUV2ZW50TGlzdGVuZXJzIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImlzTnVtZXJpYyIsIm4iLCJpc05hTiIsImlzRmluaXRlIiwic2V0U3R5bGVzIiwidW5pdCIsInNldEF0dHJpYnV0ZXMiLCJhdHRyaWJ1dGVzIiwic2V0QXR0cmlidXRlIiwiYXBwbHlTdHlsZSIsImluc3RhbmNlIiwiYXJyb3dFbGVtZW50IiwiYXJyb3dTdHlsZXMiLCJhcHBseVN0eWxlT25Mb2FkIiwibW9kaWZpZXJPcHRpb25zIiwiZ2V0Um91bmRlZE9mZnNldHMiLCJzaG91bGRSb3VuZCIsIl9kYXRhJG9mZnNldHMiLCJyb3VuZCIsImZsb29yIiwibm9Sb3VuZCIsInYiLCJyZWZlcmVuY2VXaWR0aCIsInBvcHBlcldpZHRoIiwiaXNWZXJ0aWNhbCIsImlzVmFyaWF0aW9uIiwic2FtZVdpZHRoUGFyaXR5IiwiYm90aE9kZFdpZHRoIiwiaG9yaXpvbnRhbFRvSW50ZWdlciIsInZlcnRpY2FsVG9JbnRlZ2VyIiwiaXNGaXJlZm94IiwiY29tcHV0ZVN0eWxlIiwibGVnYWN5R3B1QWNjZWxlcmF0aW9uT3B0aW9uIiwiZ3B1QWNjZWxlcmF0aW9uIiwib2Zmc2V0UGFyZW50UmVjdCIsImRldmljZVBpeGVsUmF0aW8iLCJwcmVmaXhlZFByb3BlcnR5IiwiaW52ZXJ0VG9wIiwiaW52ZXJ0TGVmdCIsIl9leHRlbmRzIiwiYXJyb3ciLCJpc01vZGlmaWVyUmVxdWlyZWQiLCJyZXF1ZXN0aW5nTmFtZSIsInJlcXVlc3RlZE5hbWUiLCJyZXF1ZXN0aW5nIiwiaXNSZXF1aXJlZCIsIl9yZXF1ZXN0aW5nIiwicmVxdWVzdGVkIiwicXVlcnlTZWxlY3RvciIsImxlbiIsInNpZGVDYXBpdGFsaXplZCIsInRvTG93ZXJDYXNlIiwiYWx0U2lkZSIsIm9wU2lkZSIsImFycm93RWxlbWVudFNpemUiLCJjZW50ZXIiLCJwb3BwZXJNYXJnaW5TaWRlIiwicG9wcGVyQm9yZGVyU2lkZSIsInNpZGVWYWx1ZSIsIm1pbiIsIl9kYXRhJG9mZnNldHMkYXJyb3ciLCJkZWZpbmVQcm9wZXJ0eSIsImdldE9wcG9zaXRlVmFyaWF0aW9uIiwicGxhY2VtZW50cyIsInZhbGlkUGxhY2VtZW50cyIsImNsb2Nrd2lzZSIsImNvdW50ZXIiLCJpbmRleCIsImNvbmNhdCIsInJldmVyc2UiLCJCRUhBVklPUlMiLCJmbGlwcGVkIiwicGxhY2VtZW50T3Bwb3NpdGUiLCJmbGlwT3JkZXIiLCJiZWhhdmlvciIsIkZMSVAiLCJDTE9DS1dJU0UiLCJDT1VOVEVSQ0xPQ0tXSVNFIiwic3RlcCIsInJlZk9mZnNldHMiLCJvdmVybGFwc1JlZiIsIm92ZXJmbG93c0xlZnQiLCJvdmVyZmxvd3NSaWdodCIsIm92ZXJmbG93c1RvcCIsIm92ZXJmbG93c0JvdHRvbSIsIm92ZXJmbG93c0JvdW5kYXJpZXMiLCJmbGlwcGVkVmFyaWF0aW9uQnlSZWYiLCJmbGlwVmFyaWF0aW9ucyIsImZsaXBwZWRWYXJpYXRpb25CeUNvbnRlbnQiLCJmbGlwVmFyaWF0aW9uc0J5Q29udGVudCIsImZsaXBwZWRWYXJpYXRpb24iLCJrZWVwVG9nZXRoZXIiLCJ0b1ZhbHVlIiwic3RyIiwic2l6ZSIsInBhcnNlT2Zmc2V0IiwiYmFzZVBsYWNlbWVudCIsInVzZUhlaWdodCIsImZyYWdtZW50cyIsImZyYWciLCJ0cmltIiwiZGl2aWRlciIsInNlYXJjaCIsInNwbGl0UmVnZXgiLCJvcHMiLCJvcCIsIm1lcmdlV2l0aFByZXZpb3VzIiwicmVkdWNlIiwiaW5kZXgyIiwicHJldmVudE92ZXJmbG93IiwidHJhbnNmb3JtUHJvcCIsInBvcHBlclN0eWxlcyIsInRyYW5zZm9ybSIsInByaW9yaXR5IiwicHJpbWFyeSIsImVzY2FwZVdpdGhSZWZlcmVuY2UiLCJzZWNvbmRhcnkiLCJzaGlmdCIsInNoaWZ0dmFyaWF0aW9uIiwic2hpZnRPZmZzZXRzIiwiaGlkZSIsImJvdW5kIiwiaW5uZXIiLCJzdWJ0cmFjdExlbmd0aCIsIkRlZmF1bHRzIiwiUG9wcGVyIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiX3RoaXMiLCJiaW5kIiwianF1ZXJ5Iiwib25Mb2FkIiwiVXRpbHMiLCJnbG9iYWwiLCJQb3BwZXJVdGlscyIsIlNoaXB0aW1pemUiLCJjb25zdHJ1Y3RvciIsImNvbnNvbGUiLCJsb2ciLCJib29zdHJhcCIsImpRdWVyeSIsInNldFRpbWVvdXQiLCJ0b29sdGlwcyIsImxvYWRBbmFseXRpY3MiLCJ0b2x0aXAiLCJtZSIsImVhY2giLCJpZHgiLCJlbGVtIiwiYXR0YWNoUG9wcGVyIiwiY29udGFpbmVyIiwiZVRvbHRpcCIsInRvbHRpcFJlZmVyZW5jZSIsInNpYmxpbmdzIiwiZ2V0IiwiZXhwb3J0U3VjY2VzcyIsImFwcExpbmsiLCJwbGF0Zm9ybSIsInNlbmRBbmFseXRpY3NFdmVudCIsImNhdGVnb3J5IiwiYWN0aW9uIiwibGFiZWwiLCJnYSIsInRyYW5zcG9ydCIsInMiLCJvIiwiZyIsInIiLCJtIiwicSIsImwiLCJEYXRlIiwiY3JlYXRlRWxlbWVudCIsImdldEVsZW1lbnRzQnlUYWdOYW1lIiwiYXN5bmMiLCJzcmMiLCJpbnNlcnRCZWZvcmUiLCJtb25pdG9yTGFiZWxTdGF0dXMiLCJjYWxsYmFja1VybCIsInBvc3QiLCJsYWJlbG1vbml0b3J1cmwiLCJyZXNwb25zZSIsImh0dHBDb2RlIiwibG9hZGVyTXNnIiwic2hpcHRpbWl6ZV9sYWJlbF9yZXF1ZXN0IiwiRmluaXNoZWQiLCJjbG9zZUxvYWRlciIsIkVycm9yIiwiSWQiLCJJbmZvIiwiTGFiZWxGaWxlIiwibGFiZWxpbmZvIiwic2hpcHRpbWl6ZV9sYWJlbF9jbGljayIsInNoaXB0aW1pemVfbGFiZWxfbGFiZWwiLCJvcGVuIiwiQ2xpZW50UmVmZXJlbmNlQ29kZUxpc3QiLCJsYWJlbHJlc3VsdCIsIlJlZmVyZW5jZUNvZGUiLCJhZGRDbGFzcyIsIm1lc3NhZ2UiLCJtc2ciLCJvcGVuTG9hZGVyIiwiYXBwZW5kIiwicmVtb3ZlIiwic2hpcHRpbWl6ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///866\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The require scope
/******/ 	var __webpack_require__ = {};
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval-source-map devtool is used.
/******/ 	var __webpack_exports__ = {};
/******/ 	__webpack_modules__[866](0, __webpack_exports__, __webpack_require__);
/******/ 	
/******/ })()
;