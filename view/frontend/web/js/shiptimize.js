!function(i){var n={};function B(I){if(n[I])return n[I].exports;var Q=n[I]={i:I,l:!1,exports:{}};return i[I].call(Q.exports,Q,Q.exports,B),Q.l=!0,Q.exports}B.m=i,B.c=n,B.d=function(I,Q,i){B.o(I,Q)||Object.defineProperty(I,Q,{enumerable:!0,get:i})},B.r=function(I){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(I,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(I,"__esModule",{value:!0})},B.t=function(Q,I){if(1&I&&(Q=B(Q)),8&I)return Q;if(4&I&&"object"==typeof Q&&Q&&Q.__esModule)return Q;var i=Object.create(null);if(B.r(i),Object.defineProperty(i,"default",{enumerable:!0,value:Q}),2&I&&"string"!=typeof Q)for(var n in Q)B.d(i,n,function(I){return Q[I]}.bind(null,n));return i},B.n=function(I){var Q=I&&I.__esModule?function(){return I.default}:function(){return I};return B.d(Q,"a",Q),Q},B.o=function(I,Q){return Object.prototype.hasOwnProperty.call(I,Q)},B.p="/js/",B(B.s=1)}([function(module,exports,__webpack_require__){"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\n/** \n * Singleton object we can use for platform independent stuff \n */\nvar ShiptimizeUtils = function () {\n  function ShiptimizeUtils() {\n    _classCallCheck(this, ShiptimizeUtils);\n  }\n\n  /** \n   * Inject Script into the page \n   * @param string src \n   */\n\n\n  _createClass(ShiptimizeUtils, [{\n    key: "injectExternalScript",\n    value: function injectExternalScript(src) {\n      var s = document.createElement("script");\n      s.setAttribute("src", src);\n      document.body.appendChild(s);\n    }\n\n    /** \n     * Inject a script string \n     */\n\n  }, {\n    key: "injectScript",\n    value: function injectScript(contents) {\n      var e = document.createElement("script");\n      e.value = contents;\n      document.body.appendChild(e);\n    }\n\n    /** \n     * Removes all not numeric chars from the string \n     *\n     * @param string string - the input string \n     * @return the string without chars that are not numbers \n     */\n\n  }, {\n    key: "removeNonNumeric",\n    value: function removeNonNumeric(string) {\n      return string.replace(/\\D/g, \'\');\n    }\n\n    /** \n     * Check if the given url exists and is valid\n     * We use this to check if the carrier icon exists given \n     * a url path and the naming convention {carrier_id}.svg \n     * Make sure the correct protocol is appended to the url http != https \n     * \n     * @return true it the url exists and is valid \n     */\n\n  }, {\n    key: "isUrlValid",\n    value: function isUrlValid(url) {\n      var http = new XMLHttpRequest();\n      http.open(\'HEAD\', url, false);\n      http.send();\n      return http.status == 200;\n    }\n\n    /** \n     * Open a new window with the provided URL \n     * @string url \n     * @return bool if the window was opened, false if popup blocker enabled \n     */\n\n  }, {\n    key: "openNewWindow",\n    value: function openNewWindow(url, options) {\n      var newWin = window.open(url, \'_blank\', options);\n      var blocked = !newWin || newWin.closed || typeof newWin.closed == \'undefined\';\n\n      return !blocked;\n    }\n  }]);\n\n  return ShiptimizeUtils;\n}();\n\nvar utils = new ShiptimizeUtils();\nexports.default = utils;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9qcy9zaGlwdGltaXplLXV0aWxzLmpzPzAwZDQiXSwibmFtZXMiOlsiU2hpcHRpbWl6ZVV0aWxzIiwic3JjIiwicyIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsInNldEF0dHJpYnV0ZSIsImJvZHkiLCJhcHBlbmRDaGlsZCIsImNvbnRlbnRzIiwiZSIsInZhbHVlIiwic3RyaW5nIiwicmVwbGFjZSIsInVybCIsImh0dHAiLCJYTUxIdHRwUmVxdWVzdCIsIm9wZW4iLCJzZW5kIiwic3RhdHVzIiwib3B0aW9ucyIsIm5ld1dpbiIsIndpbmRvdyIsImJsb2NrZWQiLCJjbG9zZWQiLCJ1dGlscyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBOzs7SUFHTUEsZTtBQUVGLDZCQUFjO0FBQUE7QUFFYjs7QUFHRDs7Ozs7Ozs7eUNBSXFCQyxHLEVBQUs7QUFDdEIsVUFBSUMsSUFBSUMsU0FBU0MsYUFBVCxDQUF1QixRQUF2QixDQUFSO0FBQ0FGLFFBQUVHLFlBQUYsQ0FBZSxLQUFmLEVBQXNCSixHQUF0QjtBQUNBRSxlQUFTRyxJQUFULENBQWNDLFdBQWQsQ0FBMEJMLENBQTFCO0FBQ0g7O0FBR0Q7Ozs7OztpQ0FHYU0sUSxFQUFVO0FBQ25CLFVBQUlDLElBQUlOLFNBQVNDLGFBQVQsQ0FBdUIsUUFBdkIsQ0FBUjtBQUNBSyxRQUFFQyxLQUFGLEdBQVVGLFFBQVY7QUFDQUwsZUFBU0csSUFBVCxDQUFjQyxXQUFkLENBQTBCRSxDQUExQjtBQUNIOztBQUVEOzs7Ozs7Ozs7cUNBTWlCRSxNLEVBQVE7QUFDckIsYUFBT0EsT0FBT0MsT0FBUCxDQUFlLEtBQWYsRUFBc0IsRUFBdEIsQ0FBUDtBQUNIOztBQUVEOzs7Ozs7Ozs7OzsrQkFRV0MsRyxFQUFLO0FBQ1osVUFBSUMsT0FBTyxJQUFJQyxjQUFKLEVBQVg7QUFDQUQsV0FBS0UsSUFBTCxDQUFVLE1BQVYsRUFBa0JILEdBQWxCLEVBQXVCLEtBQXZCO0FBQ0FDLFdBQUtHLElBQUw7QUFDQSxhQUFPSCxLQUFLSSxNQUFMLElBQWUsR0FBdEI7QUFDSDs7QUFFRDs7Ozs7Ozs7a0NBS2NMLEcsRUFBS00sTyxFQUFRO0FBQ3ZCLFVBQUlDLFNBQVNDLE9BQU9MLElBQVAsQ0FBWUgsR0FBWixFQUFpQixRQUFqQixFQUEyQk0sT0FBM0IsQ0FBYjtBQUNBLFVBQUlHLFVBQVUsQ0FBQ0YsTUFBRCxJQUFXQSxPQUFPRyxNQUFsQixJQUE0QixPQUFPSCxPQUFPRyxNQUFkLElBQXNCLFdBQWhFOztBQUVBLGFBQU8sQ0FBQ0QsT0FBUjtBQUNIOzs7Ozs7QUFJTCxJQUFJRSxRQUFRLElBQUl4QixlQUFKLEVBQVo7a0JBQ2V3QixLIiwiZmlsZSI6IjAuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiogXG4gKiBTaW5nbGV0b24gb2JqZWN0IHdlIGNhbiB1c2UgZm9yIHBsYXRmb3JtIGluZGVwZW5kZW50IHN0dWZmIFxuICovXG5jbGFzcyBTaGlwdGltaXplVXRpbHMge1xuXG4gICAgY29uc3RydWN0b3IoKSB7XG5cbiAgICB9XG5cblxuICAgIC8qKiBcbiAgICAgKiBJbmplY3QgU2NyaXB0IGludG8gdGhlIHBhZ2UgXG4gICAgICogQHBhcmFtIHN0cmluZyBzcmMgXG4gICAgICovXG4gICAgaW5qZWN0RXh0ZXJuYWxTY3JpcHQoc3JjKSB7XG4gICAgICAgIGxldCBzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKTtcbiAgICAgICAgcy5zZXRBdHRyaWJ1dGUoXCJzcmNcIiwgc3JjKTtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChzKTtcbiAgICB9XG5cblxuICAgIC8qKiBcbiAgICAgKiBJbmplY3QgYSBzY3JpcHQgc3RyaW5nIFxuICAgICAqL1xuICAgIGluamVjdFNjcmlwdChjb250ZW50cykge1xuICAgICAgICBsZXQgZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIik7XG4gICAgICAgIGUudmFsdWUgPSBjb250ZW50cztcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChlKTtcbiAgICB9XG5cbiAgICAvKiogXG4gICAgICogUmVtb3ZlcyBhbGwgbm90IG51bWVyaWMgY2hhcnMgZnJvbSB0aGUgc3RyaW5nIFxuICAgICAqXG4gICAgICogQHBhcmFtIHN0cmluZyBzdHJpbmcgLSB0aGUgaW5wdXQgc3RyaW5nIFxuICAgICAqIEByZXR1cm4gdGhlIHN0cmluZyB3aXRob3V0IGNoYXJzIHRoYXQgYXJlIG5vdCBudW1iZXJzIFxuICAgICAqL1xuICAgIHJlbW92ZU5vbk51bWVyaWMoc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmcucmVwbGFjZSgvXFxEL2csICcnKTtcbiAgICB9XG5cbiAgICAvKiogXG4gICAgICogQ2hlY2sgaWYgdGhlIGdpdmVuIHVybCBleGlzdHMgYW5kIGlzIHZhbGlkXG4gICAgICogV2UgdXNlIHRoaXMgdG8gY2hlY2sgaWYgdGhlIGNhcnJpZXIgaWNvbiBleGlzdHMgZ2l2ZW4gXG4gICAgICogYSB1cmwgcGF0aCBhbmQgdGhlIG5hbWluZyBjb252ZW50aW9uIHtjYXJyaWVyX2lkfS5zdmcgXG4gICAgICogTWFrZSBzdXJlIHRoZSBjb3JyZWN0IHByb3RvY29sIGlzIGFwcGVuZGVkIHRvIHRoZSB1cmwgaHR0cCAhPSBodHRwcyBcbiAgICAgKiBcbiAgICAgKiBAcmV0dXJuIHRydWUgaXQgdGhlIHVybCBleGlzdHMgYW5kIGlzIHZhbGlkIFxuICAgICAqLyBcbiAgICBpc1VybFZhbGlkKHVybCkge1xuICAgICAgICB2YXIgaHR0cCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICBodHRwLm9wZW4oJ0hFQUQnLCB1cmwsIGZhbHNlKTtcbiAgICAgICAgaHR0cC5zZW5kKCk7XG4gICAgICAgIHJldHVybiBodHRwLnN0YXR1cyA9PSAyMDA7XG4gICAgfVxuXG4gICAgLyoqIFxuICAgICAqIE9wZW4gYSBuZXcgd2luZG93IHdpdGggdGhlIHByb3ZpZGVkIFVSTCBcbiAgICAgKiBAc3RyaW5nIHVybCBcbiAgICAgKiBAcmV0dXJuIGJvb2wgaWYgdGhlIHdpbmRvdyB3YXMgb3BlbmVkLCBmYWxzZSBpZiBwb3B1cCBibG9ja2VyIGVuYWJsZWQgXG4gICAgICovICBcbiAgICBvcGVuTmV3V2luZG93KHVybCwgb3B0aW9ucyl7XG4gICAgICAgIGxldCBuZXdXaW4gPSB3aW5kb3cub3Blbih1cmwsICdfYmxhbmsnLCBvcHRpb25zKTsgXG4gICAgICAgIGxldCBibG9ja2VkID0gIW5ld1dpbiB8fCBuZXdXaW4uY2xvc2VkIHx8IHR5cGVvZiBuZXdXaW4uY2xvc2VkPT0ndW5kZWZpbmVkJzsgXG5cbiAgICAgICAgcmV0dXJuICFibG9ja2VkOyBcbiAgICB9XG59XG5cblxubGV0IHV0aWxzID0gbmV3IFNoaXB0aW1pemVVdGlscygpO1xuZXhwb3J0IGRlZmF1bHQgdXRpbHM7Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///0\n')},function(module,exports,__webpack_require__){"use strict";eval("\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\n__webpack_require__(2);\n\n__webpack_require__(3);\n\nvar _shiptimizeUtils = __webpack_require__(0);\n\nvar _shiptimizeUtils2 = _interopRequireDefault(_shiptimizeUtils);\n\nvar _shiptimizeMagento = __webpack_require__(4);\n\nvar _shiptimizeMagento2 = _interopRequireDefault(_shiptimizeMagento);\n\nvar _shiptimizeGmaps = __webpack_require__(5);\n\nvar _shiptimizeGmaps2 = _interopRequireDefault(_shiptimizeGmaps);\n\nvar _shiptimizeOpenMap = __webpack_require__(6);\n\nvar _shiptimizeOpenMap2 = _interopRequireDefault(_shiptimizeOpenMap);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/** \n * Class Shiptimize depends on jQuery. \n * Check if we are meant to append a map \n * \n * Platform dependent functions marked with   * @platformDependent \n */\nvar Shiptimize = function () {\n    function Shiptimize(ajax_url) {\n        _classCallCheck(this, Shiptimize);\n\n        this.markers = []; //pickup {lat, lng} \n        this.isMapLoaded = false;\n        this.gmaps_key = shiptimize_maps_key;\n        this.openMapMarkerIcons = {};\n        this.ajax_url = ajax_url; // platform dependent \n\n        this.platform = new _shiptimizeMagento2.default(this.ajax_url);\n\n        this.map = shiptimize_maps_key ? new _shiptimizeGmaps2.default(shiptimize_maps_key) : new _shiptimizeOpenMap2.default();\n        this.platform.isCheckout();\n    }\n\n    /** \n     * Show the map to the user \n     */\n\n\n    _createClass(Shiptimize, [{\n        key: 'showMap',\n        value: function showMap() {\n            this.map.grantReady();\n            this.userScroll = jQuery('html,body').scrollTop();\n            jQuery('html,body').scrollTop(0);\n            jQuery(\".shiptimize-pickup\").addClass(\"active\");\n            this.platform.pickupPoint = {};\n        }\n\n        /** \n         * Hide the map   \n         */\n\n    }, {\n        key: 'hideMap',\n        value: function hideMap() {\n            jQuery(\".shiptimize-pickup\").removeClass(\"active\");\n            jQuery(\".shiptimize-pickup__error\").hide();\n            jQuery('html,body').scrollTop(this.userScroll);\n        }\n    }, {\n        key: 'clearMarkers',\n        value: function clearMarkers() {\n            this.map.clearMarkers();\n        }\n\n        /** \n         * Generate the inputs for the user to append extra info if necessary \n         * The id of these fields is in the format shiptimize_extra_{PointId}_{FieldId}\n         */\n\n    }, {\n        key: 'getExtendedInfoHtml',\n        value: function getExtendedInfoHtml(pickupPoint) {\n            if (!pickupPoint.ExtendedInfo || typeof pickupPoint.ExtendedInfo.length == 'undefined') {\n                return \"\";\n            }\n\n            var html = '';\n\n            for (var x = 0; pickupPoint.ExtendedInfo && x < pickupPoint.ExtendedInfo.length; ++x) {\n                var extraInfo = pickupPoint.ExtendedInfo[x];\n                html += '<div class=\"shiptimize-pickup__extended\">' + '<label class=\"shiptimize-pickup__extended_label \">' + extraInfo.Tekst + '</label>' + '<input type=\"text\" name=\"shiptimize_pickup_extended_value\" value=\"\" id=\"shiptimize_extra_' + pickupPoint.PointId + '_' + extraInfo.FieldId + '\"/> ' + '<input type=\"hidden\" name=\"shiptimize_pickup_extended_id\" id=\"shiptimize_pickup\" value=\"' + extraInfo.FieldId + '\"/> ' + '</div>';\n            }\n\n            return html;\n        }\n\n        /**\n         * Reset all markers  \n         * Select the marker of index idx in map \n         */\n\n    }, {\n        key: 'selectPointFromListInMap',\n        value: function selectPointFromListInMap(idx) {\n            jQuery(\"input[name='shiptimize__point']\").prop('checked', false);\n            this.map.selectMarkerByIdx(idx);\n\n            jQuery(jQuery(\"input[name='shiptimize__point']\").get(idx)).prop('checked', true);\n        }\n\n        /** \n         * When the user clicks the validate button \n         */\n\n    }, {\n        key: 'selectFromList',\n        value: function selectFromList() {\n            var idx = jQuery(\"input[name='shiptimize__point']:checked\").val();\n\n            if (!this.pickupPoints || typeof this.pickupPoints[idx] == 'undefined') {\n                console.log(\"Invalid pickup. Did the user click select before selecting a point?\");\n                return;\n            }\n\n            var pickup = this.pickupPoints[idx];\n            var extra = '';\n\n            for (var i = 0; pickup.ExtendedInfo && i < pickup.ExtendedInfo.length; ++i) {\n                extra += \"<br/>\" + pickup.ExtendedInfo[i].Tekst + ': ' + jQuery(\"#shiptimize_extra_\" + pickup.PointId + \"_\" + pickup.ExtendedInfo[i].FieldId).val();\n            }\n\n            jQuery(\".shiptimize-pickup__description\").html(shiptimize_selected_pickup + \" : \" + pickup.Information.Name + \" \" + pickup.Information.Address + \" \" + extra);\n\n            this.platform.setPickupPoint(pickup);\n            this.hideMap();\n        }\n\n        /** \n         *  Returns the distance between 2 (lat,lng) points in kms \n         */\n\n    }, {\n        key: 'getDistance',\n        value: function getDistance(latlng, latlng2) {\n\n            var R = 6371e3; // metres\n            var φ1 = latlng.lat().toRadians();\n            var φ2 = latlng2.lng().toRadians();\n\n            var Δφ = (latln2.lat() - latlng.lng()).toRadians();\n            var Δλ = (latln2.lng() - latlng.lon()).toRadians();\n\n            var a = Math.sin(Δφ / 2) * Math.sin(Δφ / 2) + Math.cos(φ1) * Math.cos(φ2) * Math.sin(Δλ / 2) * Math.sin(Δλ / 2);\n            var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n\n            var d = Math.floor(R * c / 1000);\n        }\n\n        /** \n         * Show the map and query the server for pickup locations near the shipping address provided by the client\n         * center the map on the first point \n         * remove old markers \n         * add the new markers  \n         */\n\n    }, {\n        key: 'getPickupLocations',\n        value: function getPickupLocations() {\n            var _this = this;\n\n            this.showMap();\n\n            var data = this.platform.getShippingData();\n            data.action = 'shiptimize_pickup_locations';\n\n            this.map.setCarrierIcon(data.CarrierId);\n\n            this.map.geocode(data, function (geocode) {\n                _this.getPickupLocationsFromGeocodedAddr(geocode, data);\n            });\n        }\n    }, {\n        key: 'getPickupLocationsFromGeocodedAddr',\n        value: function getPickupLocationsFromGeocodedAddr(geocode, data) {\n            var _this2 = this;\n\n            this.resetUI();\n\n            data.Address.Country = geocode.iso2;\n            data.Address.Long = geocode.lng;\n            data.Address.Lat = geocode.lat;\n\n            console.log(data);\n            console.log(geocode);\n\n            jQuery.getJSON(this.ajax_url, data, function (pickupPoints) {\n                if (pickupPoints.length == 0) {\n                    console.log(\"no pickup points found for this address \");\n                    return;\n                }\n\n                console.log(pickupPoints);\n                if (pickupPoints.Error.Id == 0 && pickupPoints.Point.length > 0) {\n                    jQuery(\".shiptimize-pickup__options,.shiptimize-pickup__map\").show();\n                    _this2.setPickupLocations(pickupPoints.Point);\n                } else {\n                    console.log(\"The api returned an error \", pickupPoints.Error); //pickupPoints.Error.Info || \n                    _this2.pickupError(shiptimize_no_points_found);\n                }\n            });\n        }\n    }, {\n        key: 'resetUI',\n        value: function resetUI() {\n            jQuery(\".shiptimize-pickup__error\").hide();\n            this.map.clearMarkers();\n        }\n\n        /** \n         * @param string info - the message to display \n         */\n\n    }, {\n        key: 'pickupError',\n        value: function pickupError(info) {\n            this.pickupPoints = [];\n\n            var eError = jQuery(\".shiptimize-pickup__error\");\n            eError.html(info);\n            eError.show();\n\n            jQuery(\".shiptimize-pickup__options,.shiptimize-pickup__map\").hide();\n        }\n\n        /** \n         * Append the pickup Locations to the map\n         * @param array pickupPoints - an array of available pickup points \n         */\n\n    }, {\n        key: 'setPickupLocations',\n        value: function setPickupLocations(pickupPoints) {\n            var _this3 = this;\n\n            jQuery(\".shiptimize-pickup__error\").hide();\n\n            this.pickupPoints = pickupPoints;\n            this.map.clearMarkers();\n            this.map.centerMap(this.pickupPoints[0].Lat, this.pickupPoints[1].Long);\n            this.map.addMarkers(pickupPoints, function (idx) {\n                _this3.selectPointFromListInMap(idx);\n            });\n            this.setOptionsForAddress(pickupPoints);\n        }\n\n        /** \n         * @param pickupPoints[] - [] of pickup points returned by the api \n         */\n\n    }, {\n        key: 'setOptionsForAddress',\n        value: function setOptionsForAddress(pickupPoints) {\n\n            var html = '';\n            for (var i = 0; i < pickupPoints.length; ++i) {\n                html += '<div class=\"shiptimize-pickup__point\">' + '<input type=\"radio\" value=\"' + i + '\" name=\"shiptimize__point\"  onclick=\"shiptimize.selectPointFromListInMap(' + i + ')\"/>' + '<span class=\"shiptimize-pickup__point_description\" onclick=\"shiptimize.selectPointFromListInMap(' + i + ')\">' + '<span>' + (pickupPoints[i].Information.Name ? pickupPoints[i].Information.Name + '<br/>' : '') + pickupPoints[i].Information.Address + '</span>' + this.getExtendedInfoHtml(pickupPoints[i]) + '</span>' + '</div>';\n            }\n            console.log(html);\n\n            jQuery(\".shiptimize-pickup__other\").html(html);\n        }\n    }, {\n        key: 'loadMap',\n        value: function loadMap() {\n            this.map.loadMap();\n        }\n    }]);\n\n    return Shiptimize;\n}();\n\nif (typeof jQuery != 'undefined') {\n    jQuery(function () {\n        window.shiptimize = new Shiptimize(shiptimize_ajax_pickup_points);\n    });\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zaGlwdG1pemUuanM/NjljNyJdLCJuYW1lcyI6WyJTaGlwdGltaXplIiwiYWpheF91cmwiLCJtYXJrZXJzIiwiaXNNYXBMb2FkZWQiLCJnbWFwc19rZXkiLCJzaGlwdGltaXplX21hcHNfa2V5Iiwib3Blbk1hcE1hcmtlckljb25zIiwicGxhdGZvcm0iLCJNYWdlbnRvIiwibWFwIiwiR29vZ2xlTWFwIiwiT3BlblN0cmVldE1hcCIsImlzQ2hlY2tvdXQiLCJncmFudFJlYWR5IiwidXNlclNjcm9sbCIsImpRdWVyeSIsInNjcm9sbFRvcCIsImFkZENsYXNzIiwicGlja3VwUG9pbnQiLCJyZW1vdmVDbGFzcyIsImhpZGUiLCJjbGVhck1hcmtlcnMiLCJFeHRlbmRlZEluZm8iLCJsZW5ndGgiLCJodG1sIiwieCIsImV4dHJhSW5mbyIsIlRla3N0IiwiUG9pbnRJZCIsIkZpZWxkSWQiLCJpZHgiLCJwcm9wIiwic2VsZWN0TWFya2VyQnlJZHgiLCJnZXQiLCJ2YWwiLCJwaWNrdXBQb2ludHMiLCJjb25zb2xlIiwibG9nIiwicGlja3VwIiwiZXh0cmEiLCJpIiwic2hpcHRpbWl6ZV9zZWxlY3RlZF9waWNrdXAiLCJJbmZvcm1hdGlvbiIsIk5hbWUiLCJBZGRyZXNzIiwic2V0UGlja3VwUG9pbnQiLCJoaWRlTWFwIiwibGF0bG5nIiwibGF0bG5nMiIsIlIiLCLPhjEiLCJsYXQiLCJ0b1JhZGlhbnMiLCLPhjIiLCJsbmciLCLOlM+GIiwibGF0bG4yIiwizpTOuyIsImxvbiIsImEiLCJNYXRoIiwic2luIiwiY29zIiwiYyIsImF0YW4yIiwic3FydCIsImQiLCJmbG9vciIsInNob3dNYXAiLCJkYXRhIiwiZ2V0U2hpcHBpbmdEYXRhIiwiYWN0aW9uIiwic2V0Q2Fycmllckljb24iLCJDYXJyaWVySWQiLCJnZW9jb2RlIiwiZ2V0UGlja3VwTG9jYXRpb25zRnJvbUdlb2NvZGVkQWRkciIsInJlc2V0VUkiLCJDb3VudHJ5IiwiaXNvMiIsIkxvbmciLCJMYXQiLCJnZXRKU09OIiwiRXJyb3IiLCJJZCIsIlBvaW50Iiwic2hvdyIsInNldFBpY2t1cExvY2F0aW9ucyIsInBpY2t1cEVycm9yIiwic2hpcHRpbWl6ZV9ub19wb2ludHNfZm91bmQiLCJpbmZvIiwiZUVycm9yIiwiY2VudGVyTWFwIiwiYWRkTWFya2VycyIsInNlbGVjdFBvaW50RnJvbUxpc3RJbk1hcCIsInNldE9wdGlvbnNGb3JBZGRyZXNzIiwiZ2V0RXh0ZW5kZWRJbmZvSHRtbCIsImxvYWRNYXAiLCJ3aW5kb3ciLCJzaGlwdGltaXplIiwic2hpcHRpbWl6ZV9hamF4X3BpY2t1cF9wb2ludHMiXSwibWFwcGluZ3MiOiI7Ozs7QUFBQTs7QUFDQTs7QUFFQTs7OztBQUNBOzs7O0FBRUE7Ozs7QUFDQTs7Ozs7Ozs7QUFFQTs7Ozs7O0lBTU1BLFU7QUFFRix3QkFBWUMsUUFBWixFQUFzQjtBQUFBOztBQUNsQixhQUFLQyxPQUFMLEdBQWUsRUFBZixDQURrQixDQUNDO0FBQ25CLGFBQUtDLFdBQUwsR0FBbUIsS0FBbkI7QUFDQSxhQUFLQyxTQUFMLEdBQWlCQyxtQkFBakI7QUFDQSxhQUFLQyxrQkFBTCxHQUEwQixFQUExQjtBQUNBLGFBQUtMLFFBQUwsR0FBZ0JBLFFBQWhCLENBTGtCLENBS1E7O0FBRTFCLGFBQUtNLFFBQUwsR0FBZ0IsSUFBSUMsMkJBQUosQ0FBWSxLQUFLUCxRQUFqQixDQUFoQjs7QUFFQSxhQUFLUSxHQUFMLEdBQVdKLHNCQUFzQixJQUFJSyx5QkFBSixDQUFjTCxtQkFBZCxDQUF0QixHQUEyRCxJQUFJTSwyQkFBSixFQUF0RTtBQUNBLGFBQUtKLFFBQUwsQ0FBY0ssVUFBZDtBQUNIOztBQUVEOzs7Ozs7O2tDQUdVO0FBQ04saUJBQUtILEdBQUwsQ0FBU0ksVUFBVDtBQUNBLGlCQUFLQyxVQUFMLEdBQWtCQyxPQUFPLFdBQVAsRUFBb0JDLFNBQXBCLEVBQWxCO0FBQ0FELG1CQUFPLFdBQVAsRUFBb0JDLFNBQXBCLENBQThCLENBQTlCO0FBQ0FELG1CQUFPLG9CQUFQLEVB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QUFiLEVBQWdCRSxXQUFoQixDQUE0QkMsSUFBNUIsR0FBbUMsT0FBdEUsR0FBZ0YsRUFIeEYsSUFJRFIsYUFBYUssQ0FBYixFQUFnQkUsV0FBaEIsQ0FBNEJFLE9BSjNCLEdBSXFDLFNBSnJDLEdBS0osS0FBS21ELG1CQUFMLENBQXlCNUQsYUFBYUssQ0FBYixDQUF6QixDQUxJLEdBTUosU0FOSSxHQVNKLFFBVEo7QUFVSDtBQUNESixvQkFBUUMsR0FBUixDQUFZYixJQUFaOztBQUVBVCxtQkFBTywyQkFBUCxFQUFvQ1MsSUFBcEMsQ0FBeUNBLElBQXpDO0FBQ0g7OztrQ0FHUztBQUNOLGlCQUFLZixHQUFMLENBQVN1RixPQUFUO0FBQ0g7Ozs7OztBQUdMLElBQUcsT0FBT2pGLE1BQVAsSUFBa0IsV0FBckIsRUFBaUM7QUFDN0JBLFdBQU8sWUFBVztBQUNka0YsZUFBT0MsVUFBUCxHQUFvQixJQUFJbEcsVUFBSixDQUFlbUcsNkJBQWYsQ0FBcEI7QUFDSCxLQUZEO0FBR0giLCJmaWxlIjoiMS5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAnLi9zY3NzL3NoaXB0aW1pemUuc2Nzcyc7XG5pbXBvcnQgJy4vY3NzL2xlYWZsZXQuY3NzJztcblxuaW1wb3J0IFV0aWxzIGZyb20gJy4vanMvc2hpcHRpbWl6ZS11dGlscy5qcyc7XG5pbXBvcnQgTWFnZW50byBmcm9tICcuL2pzL3NoaXB0aW1pemUtbWFnZW50by5qcyc7XG5cbmltcG9ydCBHb29nbGVNYXAgZnJvbSAnLi9qcy9zaGlwdGltaXplLWdtYXBzLmpzJztcbmltcG9ydCBPcGVuU3RyZWV0TWFwIGZyb20gJy4vanMvc2hpcHRpbWl6ZS1vcGVuLW1hcC5qcyc7XG5cbi8qKiBcbiAqIENsYXNzIFNoaXB0aW1pemUgZGVwZW5kcyBvbiBqUXVlcnkuIFxuICogQ2hlY2sgaWYgd2UgYXJlIG1lYW50IHRvIGFwcGVuZCBhIG1hcCBcbiAqIFxuICogUGxhdGZvcm0gZGVwZW5kZW50IGZ1bmN0aW9ucyBtYXJrZWQgd2l0aCAgICogQHBsYXRmb3JtRGVwZW5kZW50IFxuICovXG5jbGFzcyBTaGlwdGltaXplIHtcblxuICAgIGNvbnN0cnVjdG9yKGFqYXhfdXJsKSB7XG4gICAgICAgIHRoaXMubWFya2VycyA9IFtdOyAvL3BpY2t1cCB7bGF0LCBsbmd9IFxuICAgICAgICB0aGlzLmlzTWFwTG9hZGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZ21hcHNfa2V5ID0gc2hpcHRpbWl6ZV9tYXBzX2tleTtcbiAgICAgICAgdGhpcy5vcGVuTWFwTWFya2VySWNvbnMgPSB7fTtcbiAgICAgICAgdGhpcy5hamF4X3VybCA9IGFqYXhfdXJsOyAvLyBwbGF0Zm9ybSBkZXBlbmRlbnQgXG5cbiAgICAgICAgdGhpcy5wbGF0Zm9ybSA9IG5ldyBNYWdlbnRvKHRoaXMuYWpheF91cmwpO1xuXG4gICAgICAgIHRoaXMubWFwID0gc2hpcHRpbWl6ZV9tYXBzX2tleSA/IG5ldyBHb29nbGVNYXAoc2hpcHRpbWl6ZV9tYXBzX2tleSkgOiBuZXcgT3BlblN0cmVldE1hcCgpO1xuICAgICAgICB0aGlzLnBsYXRmb3JtLmlzQ2hlY2tvdXQoKTsgXG4gICAgfVxuXG4gICAgLyoqIFxuICAgICAqIFNob3cgdGhlIG1hcCB0byB0aGUgdXNlciBcbiAgICAgKi9cbiAgICBzaG93TWFwKCkge1xuICAgICAgICB0aGlzLm1hcC5ncmFudFJlYWR5KCk7XG4gICAgICAgIHRoaXMudXNlclNjcm9sbCA9IGpRdWVyeSgnaHRtbCxib2R5Jykuc2Nyb2xsVG9wKCk7IFxuICAgICAgICBqUXVlcnkoJ2h0bWwsYm9keScpLnNjcm9sbFRvcCgwKTsgXG4gICAgICAgIGpRdWVyeShcIi5zaGlwdGltaXplLXBpY2t1cFwiKS5hZGRDbGFzcyhcImFjdGl2ZVwiKTsgXG4gICAgICAgIHRoaXMucGxhdGZvcm0ucGlja3VwUG9pbnQgPSB7fTtcbiAgICB9XG5cbiAgICAvKiogXG4gICAgICogSGlkZSB0aGUgbWFwICAgXG4gICAgICovXG4gICAgaGlkZU1hcCgpIHtcbiAgICAgICAgalF1ZXJ5KFwiLnNoaXB0aW1pemUtcGlja3VwXCIpLnJlbW92ZUNsYXNzKFwiYWN0aXZlXCIpO1xuICAgICAgICBqUXVlcnkoXCIuc2hpcHRpbWl6ZS1waWNrdXBfX2Vycm9yXCIpLmhpZGUoKTtcbiAgICAgICAgalF1ZXJ5KCdodG1sLGJvZHknKS5zY3JvbGxUb3AodGhpcy51c2VyU2Nyb2xsKTsgXG4gICAgfVxuXG4gICAgY2xlYXJNYXJrZXJzKCkge1xuICAgICAgICB0aGlzLm1hcC5jbGVhck1hcmtlcnMoKTtcbiAgICB9XG5cbiAgICAvKiogXG4gICAgICogR2VuZXJhdGUgdGhlIGlucHV0cyBmb3IgdGhlIHVzZXIgdG8gYXBwZW5kIGV4dHJhIGluZm8gaWYgbmVjZXNzYXJ5IFxuICAgICAqIFRoZSBpZCBvZiB0aGVzZSBmaWVsZHMgaXMgaW4gdGhlIGZvcm1hdCBzaGlwdGltaXplX2V4dHJhX3tQb2ludElkfV97RmllbGRJZH1cbiAgICAgKi9cbiAgICBnZXRFeHRlbmRlZEluZm9IdG1sKHBpY2t1cFBvaW50KSB7XG4gICAgICAgIGlmICghcGlja3VwUG9pbnQuRXh0ZW5kZWRJbmZvIHx8IHR5cGVvZihwaWNrdXBQb2ludC5FeHRlbmRlZEluZm8ubGVuZ3RoKSA9PSd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBodG1sID0gJyc7XG5cbiAgICAgICAgZm9yIChsZXQgeCA9IDA7IHBpY2t1cFBvaW50LkV4dGVuZGVkSW5mbyAmJiB4IDwgcGlja3VwUG9pbnQuRXh0ZW5kZWRJbmZvLmxlbmd0aDsgKyt4KSB7XG4gICAgICAgICAgICBsZXQgZXh0cmFJbmZvID0gcGlja3VwUG9pbnQuRXh0ZW5kZWRJbmZvW3hdO1xuICAgICAgICAgICAgaHRtbCArPSAnPGRpdiBjbGFzcz1cInNoaXB0aW1pemUtcGlja3VwX19leHRlbmRlZFwiPicgK1xuICAgICAgICAgICAgICAgICc8bGFiZWwgY2xhc3M9XCJzaGlwdGltaXplLXBpY2t1cF9fZXh0ZW5kZWRfbGFiZWwgXCI+JyArIGV4dHJhSW5mby5UZWtzdCArICc8L2xhYmVsPicgK1xuICAgICAgICAgICAgICAgICc8aW5wdXQgdHlwZT1cInRleHRcIiBuYW1lPVwic2hpcHRpbWl6ZV9waWNrdXBfZXh0ZW5kZWRfdmFsdWVcIiB2YWx1ZT1cIlwiIGlkPVwic2hpcHRpbWl6ZV9leHRyYV8nICsgcGlja3VwUG9pbnQuUG9pbnRJZCArICdfJyArIGV4dHJhSW5mby5GaWVsZElkICsgJ1wiLz4gJyArXG4gICAgICAgICAgICAgICAgJzxpbnB1dCB0eXBlPVwiaGlkZGVuXCIgbmFtZT1cInNoaXB0aW1pemVfcGlja3VwX2V4dGVuZGVkX2lkXCIgaWQ9XCJzaGlwdGltaXplX3BpY2t1cFwiIHZhbHVlPVwiJyArIGV4dHJhSW5mby5GaWVsZElkICsgJ1wiLz4gJyArXG4gICAgICAgICAgICAgICAgJzwvZGl2Pic7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaHRtbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXNldCBhbGwgbWFya2VycyAgXG4gICAgICogU2VsZWN0IHRoZSBtYXJrZXIgb2YgaW5kZXggaWR4IGluIG1hcCBcbiAgICAgKi9cbiAgICBzZWxlY3RQb2ludEZyb21MaXN0SW5NYXAoaWR4KSB7XG4gICAgICAgIGpRdWVyeShcImlucHV0W25hbWU9J3NoaXB0aW1pemVfX3BvaW50J11cIikucHJvcCgnY2hlY2tlZCcsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5tYXAuc2VsZWN0TWFya2VyQnlJZHgoaWR4KTtcblxuICAgICAgICBqUXVlcnkoalF1ZXJ5KFwiaW5wdXRbbmFtZT0nc2hpcHRpbWl6ZV9fcG9pbnQnXVwiKS5nZXQoaWR4KSkucHJvcCgnY2hlY2tlZCcsIHRydWUpO1xuICAgIH1cblxuXG4gICAgLyoqIFxuICAgICAqIFdoZW4gdGhlIHVzZXIgY2xpY2tzIHRoZSB2YWxpZGF0ZSBidXR0b24gXG4gICAgICovXG4gICAgc2VsZWN0RnJvbUxpc3QoKSB7XG4gICAgICAgIGxldCBpZHggPSBqUXVlcnkoXCJpbnB1dFtuYW1lPSdzaGlwdGltaXplX19wb2ludCddOmNoZWNrZWRcIikudmFsKCk7XG4gICAgICAgIFxuICAgICAgICBpZighdGhpcy5waWNrdXBQb2ludHMgfHwgdHlwZW9mKHRoaXMucGlja3VwUG9pbnRzW2lkeF0pID09ICd1bmRlZmluZWQnKXtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiSW52YWxpZCBwaWNrdXAuIERpZCB0aGUgdXNlciBjbGljayBzZWxlY3QgYmVmb3JlIHNlbGVjdGluZyBhIHBvaW50P1wiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIFxuICAgICAgICBsZXQgcGlja3VwID0gdGhpcy5waWNrdXBQb2ludHNbaWR4XTtcbiAgICAgICAgbGV0IGV4dHJhID0gJyc7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IHBpY2t1cC5FeHRlbmRlZEluZm8gJiYgaSA8IHBpY2t1cC5FeHRlbmRlZEluZm8ubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGV4dHJhICs9IFwiPGJyLz5cIiArIHBpY2t1cC5FeHRlbmRlZEluZm9baV0uVGVrc3QgKyAnOiAnICsgalF1ZXJ5KFwiI3NoaXB0aW1pemVfZXh0cmFfXCIgKyBwaWNrdXAuUG9pbnRJZCArIFwiX1wiICsgcGlja3VwLkV4dGVuZGVkSW5mb1tpXS5GaWVsZElkKS52YWwoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGpRdWVyeShcIi5zaGlwdGltaXplLXBpY2t1cF9fZGVzY3JpcHRpb25cIikuaHRtbChzaGlwdGltaXplX3NlbGVjdGVkX3BpY2t1cCArIFwiIDogXCIgKyBwaWNrdXAuSW5mb3JtYXRpb24uTmFtZSArIFwiIFwiICsgcGlja3VwLkluZm9ybWF0aW9uLkFkZHJlc3MgKyBcIiBcIiArIGV4dHJhKTtcblxuICAgICAgICB0aGlzLnBsYXRmb3JtLnNldFBpY2t1cFBvaW50KHBpY2t1cCk7XG4gICAgICAgIHRoaXMuaGlkZU1hcCgpO1xuICAgIH1cblxuXG4gICAgLyoqIFxuICAgICAqICBSZXR1cm5zIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIDIgKGxhdCxsbmcpIHBvaW50cyBpbiBrbXMgXG4gICAgICovXG4gICAgZ2V0RGlzdGFuY2UobGF0bG5nLCBsYXRsbmcyKSB7XG5cbiAgICAgICAgdmFyIFIgPSA2MzcxZTM7IC8vIG1ldHJlc1xuICAgICAgICB2YXIgz4YxID0gbGF0bG5nLmxhdCgpLnRvUmFkaWFucygpO1xuICAgICAgICB2YXIgz4YyID0gbGF0bG5nMi5sbmcoKS50b1JhZGlhbnMoKTtcblxuICAgICAgICB2YXIgzpTPhiA9IChsYXRsbjIubGF0KCkgLSBsYXRsbmcubG5nKCkpLnRvUmFkaWFucygpO1xuICAgICAgICB2YXIgzpTOuyA9IChsYXRsbjIubG5nKCkgLSBsYXRsbmcubG9uKCkpLnRvUmFkaWFucygpO1xuXG4gICAgICAgIHZhciBhID0gTWF0aC5zaW4ozpTPhiAvIDIpICogTWF0aC5zaW4ozpTPhiAvIDIpICtcbiAgICAgICAgICAgIE1hdGguY29zKM+GMSkgKiBNYXRoLmNvcyjPhjIpICpcbiAgICAgICAgICAgIE1hdGguc2luKM6UzrsgLyAyKSAqIE1hdGguc2luKM6UzrsgLyAyKTtcbiAgICAgICAgdmFyIGMgPSAyICogTWF0aC5hdGFuMihNYXRoLnNxcnQoYSksIE1hdGguc3FydCgxIC0gYSkpO1xuXG4gICAgICAgIHZhciBkID0gTWF0aC5mbG9vcihSICogYyAvIDEwMDApO1xuICAgIH1cblxuICAgIC8qKiBcbiAgICAgKiBTaG93IHRoZSBtYXAgYW5kIHF1ZXJ5IHRoZSBzZXJ2ZXIgZm9yIHBpY2t1cCBsb2NhdGlvbnMgbmVhciB0aGUgc2hpcHBpbmcgYWRkcmVzcyBwcm92aWRlZCBieSB0aGUgY2xpZW50XG4gICAgICogY2VudGVyIHRoZSBtYXAgb24gdGhlIGZpcnN0IHBvaW50IFxuICAgICAqIHJlbW92ZSBvbGQgbWFya2VycyBcbiAgICAgKiBhZGQgdGhlIG5ldyBtYXJrZXJzICBcbiAgICAgKi9cbiAgICBnZXRQaWNrdXBMb2NhdGlvbnMoKSB7XG4gICAgICAgIHRoaXMuc2hvd01hcCgpO1xuXG4gICAgICAgIGxldCBkYXRhID0gdGhpcy5wbGF0Zm9ybS5nZXRTaGlwcGluZ0RhdGEoKTtcbiAgICAgICAgZGF0YS5hY3Rpb24gPSAnc2hpcHRpbWl6ZV9waWNrdXBfbG9jYXRpb25zJztcblxuICAgICAgICB0aGlzLm1hcC5zZXRDYXJyaWVySWNvbihkYXRhLkNhcnJpZXJJZCk7XG5cbiAgICAgICAgdGhpcy5tYXAuZ2VvY29kZShkYXRhLCAoZ2VvY29kZSkgPT4geyB0aGlzLmdldFBpY2t1cExvY2F0aW9uc0Zyb21HZW9jb2RlZEFkZHIoZ2VvY29kZSwgZGF0YSk7IH0pO1xuICAgIH1cblxuXG4gICAgZ2V0UGlja3VwTG9jYXRpb25zRnJvbUdlb2NvZGVkQWRkcihnZW9jb2RlLCBkYXRhKSB7XG4gICAgICAgIHRoaXMucmVzZXRVSSgpOyBcbiAgICAgICAgXG4gICAgICAgIGRhdGEuQWRkcmVzcy5Db3VudHJ5ID0gZ2VvY29kZS5pc28yO1xuICAgICAgICBkYXRhLkFkZHJlc3MuTG9uZyA9IGdlb2NvZGUubG5nO1xuICAgICAgICBkYXRhLkFkZHJlc3MuTGF0ID0gZ2VvY29kZS5sYXQ7XG5cbiAgICAgICAgY29uc29sZS5sb2coZGF0YSk7XG4gICAgICAgIGNvbnNvbGUubG9nKGdlb2NvZGUpO1xuXG4gICAgICAgIGpRdWVyeS5nZXRKU09OKHRoaXMuYWpheF91cmwsIGRhdGEsIChwaWNrdXBQb2ludHMpID0+IHtcbiAgICAgICAgICAgIGlmIChwaWNrdXBQb2ludHMubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIm5vIHBpY2t1cCBwb2ludHMgZm91bmQgZm9yIHRoaXMgYWRkcmVzcyBcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhwaWNrdXBQb2ludHMpO1xuICAgICAgICAgICAgaWYgKHBpY2t1cFBvaW50cy5FcnJvci5JZCA9PSAwICYmIHBpY2t1cFBvaW50cy5Qb2ludC5sZW5ndGggPiAwICkge1xuICAgICAgICAgICAgICAgIGpRdWVyeShcIi5zaGlwdGltaXplLXBpY2t1cF9fb3B0aW9ucywuc2hpcHRpbWl6ZS1waWNrdXBfX21hcFwiKS5zaG93KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRQaWNrdXBMb2NhdGlvbnMocGlja3VwUG9pbnRzLlBvaW50KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJUaGUgYXBpIHJldHVybmVkIGFuIGVycm9yIFwiLCBwaWNrdXBQb2ludHMuRXJyb3IpOyAvL3BpY2t1cFBvaW50cy5FcnJvci5JbmZvIHx8IFxuICAgICAgICAgICAgICAgIHRoaXMucGlja3VwRXJyb3Ioc2hpcHRpbWl6ZV9ub19wb2ludHNfZm91bmQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHJlc2V0VUkoKXtcbiAgICAgICAgalF1ZXJ5KFwiLnNoaXB0aW1pemUtcGlja3VwX19lcnJvclwiKS5oaWRlKCk7XG4gICAgICAgIHRoaXMubWFwLmNsZWFyTWFya2VycygpOyBcbiAgICB9XG5cbiAgICAvKiogXG4gICAgICogQHBhcmFtIHN0cmluZyBpbmZvIC0gdGhlIG1lc3NhZ2UgdG8gZGlzcGxheSBcbiAgICAgKi9cbiAgICBwaWNrdXBFcnJvcihpbmZvKSB7XG4gICAgICAgIHRoaXMucGlja3VwUG9pbnRzID0gW107IFxuXG4gICAgICAgIGxldCBlRXJyb3IgPSBqUXVlcnkoXCIuc2hpcHRpbWl6ZS1waWNrdXBfX2Vycm9yXCIpO1xuICAgICAgICBlRXJyb3IuaHRtbChpbmZvKTtcbiAgICAgICAgZUVycm9yLnNob3coKTtcblxuICAgICAgICBqUXVlcnkoXCIuc2hpcHRpbWl6ZS1waWNrdXBfX29wdGlvbnMsLnNoaXB0aW1pemUtcGlja3VwX19tYXBcIikuaGlkZSgpO1xuICAgIH1cblxuICAgIC8qKiBcbiAgICAgKiBBcHBlbmQgdGhlIHBpY2t1cCBMb2NhdGlvbnMgdG8gdGhlIG1hcFxuICAgICAqIEBwYXJhbSBhcnJheSBwaWNrdXBQb2ludHMgLSBhbiBhcnJheSBvZiBhdmFpbGFibGUgcGlja3VwIHBvaW50cyBcbiAgICAgKi9cbiAgICBzZXRQaWNrdXBMb2NhdGlvbnMocGlja3VwUG9pbnRzKSB7XG4gICAgICAgIGpRdWVyeShcIi5zaGlwdGltaXplLXBpY2t1cF9fZXJyb3JcIikuaGlkZSgpO1xuXG4gICAgICAgIHRoaXMucGlja3VwUG9pbnRzID0gcGlja3VwUG9pbnRzO1xuICAgICAgICB0aGlzLm1hcC5jbGVhck1hcmtlcnMoKTtcbiAgICAgICAgdGhpcy5tYXAuY2VudGVyTWFwKHRoaXMucGlja3VwUG9pbnRzWzBdLkxhdCwgdGhpcy5waWNrdXBQb2ludHNbMV0uTG9uZyk7XG4gICAgICAgIHRoaXMubWFwLmFkZE1hcmtlcnMocGlja3VwUG9pbnRzLCAoaWR4KSA9PiB7IHRoaXMuc2VsZWN0UG9pbnRGcm9tTGlzdEluTWFwKGlkeCk7IH0pO1xuICAgICAgICB0aGlzLnNldE9wdGlvbnNGb3JBZGRyZXNzKHBpY2t1cFBvaW50cyk7XG4gICAgfVxuXG4gICAgLyoqIFxuICAgICAqIEBwYXJhbSBwaWNrdXBQb2ludHNbXSAtIFtdIG9mIHBpY2t1cCBwb2ludHMgcmV0dXJuZWQgYnkgdGhlIGFwaSBcbiAgICAgKi9cbiAgICBzZXRPcHRpb25zRm9yQWRkcmVzcyhwaWNrdXBQb2ludHMpIHtcblxuICAgICAgICBsZXQgaHRtbCA9ICcnO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBpY2t1cFBvaW50cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgaHRtbCArPSAnPGRpdiBjbGFzcz1cInNoaXB0aW1pemUtcGlja3VwX19wb2ludFwiPicgK1xuICAgICAgICAgICAgICAgICc8aW5wdXQgdHlwZT1cInJhZGlvXCIgdmFsdWU9XCInICsgaSArICdcIiBuYW1lPVwic2hpcHRpbWl6ZV9fcG9pbnRcIiAgb25jbGljaz1cInNoaXB0aW1pemUuc2VsZWN0UG9pbnRGcm9tTGlzdEluTWFwKCcgKyBpICsgJylcIi8+JyArXG4gICAgICAgICAgICAgICAgJzxzcGFuIGNsYXNzPVwic2hpcHRpbWl6ZS1waWNrdXBfX3BvaW50X2Rlc2NyaXB0aW9uXCIgb25jbGljaz1cInNoaXB0aW1pemUuc2VsZWN0UG9pbnRGcm9tTGlzdEluTWFwKCcgKyBpICsgJylcIj4nICtcbiAgICAgICAgICAgICAgICAnPHNwYW4+JyArIChwaWNrdXBQb2ludHNbaV0uSW5mb3JtYXRpb24uTmFtZSA/IHBpY2t1cFBvaW50c1tpXS5JbmZvcm1hdGlvbi5OYW1lICsgJzxici8+JyA6ICcnKVxuICAgICAgICAgICAgICAgICArIHBpY2t1cFBvaW50c1tpXS5JbmZvcm1hdGlvbi5BZGRyZXNzICsgJzwvc3Bhbj4nICtcbiAgICAgICAgICAgICAgICB0aGlzLmdldEV4dGVuZGVkSW5mb0h0bWwocGlja3VwUG9pbnRzW2ldKSArXG4gICAgICAgICAgICAgICAgJzwvc3Bhbj4nXG5cbiAgICAgICAgICAgICAgICArXG4gICAgICAgICAgICAgICAgJzwvZGl2Pic7XG4gICAgICAgIH1cbiAgICAgICAgY29uc29sZS5sb2coaHRtbCk7XG5cbiAgICAgICAgalF1ZXJ5KFwiLnNoaXB0aW1pemUtcGlja3VwX19vdGhlclwiKS5odG1sKGh0bWwpO1xuICAgIH1cblxuXG4gICAgbG9hZE1hcCgpIHtcbiAgICAgICAgdGhpcy5tYXAubG9hZE1hcCgpO1xuICAgIH1cbn1cblxuaWYodHlwZW9mKGpRdWVyeSkgIT0gJ3VuZGVmaW5lZCcpe1xuICAgIGpRdWVyeShmdW5jdGlvbigpIHtcbiAgICAgICAgd2luZG93LnNoaXB0aW1pemUgPSBuZXcgU2hpcHRpbWl6ZShzaGlwdGltaXplX2FqYXhfcGlja3VwX3BvaW50cyk7XG4gICAgfSk7XG59Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///1\n")},function(module,exports,__webpack_require__){eval("// extracted by mini-css-extract-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zY3NzL3NoaXB0aW1pemUuc2Nzcz9lYzk3Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBIiwiZmlsZSI6IjIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///2\n")},function(module,exports,__webpack_require__){eval("// extracted by mini-css-extract-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9jc3MvbGVhZmxldC5jc3M/OTU1NSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSIsImZpbGUiOiIzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///3\n")},function(module,exports,__webpack_require__){"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nvar ShiptmizeMagento = function () {\n  function ShiptmizeMagento() {\n    _classCallCheck(this, ShiptmizeMagento);\n\n    this.bootstrap();\n    this.rate_carrier = {};\n    this.rate_requested = false;\n    this.pickupPoint = {};\n    this.currentMethod = null;\n  }\n\n  /**   \n   * If it\'s a multi step ajax checkout.. we don\'t try to understand  what convoluted logic the theme developers have going on, but just wait for the \n   * methods to be included \n   *\n   * Furthermore we are plugin into the footer to inject the map, but we can\'t guarantee it will be included in the outer body tag, so we need to do that after load. \n   * If there is a table rate present we need to ask the server if the selected method has pickup \n   */\n\n\n  _createClass(ShiptmizeMagento, [{\n    key: "bootstrap",\n    value: function bootstrap() {\n      var _this = this;\n\n      //Not ideal, but also not horrendous wait for the element to exist \n      if (jQuery("input[type=\'radio\']:checked").size() == 0) {\n        setTimeout(function () {\n          _this.bootstrap();\n        }, 500);\n        return;\n      }\n\n      this.addCheckoutButton();\n      jQuery("#maincontent").on(\'change\', "input[type=\'radio\']", function () {\n        _this.addCheckoutButton();\n      });\n\n      /**\n       * If the user clicks the row the method is changed \n       * but the change event is not triggered \n       */\n      jQuery("#maincontent").on(\'click\', "tr", function () {\n        _this.addCheckoutButton();\n      });\n\n      var map_wrapper = jQuery(".shiptimize-pickup");\n      jQuery("body").append(map_wrapper);\n    }\n\n    /** \n     * If the selected Shipping method allows the user to choose a pickup address we add a button \n     * We always refresh the address, because people can go back and change it and we have no way of knowing if that happened \n     * \n     * Layout options by order: \n     * if there is a label, insert after the label \n     * if there is a table, insert in the last td \n     * else insert after the selected radio \n     */\n\n  }, {\n    key: "addCheckoutButton",\n    value: function addCheckoutButton() {\n\n      var shippingMethod = this.getSelectedShipppingMethod();\n      if (this.currentMethod === shippingMethod) {\n        return;\n      }\n\n      this.currentMethod = shippingMethod;\n      this.pickupPoint = {};\n\n      if (!this.hasPickup(shippingMethod)) {\n        jQuery(".shiptimize-choose-pickup").remove();\n        return;\n      }\n\n      jQuery(".shiptimize-choose-pickup").remove();\n\n      /** \n       * This function is declared on our mage script\n       */\n      shiptimize_get_shipping_address();\n\n      var eSelectedMethod = jQuery(jQuery("input[type=\'radio\']:checked").get(0));\n      var parentRow = eSelectedMethod.parents("tr");\n\n      var eLabel = eSelectedMethod.siblings(\'label\');\n\n      var eShiptimizeButton = jQuery("<span class=\'shiptimize-choose-pickup\' >" + "<button class=\'button\' type=\'button\' onClick=\'shiptimize.getPickupLocations()\'>" + shiptmize_choose + \'</button>\' + "<span class=\'shiptimize-pickup__description\'></span>" + "</span>");\n\n      if (eLabel.size() > 0) {\n        eShiptimizeButton.insertAfter(eLabel);\n      } else if (parentRow.size() > 0) {\n        var tds = parentRow.children("td");\n        jQuery(tds.get(tds.size() - 1)).append(eShiptimizeButton);\n      } else {\n        eShiptimizeButton.insertAfter(eSelectedMethod);\n      }\n    }\n\n    /**\n     * \n     */\n\n  }, {\n    key: "hasPickup",\n    value: function hasPickup(mage_id) {\n      /** \n       * Shiptimize table rates adds sufix pickup if method provides pickup points \n       */\n      if (mage_id.match(/([\\d]+)_pickup/) != null) {\n        return true;\n      }\n\n      for (var x = 0; x < shiptimize_carriers.length; ++x) {\n        if (shiptimize_carriers[x].ClassName === mage_id && shiptimize_carriers[x].HasPickup) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n\n    /** \n     * @return the id of the shiptimize carrier associated with this method \n     */\n\n  }, {\n    key: "getShiptimizeId",\n    value: function getShiptimizeId(mage_id) {\n      var carrier_id = mage_id.match(/([\\d]+)_pickup/);\n      if (carrier_id != null) {\n        return carrier_id[1];\n      }\n\n      for (var x = 0; x < shiptimize_carriers.length; ++x) {\n        if (shiptimize_carriers[x].ClassName === mage_id) {\n          return _typeof(shiptimize_carriers[x].Id) == \'object\' ? shiptimize_carriers[x].Id[\'0\'] : shiptimize_carriers[x].Id;\n        }\n      }\n\n      return 0;\n    }\n  }, {\n    key: "getSelectedShipppingMethod",\n    value: function getSelectedShipppingMethod() {\n      var eSelectedMethod = jQuery("input[type=\'radio\']:checked");\n\n      if (eSelectedMethod.size() == 0) {\n        return \'\';\n      }\n\n      var method = eSelectedMethod.val();\n      /** \n       * Mage repeats the method name \n       */\n      var parts = method.split(\'_\');\n      return parts.length > 1 && parts[0] == parts[1] ? parts[0] : method;\n    }\n\n    /** \n     * We only include this script on checkout, so it\'s always true\n     */\n\n  }, {\n    key: "isCheckout",\n    value: function isCheckout() {\n      return true;\n    }\n\n    /** \n     * Returns the shipping data as an object in the same format that the api receives \n     * We get the address parts server side here \n     */\n\n  }, {\n    key: "getShippingData",\n    value: function getShippingData() {\n      return {\n        "Address": {\n          "Lat": "",\n          "Long": "",\n          \'Streetname1\': shiptimize_address.Streetname1,\n          \'Streetname2\': shiptimize_address.Streetname2,\n          \'HouseNumber\': \'\',\n          \'NumberExtension\': \'\',\n          \'PostalCode\': shiptimize_address.PostalCode,\n          \'City\': shiptimize_address.City,\n          \'Country\': shiptimize_address.Country,\n          "State": shiptimize_address.State\n        },\n        "CarrierId": this.getShiptimizeId(this.getSelectedShipppingMethod()) //in prestashop we can get this server side \n      };\n    }\n\n    /** \n     * @param Pickup pickup - a pickupPoint as received from the api \n     */\n\n  }, {\n    key: "setPickupPoint",\n    value: function setPickupPoint(pickup) {\n      this.pickupPoint = pickup;\n\n      var label = pickup.Information.Name ? pickup.Information.Name : pickup.Information.Address + " " + pickup.Information.ZipCode;\n\n      var data = {\n        \'PointId\': pickup.PointId,\n        \'Label\': label,\n        \'Extendedinfo\': pickup.Extendedinfo\n      };\n      console.log(data);\n      jQuery.getJSON(shiptimize_ajax_save_pickup, data, function (resp) {\n        console.log(resp);\n      });\n    }\n  }]);\n\n  return ShiptmizeMagento;\n}();\n\nexports.default = ShiptmizeMagento;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9qcy9zaGlwdGltaXplLW1hZ2VudG8uanM/YzBjZiJdLCJuYW1lcyI6WyJTaGlwdG1pemVNYWdlbnRvIiwiYm9vdHN0cmFwIiwicmF0ZV9jYXJyaWVyIiwicmF0ZV9yZXF1ZXN0ZWQiLCJwaWNrdXBQb2ludCIsImN1cnJlbnRNZXRob2QiLCJqUXVlcnkiLCJzaXplIiwic2V0VGltZW91dCIsImFkZENoZWNrb3V0QnV0dG9uIiwib24iLCJtYXBfd3JhcHBlciIsImFwcGVuZCIsInNoaXBwaW5nTWV0aG9kIiwiZ2V0U2VsZWN0ZWRTaGlwcHBpbmdNZXRob2QiLCJoYXNQaWNrdXAiLCJyZW1vdmUiLCJzaGlwdGltaXplX2dldF9zaGlwcGluZ19hZGRyZXNzIiwiZVNlbGVjdGVkTWV0aG9kIiwiZ2V0IiwicGFyZW50Um93IiwicGFyZW50cyIsImVMYWJlbCIsInNpYmxpbmdzIiwiZVNoaXB0aW1pemVCdXR0b24iLCJzaGlwdG1pemVfY2hvb3NlIiwiaW5zZXJ0QWZ0ZXIiLCJ0ZHMiLCJjaGlsZHJlbiIsIm1hZ2VfaWQiLCJtYXRjaCIsIngiLCJzaGlwdGltaXplX2NhcnJpZXJzIiwibGVuZ3RoIiwiQ2xhc3NOYW1lIiwiSGFzUGlja3VwIiwiY2Fycmllcl9pZCIsIklkIiwibWV0aG9kIiwidmFsIiwicGFydHMiLCJzcGxpdCIsInNoaXB0aW1pemVfYWRkcmVzcyIsIlN0cmVldG5hbWUxIiwiU3RyZWV0bmFtZTIiLCJQb3N0YWxDb2RlIiwiQ2l0eSIsIkNvdW50cnkiLCJTdGF0ZSIsImdldFNoaXB0aW1pemVJZCIsInBpY2t1cCIsImxhYmVsIiwiSW5mb3JtYXRpb24iLCJOYW1lIiwiQWRkcmVzcyIsIlppcENvZGUiLCJkYXRhIiwiUG9pbnRJZCIsIkV4dGVuZGVkaW5mbyIsImNvbnNvbGUiLCJsb2ciLCJnZXRKU09OIiwic2hpcHRpbWl6ZV9hamF4X3NhdmVfcGlja3VwIiwicmVzcCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0lBQXFC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LFdBSnpCO0FBS1QseUJBQWUsRUFMTjtBQU1ULDZCQUFtQixFQU5WO0FBT1Qsd0JBQWNGLG1CQUFtQkcsVUFQeEI7QUFRVCxrQkFBUUgsbUJBQW1CSSxJQVJsQjtBQVNULHFCQUFXSixtQkFBbUJLLE9BVHJCO0FBVVQsbUJBQVNMLG1CQUFtQk07QUFWbkIsU0FETjtBQWFMLHFCQUFhLEtBQUtDLGVBQUwsQ0FBcUIsS0FBS25DLDBCQUFMLEVBQXJCLENBYlIsQ0FhaUU7QUFiakUsT0FBUDtBQWVEOztBQUVEOzs7Ozs7bUNBR2VvQyxNLEVBQVE7QUFDckIsV0FBSzlDLFdBQUwsR0FBbUI4QyxNQUFuQjs7QUFFQSxVQUFJQyxRQUFRRCxPQUFPRSxXQUFQLENBQW1CQyxJQUFuQixHQUEwQkgsT0FBT0UsV0FBUCxDQUFtQkMsSUFBN0MsR0FBcURILE9BQU9FLFdBQVAsQ0FBbUJFLE9BQW5CLEdBQTZCLEdBQTdCLEdBQW1DSixPQUFPRSxXQUFQLENBQW1CRyxPQUF2SDs7QUFFQSxVQUFJQyxPQUFPO0FBQ1QsbUJBQVdOLE9BQU9PLE9BRFQ7QUFFVCxpQkFBU04sS0FGQTtBQUdULHdCQUFnQkQsT0FBT1E7QUFIZCxPQUFYO0FBS0FDLGNBQVFDLEdBQVIsQ0FBWUosSUFBWjtBQUNBbEQsYUFBT3VELE9BQVAsQ0FBZUMsMkJBQWYsRUFBNENOLElBQTVDLEVBQWtELFVBQUNPLElBQUQsRUFBVTtBQUMxREosZ0JBQVFDLEdBQVIsQ0FBWUcsSUFBWjtBQUNELE9BRkQ7QUFHRDs7Ozs7O2tCQTVNa0IvRCxnQiIsImZpbGUiOiI0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2hpcHRtaXplTWFnZW50byB7XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5ib290c3RyYXAoKTtcbiAgICB0aGlzLnJhdGVfY2FycmllciA9IHt9O1xuICAgIHRoaXMucmF0ZV9yZXF1ZXN0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLnBpY2t1cFBvaW50ID0ge307XG4gICAgdGhpcy5jdXJyZW50TWV0aG9kID0gbnVsbDtcbiAgfVxuXG5cbiAgLyoqICAgXG4gICAqIElmIGl0J3MgYSBtdWx0aSBzdGVwIGFqYXggY2hlY2tvdXQuLiB3ZSBkb24ndCB0cnkgdG8gdW5kZXJzdGFuZCAgd2hhdCBjb252b2x1dGVkIGxvZ2ljIHRoZSB0aGVtZSBkZXZlbG9wZXJzIGhhdmUgZ29pbmcgb24sIGJ1dCBqdXN0IHdhaXQgZm9yIHRoZSBcbiAgICogbWV0aG9kcyB0byBiZSBpbmNsdWRlZCBcbiAgICpcbiAgICogRnVydGhlcm1vcmUgd2UgYXJlIHBsdWdpbiBpbnRvIHRoZSBmb290ZXIgdG8gaW5qZWN0IHRoZSBtYXAsIGJ1dCB3ZSBjYW4ndCBndWFyYW50ZWUgaXQgd2lsbCBiZSBpbmNsdWRlZCBpbiB0aGUgb3V0ZXIgYm9keSB0YWcsIHNvIHdlIG5lZWQgdG8gZG8gdGhhdCBhZnRlciBsb2FkLiBcbiAgICogSWYgdGhlcmUgaXMgYSB0YWJsZSByYXRlIHByZXNlbnQgd2UgbmVlZCB0byBhc2sgdGhlIHNlcnZlciBpZiB0aGUgc2VsZWN0ZWQgbWV0aG9kIGhhcyBwaWNrdXAgXG4gICAqL1xuICBib290c3RyYXAoKSB7XG4gICAgLy9Ob3QgaWRlYWwsIGJ1dCBhbHNvIG5vdCBob3JyZW5kb3VzIHdhaXQgZm9yIHRoZSBlbGVtZW50IHRvIGV4aXN0IFxuICAgIGlmIChqUXVlcnkoXCJpbnB1dFt0eXBlPSdyYWRpbyddOmNoZWNrZWRcIilcbiAgICAgIC5zaXplKCkgPT0gMCkge1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRoaXMuYm9vdHN0cmFwKCk7XG4gICAgICB9LCA1MDApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuYWRkQ2hlY2tvdXRCdXR0b24oKTtcbiAgICBqUXVlcnkoXCIjbWFpbmNvbnRlbnRcIilcbiAgICAgIC5vbignY2hhbmdlJywgXCJpbnB1dFt0eXBlPSdyYWRpbyddXCIsICgpID0+IHtcbiAgICAgICAgdGhpcy5hZGRDaGVja291dEJ1dHRvbigpO1xuICAgICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBJZiB0aGUgdXNlciBjbGlja3MgdGhlIHJvdyB0aGUgbWV0aG9kIGlzIGNoYW5nZWQgXG4gICAgICogYnV0IHRoZSBjaGFuZ2UgZXZlbnQgaXMgbm90IHRyaWdnZXJlZCBcbiAgICAgKi9cbiAgICBqUXVlcnkoXCIjbWFpbmNvbnRlbnRcIilcbiAgICAgIC5vbignY2xpY2snLCBcInRyXCIsICgpID0+IHtcbiAgICAgICAgdGhpcy5hZGRDaGVja291dEJ1dHRvbigpO1xuICAgICAgfSk7XG5cbiAgICBsZXQgbWFwX3dyYXBwZXIgPSBqUXVlcnkoXCIuc2hpcHRpbWl6ZS1waWNrdXBcIik7XG4gICAgalF1ZXJ5KFwiYm9keVwiKVxuICAgICAgLmFwcGVuZChtYXBfd3JhcHBlcik7XG5cbiAgfVxuXG4gIC8qKiBcbiAgICogSWYgdGhlIHNlbGVjdGVkIFNoaXBwaW5nIG1ldGhvZCBhbGxvd3MgdGhlIHVzZXIgdG8gY2hvb3NlIGEgcGlja3VwIGFkZHJlc3Mgd2UgYWRkIGEgYnV0dG9uIFxuICAgKiBXZSBhbHdheXMgcmVmcmVzaCB0aGUgYWRkcmVzcywgYmVjYXVzZSBwZW9wbGUgY2FuIGdvIGJhY2sgYW5kIGNoYW5nZSBpdCBhbmQgd2UgaGF2ZSBubyB3YXkgb2Yga25vd2luZyBpZiB0aGF0IGhhcHBlbmVkIFxuICAgKiBcbiAgICogTGF5b3V0IG9wdGlvbnMgYnkgb3JkZXI6IFxuICAgKiBpZiB0aGVyZSBpcyBhIGxhYmVsLCBpbnNlcnQgYWZ0ZXIgdGhlIGxhYmVsIFxuICAgKiBpZiB0aGVyZSBpcyBhIHRhYmxlLCBpbnNlcnQgaW4gdGhlIGxhc3QgdGQgXG4gICAqIGVsc2UgaW5zZXJ0IGFmdGVyIHRoZSBzZWxlY3RlZCByYWRpbyBcbiAgICovXG4gIGFkZENoZWNrb3V0QnV0dG9uKCkge1xuXG4gICAgY29uc3Qgc2hpcHBpbmdNZXRob2QgPSB0aGlzLmdldFNlbGVjdGVkU2hpcHBwaW5nTWV0aG9kKCk7XG4gICAgaWYgKHRoaXMuY3VycmVudE1ldGhvZCA9PT0gc2hpcHBpbmdNZXRob2QpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmN1cnJlbnRNZXRob2QgPSBzaGlwcGluZ01ldGhvZDtcbiAgICB0aGlzLnBpY2t1cFBvaW50ID0ge307XG4gICAgXG4gICAgaWYgKCF0aGlzLmhhc1BpY2t1cChzaGlwcGluZ01ldGhvZCkpIHtcbiAgICAgIGpRdWVyeShcIi5zaGlwdGltaXplLWNob29zZS1waWNrdXBcIilcbiAgICAgICAgLnJlbW92ZSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGpRdWVyeShcIi5zaGlwdGltaXplLWNob29zZS1waWNrdXBcIilcbiAgICAgIC5yZW1vdmUoKTtcblxuICAgIC8qKiBcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGRlY2xhcmVkIG9uIG91ciBtYWdlIHNjcmlwdFxuICAgICAqL1xuICAgIHNoaXB0aW1pemVfZ2V0X3NoaXBwaW5nX2FkZHJlc3MoKTtcblxuICAgIGxldCBlU2VsZWN0ZWRNZXRob2QgPSBqUXVlcnkoalF1ZXJ5KFwiaW5wdXRbdHlwZT0ncmFkaW8nXTpjaGVja2VkXCIpXG4gICAgICAuZ2V0KDApKTtcbiAgICBsZXQgcGFyZW50Um93ID0gZVNlbGVjdGVkTWV0aG9kLnBhcmVudHMoXCJ0clwiKTtcblxuICAgIGxldCBlTGFiZWwgPSBlU2VsZWN0ZWRNZXRob2Quc2libGluZ3MoJ2xhYmVsJyk7XG5cbiAgICBsZXQgZVNoaXB0aW1pemVCdXR0b24gPSBqUXVlcnkoXCI8c3BhbiBjbGFzcz0nc2hpcHRpbWl6ZS1jaG9vc2UtcGlja3VwJyA+XCIgK1xuICAgICAgXCI8YnV0dG9uIGNsYXNzPSdidXR0b24nIHR5cGU9J2J1dHRvbicgb25DbGljaz0nc2hpcHRpbWl6ZS5nZXRQaWNrdXBMb2NhdGlvbnMoKSc+XCIgKyBzaGlwdG1pemVfY2hvb3NlICsgJzwvYnV0dG9uPicgK1xuICAgICAgXCI8c3BhbiBjbGFzcz0nc2hpcHRpbWl6ZS1waWNrdXBfX2Rlc2NyaXB0aW9uJz48L3NwYW4+XCIgK1xuICAgICAgXCI8L3NwYW4+XCIpO1xuXG4gICAgaWYgKGVMYWJlbC5zaXplKCkgPiAwKSB7XG4gICAgICBlU2hpcHRpbWl6ZUJ1dHRvbi5pbnNlcnRBZnRlcihlTGFiZWwpO1xuICAgIH0gZWxzZSBpZiAocGFyZW50Um93LnNpemUoKSA+IDApIHtcbiAgICAgIGxldCB0ZHMgPSBwYXJlbnRSb3cuY2hpbGRyZW4oXCJ0ZFwiKTtcbiAgICAgIGpRdWVyeSh0ZHMuZ2V0KHRkcy5zaXplKCkgLSAxKSlcbiAgICAgICAgLmFwcGVuZChlU2hpcHRpbWl6ZUJ1dHRvbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVTaGlwdGltaXplQnV0dG9uLmluc2VydEFmdGVyKGVTZWxlY3RlZE1ldGhvZCk7XG4gICAgfVxuXG4gIH1cblxuICAvKipcbiAgICogXG4gICAqL1xuICBoYXNQaWNrdXAobWFnZV9pZCkge1xuICAgIC8qKiBcbiAgICAgKiBTaGlwdGltaXplIHRhYmxlIHJhdGVzIGFkZHMgc3VmaXggcGlja3VwIGlmIG1ldGhvZCBwcm92aWRlcyBwaWNrdXAgcG9pbnRzIFxuICAgICAqL1xuICAgIGlmIChtYWdlX2lkLm1hdGNoKC8oW1xcZF0rKV9waWNrdXAvKSAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBmb3IgKGxldCB4ID0gMDsgeCA8IHNoaXB0aW1pemVfY2FycmllcnMubGVuZ3RoOyArK3gpIHtcbiAgICAgIGlmIChzaGlwdGltaXplX2NhcnJpZXJzW3hdLkNsYXNzTmFtZSA9PT0gbWFnZV9pZCAmJiBzaGlwdGltaXplX2NhcnJpZXJzW3hdLkhhc1BpY2t1cCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKiogXG4gICAqIEByZXR1cm4gdGhlIGlkIG9mIHRoZSBzaGlwdGltaXplIGNhcnJpZXIgYXNzb2NpYXRlZCB3aXRoIHRoaXMgbWV0aG9kIFxuICAgKi9cbiAgZ2V0U2hpcHRpbWl6ZUlkKG1hZ2VfaWQpIHtcbiAgICB2YXIgY2Fycmllcl9pZCA9IG1hZ2VfaWQubWF0Y2goLyhbXFxkXSspX3BpY2t1cC8pO1xuICAgIGlmIChjYXJyaWVyX2lkICE9IG51bGwpIHtcbiAgICAgIHJldHVybiBjYXJyaWVyX2lkWzFdO1xuICAgIH1cblxuICAgIGZvciAobGV0IHggPSAwOyB4IDwgc2hpcHRpbWl6ZV9jYXJyaWVycy5sZW5ndGg7ICsreCkge1xuICAgICAgaWYgKHNoaXB0aW1pemVfY2FycmllcnNbeF0uQ2xhc3NOYW1lID09PSBtYWdlX2lkKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgKHNoaXB0aW1pemVfY2FycmllcnNbeF0uSWQpID09ICdvYmplY3QnID8gc2hpcHRpbWl6ZV9jYXJyaWVyc1t4XS5JZFsnMCddIDogc2hpcHRpbWl6ZV9jYXJyaWVyc1t4XS5JZDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIGdldFNlbGVjdGVkU2hpcHBwaW5nTWV0aG9kKCkge1xuICAgIGNvbnN0IGVTZWxlY3RlZE1ldGhvZCA9IGpRdWVyeShcImlucHV0W3R5cGU9J3JhZGlvJ106Y2hlY2tlZFwiKTtcblxuICAgIGlmIChlU2VsZWN0ZWRNZXRob2Quc2l6ZSgpID09IDApIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG5cbiAgICB2YXIgbWV0aG9kID0gZVNlbGVjdGVkTWV0aG9kLnZhbCgpO1xuICAgIC8qKiBcbiAgICAgKiBNYWdlIHJlcGVhdHMgdGhlIG1ldGhvZCBuYW1lIFxuICAgICAqL1xuICAgIHZhciBwYXJ0cyA9IG1ldGhvZC5zcGxpdCgnXycpO1xuICAgIHJldHVybiBwYXJ0cy5sZW5ndGggPiAxICYmIHBhcnRzWzBdID09IHBhcnRzWzFdID8gcGFydHNbMF0gOiBtZXRob2Q7XG4gIH1cblxuICAvKiogXG4gICAqIFdlIG9ubHkgaW5jbHVkZSB0aGlzIHNjcmlwdCBvbiBjaGVja291dCwgc28gaXQncyBhbHdheXMgdHJ1ZVxuICAgKi9cbiAgaXNDaGVja291dCgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKiBcbiAgICogUmV0dXJucyB0aGUgc2hpcHBpbmcgZGF0YSBhcyBhbiBvYmplY3QgaW4gdGhlIHNhbWUgZm9ybWF0IHRoYXQgdGhlIGFwaSByZWNlaXZlcyBcbiAgICogV2UgZ2V0IHRoZSBhZGRyZXNzIHBhcnRzIHNlcnZlciBzaWRlIGhlcmUgXG4gICAqL1xuICBnZXRTaGlwcGluZ0RhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIFwiQWRkcmVzc1wiOiB7XG4gICAgICAgIFwiTGF0XCI6IFwiXCIsXG4gICAgICAgIFwiTG9uZ1wiOiBcIlwiLFxuICAgICAgICAnU3RyZWV0bmFtZTEnOiBzaGlwdGltaXplX2FkZHJlc3MuU3RyZWV0bmFtZTEsXG4gICAgICAgICdTdHJlZXRuYW1lMic6IHNoaXB0aW1pemVfYWRkcmVzcy5TdHJlZXRuYW1lMixcbiAgICAgICAgJ0hvdXNlTnVtYmVyJzogJycsXG4gICAgICAgICdOdW1iZXJFeHRlbnNpb24nOiAnJyxcbiAgICAgICAgJ1Bvc3RhbENvZGUnOiBzaGlwdGltaXplX2FkZHJlc3MuUG9zdGFsQ29kZSxcbiAgICAgICAgJ0NpdHknOiBzaGlwdGltaXplX2FkZHJlc3MuQ2l0eSxcbiAgICAgICAgJ0NvdW50cnknOiBzaGlwdGltaXplX2FkZHJlc3MuQ291bnRyeSxcbiAgICAgICAgXCJTdGF0ZVwiOiBzaGlwdGltaXplX2FkZHJlc3MuU3RhdGUsXG4gICAgICB9LFxuICAgICAgXCJDYXJyaWVySWRcIjogdGhpcy5nZXRTaGlwdGltaXplSWQodGhpcy5nZXRTZWxlY3RlZFNoaXBwcGluZ01ldGhvZCgpKSwgLy9pbiBwcmVzdGFzaG9wIHdlIGNhbiBnZXQgdGhpcyBzZXJ2ZXIgc2lkZSBcbiAgICB9O1xuICB9XG5cbiAgLyoqIFxuICAgKiBAcGFyYW0gUGlja3VwIHBpY2t1cCAtIGEgcGlja3VwUG9pbnQgYXMgcmVjZWl2ZWQgZnJvbSB0aGUgYXBpIFxuICAgKi9cbiAgc2V0UGlja3VwUG9pbnQocGlja3VwKSB7XG4gICAgdGhpcy5waWNrdXBQb2ludCA9IHBpY2t1cDtcblxuICAgIGxldCBsYWJlbCA9IHBpY2t1cC5JbmZvcm1hdGlvbi5OYW1lID8gcGlja3VwLkluZm9ybWF0aW9uLk5hbWUgOiAocGlja3VwLkluZm9ybWF0aW9uLkFkZHJlc3MgKyBcIiBcIiArIHBpY2t1cC5JbmZvcm1hdGlvbi5aaXBDb2RlKTtcblxuICAgIGxldCBkYXRhID0ge1xuICAgICAgJ1BvaW50SWQnOiBwaWNrdXAuUG9pbnRJZCxcbiAgICAgICdMYWJlbCc6IGxhYmVsLFxuICAgICAgJ0V4dGVuZGVkaW5mbyc6IHBpY2t1cC5FeHRlbmRlZGluZm9cbiAgICB9O1xuICAgIGNvbnNvbGUubG9nKGRhdGEpO1xuICAgIGpRdWVyeS5nZXRKU09OKHNoaXB0aW1pemVfYWpheF9zYXZlX3BpY2t1cCwgZGF0YSwgKHJlc3ApID0+IHtcbiAgICAgIGNvbnNvbGUubG9nKHJlc3ApO1xuICAgIH0pO1xuICB9XG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///4\n')},function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _shiptimizeUtils = __webpack_require__(0);\n\nvar _shiptimizeUtils2 = _interopRequireDefault(_shiptimizeUtils);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar ShiptimizeGmaps = function () {\n    function ShiptimizeGmaps(key) {\n        _classCallCheck(this, ShiptimizeGmaps);\n\n        this.isScriptLoaded = false;\n        this.markers = [];\n        this.map = null;\n        this.pickupPoints = [];\n        this.key = key;\n\n        /** \n         * the root url for the icons it's different for every platform  \n         * make sure to include a trailing / \n         */\n        this.icon_folder = shiptimize_icon_folder;\n        this.icon_selected = shiptimize_icon_folder + 'selected.png';\n        this.icon_default = shiptimize_icon_folder + 'default.png';\n        this.current_icon = this.icon_default;\n    }\n\n    /** \n     * Checks if we have an icon for this carrier.\n     * If yes then change the carrier icon\n     * If not then use the default icon\n     * \n     * @param int carrier_id - the carrier id \n     */\n\n\n    _createClass(ShiptimizeGmaps, [{\n        key: 'setCarrierIcon',\n        value: function setCarrierIcon(carrier_id) {\n            var carrier_icon_url = this.icon_folder + '' + carrier_id + '.png';\n            this.current_icon = _shiptimizeUtils2.default.isUrlValid(carrier_icon_url) ? carrier_icon_url : this.icon_default;\n        }\n\n        /** \n         * if the script has not been loaded , load it \n         */\n\n    }, {\n        key: 'grantReady',\n        value: function grantReady() {\n            if (!this.isScriptLoaded) {\n                this.loadScript();\n            }\n        }\n    }, {\n        key: 'loadScript',\n        value: function loadScript() {\n            if (typeof google == 'undefined' || typeof google.maps == 'undefined') {\n                _shiptimizeUtils2.default.injectExternalScript(\"https://maps.googleapis.com/maps/api/js?key=\" + this.key + \"&callback=shiptimize.loadMap\");\n            }\n            this.isScriptLoaded = true;\n        }\n\n        /** \n         * Load the map into the element \n         * This function needs the script to be loaded \n         */\n\n    }, {\n        key: 'loadMap',\n        value: function loadMap() {\n            console.log(\"displaying map on container with \" + jQuery(\".shiptimize-pickup__map\").width() + \" \" + jQuery(\".shiptimize-pickup__map\").height(), jQuery(\".shiptimize-pickup__map\").get(0));\n            this.map = new google.maps.Map(jQuery(\".shiptimize-pickup__map\").get(0), {\n                center: { lat: -34.397, lng: 150.644 },\n                zoom: 16,\n                mapTypeControl: false\n            });\n        }\n\n        /** \n         * center the map \n         */\n\n    }, {\n        key: 'centerMap',\n        value: function centerMap(lat, lng) {\n            this.map.setCenter(new google.maps.LatLng(lat, lng));\n        }\n\n        /** \n         * Extract the country code from a geocode result\n         * @param geocode - a google.maps.Geocoder result \n         * @return string alpha-2 code for the country name \n         */\n\n    }, {\n        key: 'getCountryCodeFromResult',\n        value: function getCountryCodeFromResult(geocode) {\n            if (typeof geocode.address_components == \"undefined\") {\n                return \"\";\n            }\n\n            var components = geocode.address_components;\n            for (var i = 0; i < components.length; ++i) {\n                var types = components[i].types;\n\n                for (var j = 0; j < types.length; ++j) {\n                    if (types[j] == 'country') {\n                        return components[i].short_name;\n                    }\n                }\n            }\n        }\n\n        /**\n         *  \n         * @param shippingData, the address parts       \n         * @param f_callback , the function to call when all mighty google returns a result \n         */\n\n    }, {\n        key: 'geocode',\n        value: function geocode(shippingData, f_callback) {\n            var _this = this;\n\n            if (typeof google == 'undefined') {\n                //script not loaded yet\n                setTimeout(function () {\n                    _this.geocode(shippingData, f_callback);\n                }, 200);\n                return;\n            }\n\n            var geocoder = new google.maps.Geocoder();\n            var me = this;\n\n            var address = shippingData.Address.Streetname1 + \" \" + shippingData.Address.Streetname2 + \" \" + shippingData.Address.postalCode + \" \" + shippingData.Address.City + \" \" + shippingData.Address.State + \" \" + shippingData.Address.Country;\n            console.log('geocoding ' + address);\n\n            geocoder.geocode({ 'address': address }, function (results, status) {\n                var geocode = { iso2: '', lat: '', lng: '' };\n\n                if (status == 'OK') {\n                    geocode = results[0];\n                } else {\n                    console.log('Geocode was not successful for the following reason: ' + status);\n                    f_callback(geocode);\n                    return;\n                }\n\n                var latlng = geocode.geometry.location;\n\n                geocode.iso2 = me.getCountryCodeFromResult(geocode);\n                geocode.lat = latlng.lat();\n                geocode.lng = latlng.lng();\n\n                f_callback(geocode);\n            });\n        }\n    }, {\n        key: 'clearMarkers',\n        value: function clearMarkers() {\n            if (this.markers.length > 0) {\n                for (var i = 0; i < this.markers.length; ++i) {\n                    this.markers[i].setMap(null);\n                }\n\n                this.markers = [];\n            }\n        }\n\n        /** \n         * Add the markers to map \n         * @param array pickupPoints - an array of pickupPoints\n         * @param callback - a function to call when the marker is clicked \n         */\n\n    }, {\n        key: 'addMarkers',\n        value: function addMarkers(pickupPoints, callback) {\n            var _this2 = this;\n\n            this.pickupPoints = pickupPoints;\n\n            var _loop = function _loop(x) {\n                _this2.markers[x] = _this2.getMarker(pickupPoints[x]);\n                //    we need to do this because the values for lat,lng we have are rounded, so they will not match the ones returned by google\n                pickupPoints[x].marker = _this2.markers[x];\n\n                _this2.markers[x].addListener('click', function () {\n                    if (typeof callback != 'undefined') {\n                        callback(x);\n                    }\n                });\n            };\n\n            for (var x = 0; x < pickupPoints.length; ++x) {\n                _loop(x);\n            }\n\n            this.fitBounds();\n        }\n\n        /** \n         * Return a marker for the gmaps \n         */\n\n    }, {\n        key: 'getMarker',\n        value: function getMarker(pickupPoint, callback) {\n            var marker = new google.maps.Marker({\n                position: new google.maps.LatLng(pickupPoint.Lat, pickupPoint.Long),\n                map: this.map,\n                icon: {\n                    url: this.current_icon\n                }\n            });\n\n            return marker;\n        }\n    }, {\n        key: 'fitBounds',\n        value: function fitBounds() {\n            var bounds = new google.maps.LatLngBounds();\n            for (var x = 0; x < this.markers.length; ++x) {\n                bounds.extend(this.markers[x].getPosition());\n            }\n            this.map.fitBounds(bounds);\n        }\n\n        /**\n         * Reset all markers  \n         * Select the marker of index idx in map \n         * @param int idx - the index to select \n         */\n\n    }, {\n        key: 'selectMarkerByIdx',\n        value: function selectMarkerByIdx(idx) {\n            for (var i = 0; i < this.markers.length; ++i) {\n                this.markers[i].setIcon(idx == i ? this.icon_selected : this.current_icon);\n            }\n        }\n    }]);\n\n    return ShiptimizeGmaps;\n}();\n\nexports.default = ShiptimizeGmaps;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9qcy9zaGlwdGltaXplLWdtYXBzLmpzPzBiZjEiXSwibmFtZXMiOlsiU2hpcHRpbWl6ZUdtYXBzIiwia2V5IiwiaXNTY3JpcHRMb2FkZWQiLCJtYXJrZXJzIiwibWFwIiwicGlja3VwUG9pbnRzIiwiaWNvbl9mb2xkZXIiLCJzaGlwdGltaXplX2ljb25fZm9sZGVyIiwiaWNvbl9zZWxlY3RlZCIsImljb25fZGVmYXVsdCIsImN1cnJlbnRfaWNvbiIsImNhcnJpZXJfaWQiLCJjYXJyaWVyX2ljb25fdXJsIiwiVXRpbHMiLCJpc1VybFZhbGlkIiwibG9hZFNjcmlwdCIsImdvb2dsZSIsIm1hcHMiLCJpbmplY3RFeHRlcm5hbFNjcmlwdCIsImNvbnNvbGUiLCJsb2ciLCJqUXVlcnkiLCJ3aWR0aCIsImhlaWdodCIsImdldCIsIk1hcCIsImNlbnRlciIsImxhdCIsImxuZyIsInpvb20iLCJtYXBUeXBlQ29udHJvbCIsInNldENlbnRlciIsIkxhdExuZyIsImdlb2NvZGUiLCJhZGRyZXNzX2NvbXBvbmVudHMiLCJjb21wb25lbnRzIiwiaSIsImxlbmd0aCIsInR5cGVzIiwiaiIsInNob3J0X25hbWUiLCJzaGlwcGluZ0RhdGEiLCJmX2NhbGxiYWNrIiwic2V0VGltZW91dCIsImdlb2NvZGVyIiwiR2VvY29kZXIiLCJtZSIsImFkZHJlc3MiLCJBZGRyZXNzIiwiU3RyZWV0bmFtZTEiLCJTdHJlZXRuYW1lMiIsInBvc3RhbENvZGUiLCJDaXR5IiwiU3RhdGUiLCJDb3VudHJ5IiwicmVzdWx0cyIsInN0YXR1cyIsImlzbzIiLCJsYXRsbmciLCJnZW9tZXRyeSIsImxvY2F0aW9uIiwiZ2V0Q291bnRyeUNvZGVGcm9tUmVzdWx0Iiwic2V0TWFwIiwiY2FsbGJhY2siLCJ4IiwiZ2V0TWFya2VyIiwibWFya2VyIiwiYWRkTGlzdGVuZXIiLCJmaXRCb3VuZHMiLCJwaWNrdXBQb2ludCIsIk1hcmtlciIsInBvc2l0aW9uIiwiTGF0IiwiTG9uZyIsImljb24iLCJ1cmwiLCJib3VuZHMiLCJMYXRMbmdCb3VuZHMiLCJleHRlbmQiLCJnZXRQb3NpdGlvbiIsImlkeCIsInNldEljb24iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7Ozs7Ozs7O0lBRXFCQSxlO0FBRWpCLDZCQUFZQyxHQUFaLEVBQWlCO0FBQUE7O0FBQ2IsYUFBS0MsY0FBTCxHQUFzQixLQUF0QjtBQUNBLGFBQUtDLE9BQUwsR0FBZSxFQUFmO0FBQ0EsYUFBS0MsR0FBTCxHQUFXLElBQVg7QUFDQSxhQUFLQyxZQUFMLEdBQW9CLEVBQXBCO0FBQ0EsYUFBS0osR0FBTCxHQUFXQSxHQUFYOztBQUVBOzs7O0FBSUEsYUFBS0ssV0FBTCxHQUFtQkMsc0JBQW5CO0FBQ0EsYUFBS0MsYUFBTCxHQUFxQkQseUJBQXVCLGNBQTVDO0FBQ0EsYUFBS0UsWUFBTCxHQUFvQkYseUJBQXVCLGFBQTNDO0FBQ0EsYUFBS0csWUFBTCxHQUFvQixLQUFLRCxZQUF6QjtBQUNIOztBQUdEOzs7Ozs7Ozs7Ozt1Q0FPZUUsVSxFQUFXO0FBQ3hCLGdCQUFJQyxtQkFBbUIsS0FBS04sV0FBTCxHQUFpQixFQUFqQixHQUFvQkssVUFBcEIsR0FBK0IsTUFBdEQ7QUFDQSxpQkFBS0QsWUFBTCxHQUFvQkcsMEJBQU1DLFVBQU4sQ0FBaUJGLGdCQUFqQixJQUFzQ0EsZ0JBQXRDLEdBQXlELEtBQUtILFlBQWxGO0FBQ0Q7O0FBR0Q7Ozs7OztxQ0FHYTtBQUNULGdCQUFJLENBQUMsS0FBS1AsY0FBVixFQUEwQjtBQUN0QixxQkFBS2EsVUFBTDtBQUNIO0FBQ0o7OztxQ0FFWTtBQUNULGdCQUFHLE9BQU9DLE1BQVAsSUFBa0IsV0FBbEIsSUFBa0MsT0FBT0EsT0FBT0MsSUFBZCxJQUF1QixXQUE1RCxFQUF3RTtBQUNwRUosMENBQU1LLG9CQUFOLENBQTJCLGlEQUFpRCxLQUFLakIsR0FBdEQsR0FBNEQsOEJBQXZGO0FBQ0g7QUFDRCxpQkFBS0MsY0FBTCxHQUFzQixJQUF0QjtBQUNIOztBQUVEOzs7Ozs7O2tDQUlVO0FBQ05pQixvQkFBUUMsR0FBUixDQUFZLHNDQUFzQ0MsT0FBTyx5QkFBUCxFQUFrQ0MsS0FBbEMsRUFBdEMsR0FBa0YsR0FBbEYsR0FBc0ZELE9BQU8seUJBQVAsRUFBa0NFLE1BQWxDLEVBQWxHLEVBQThJRixPQUFPLHlCQUFQLEVBQWtDRyxHQUFsQyxDQUFzQyxDQUF0QyxDQUE5STtBQUNBLGlCQUFLcEIsR0FBTCxHQUFXLElBQUlZLE9BQU9DLElBQVAsQ0FBWVEsR0FBaEIsQ0FBb0JKLE9BQU8seUJBQVAsRUFBa0NHLEdBQWxDLENBQXNDLENBQXRDLENBQXBCLEVBQThEO0FBQ3JFRSx3QkFBUSxFQUFFQyxLQUFLLENBQUMsTUFBUixFQUFnQkMsS0FBSyxPQUFyQixFQUQ2RDtBQUVyRUMsc0JBQU0sRUFGK0Q7QUFHckVDLGdDQUFnQjtBQUhxRCxhQUE5RCxDQUFYO0FBS0g7O0FBRUQ7Ozs7OztrQ0FHVUgsRyxFQUFLQyxHLEVBQUs7QUFDaEIsaUJBQUt4QixHQUFMLENBQVMyQixTQUFULENBQW1CLElBQUlmLE9BQU9DLElBQVAsQ0FBWWUsTUFBaEIsQ0FBdUJMLEdBQXZCLEVBQTRCQyxHQUE1QixDQUFuQjtBQUNIOztBQUVEOzs7Ozs7OztpREFLeUJLLE8sRUFBUTtBQUMvQixnQkFBRyxPQUFPQSxRQUFRQyxrQkFBZixJQUFzQyxXQUF6QyxFQUFxRDtBQUNuRCx1QkFBTyxFQUFQO0FBQ0Q7O0FBRUQsZ0JBQUlDLGFBQWFGLFFBQVFDLGtCQUF6QjtBQUNBLGlCQUFLLElBQUlFLElBQUUsQ0FBWCxFQUFjQSxJQUFJRCxXQUFXRSxNQUE3QixFQUFxQyxFQUFFRCxDQUF2QyxFQUEwQztBQUN4QyxvQkFBSUUsUUFBUUgsV0FBV0MsQ0FBWCxFQUFjRSxLQUExQjs7QUFFQSxxQkFBSSxJQUFJQyxJQUFFLENBQVYsRUFBYUEsSUFBSUQsTUFBTUQsTUFBdkIsRUFBK0IsRUFBRUUsQ0FBakMsRUFBb0M7QUFDbEMsd0JBQUlELE1BQU1DLENBQU4sS0FBWSxTQUFoQixFQUEyQjtBQUN6QiwrQkFBT0osV0FBV0MsQ0FBWCxFQUFjSSxVQUFyQjtBQUNEO0FBQ0Y7QUFFRjtBQUNGOztBQUVEOzs7Ozs7OztnQ0FLUUMsWSxFQUFlQyxVLEVBQVk7QUFBQTs7QUFDakMsZ0JBQUcsT0FBTzFCLE1BQVAsSUFBa0IsV0FBckIsRUFBaUM7QUFBRTtBQUNqQzJCLDJCQUFXLFlBQUk7QUFBQywwQkFBS1YsT0FBTCxDQUFhUSxZQUFiLEVBQTJCQyxVQUEzQjtBQUF5QyxpQkFBekQsRUFBMkQsR0FBM0Q7QUFDQTtBQUNEOztBQUVDLGdCQUFJRSxXQUFXLElBQUk1QixPQUFPQyxJQUFQLENBQVk0QixRQUFoQixFQUFmO0FBQ0EsZ0JBQUlDLEtBQU0sSUFBVjs7QUFFQSxnQkFBSUMsVUFBVU4sYUFBYU8sT0FBYixDQUFxQkMsV0FBckIsR0FBbUMsR0FBbkMsR0FBeUNSLGFBQWFPLE9BQWIsQ0FBcUJFLFdBQTlELEdBQTRFLEdBQTVFLEdBQWtGVCxhQUFhTyxPQUFiLENBQXFCRyxVQUF2RyxHQUFvSCxHQUFwSCxHQUEwSFYsYUFBYU8sT0FBYixDQUFxQkksSUFBL0ksR0FBc0osR0FBdEosR0FBNEpYLGFBQWFPLE9BQWIsQ0FBcUJLLEtBQWpMLEdBQXlMLEdBQXpMLEdBQStMWixhQUFhTyxPQUFiLENBQXFCTSxPQUFsTztBQUNBbkMsb0JBQVFDLEdBQVIsQ0FBWSxlQUFlMkIsT0FBM0I7O0FBRUFILHFCQUFTWCxPQUFULENBQWlCLEVBQUUsV0FBV2MsT0FBYixFQUFqQixFQUF5QyxVQUFTUSxPQUFULEVBQWtCQyxNQUFsQixFQUEwQjtBQUMvRCxvQkFBSXZCLFVBQVUsRUFBQ3dCLE1BQUssRUFBTixFQUFVOUIsS0FBSSxFQUFkLEVBQWtCQyxLQUFJLEVBQXRCLEVBQWQ7O0FBRUEsb0JBQUk0QixVQUFVLElBQWQsRUFBb0I7QUFDaEJ2Qiw4QkFBVXNCLFFBQVEsQ0FBUixDQUFWO0FBQ0gsaUJBRkQsTUFHSztBQUNEcEMsNEJBQVFDLEdBQVIsQ0FBWSwwREFBMERvQyxNQUF0RTtBQUNBZCwrQkFBV1QsT0FBWDtBQUNBO0FBQ0g7O0FBRUQsb0JBQUl5QixTQUFTekIsUUFBUTBCLFFBQVIsQ0FBaUJDLFFBQTlCOztBQUVBM0Isd0JBQVF3QixJQUFSLEdBQWVYLEdBQUdlLHdCQUFILENBQTRCNUIsT0FBNUIsQ0FBZjtBQUNBQSx3QkFBUU4sR0FBUixHQUFjK0IsT0FBTy9CLEdBQVAsRUFBZDtBQUNBTSx3QkFBUUwsR0FBUixHQUFjOEIsT0FBTzlCLEdBQVAsRUFBZDs7QUFFQWMsMkJBQVdULE9BQVg7QUFDSCxhQW5CRDtBQW9CSDs7O3VDQUVjO0FBQ1gsZ0JBQUksS0FBSzlCLE9BQUwsQ0FBYWtDLE1BQWIsR0FBc0IsQ0FBMUIsRUFBNkI7QUFDekIscUJBQUssSUFBSUQsSUFBSSxDQUFiLEVBQWdCQSxJQUFJLEtBQUtqQyxPQUFMLENBQWFrQyxNQUFqQyxFQUF5QyxFQUFFRCxDQUEzQyxFQUE4QztBQUMxQyx5QkFBS2pDLE9BQUwsQ0FBYWlDLENBQWIsRUFBZ0IwQixNQUFoQixDQUF1QixJQUF2QjtBQUNIOztBQUVELHFCQUFLM0QsT0FBTCxHQUFlLEVBQWY7QUFDSDtBQUNKOztBQUVEOzs7Ozs7OzttQ0FLV0UsWSxFQUFjMEQsUSxFQUFVO0FBQUE7O0FBQy9CLGlCQUFLMUQsWUFBTCxHQUFvQkEsWUFBcEI7O0FBRCtCLHVDQUd0QjJELENBSHNCO0FBSTNCLHVCQUFLN0QsT0FBTCxDQUFhNkQsQ0FBYixJQUFrQixPQUFLQyxTQUFMLENBQWU1RCxhQUFhMkQsQ0FBYixDQUFmLENBQWxCO0FBQ0E7QUFDQTNELDZCQUFhMkQsQ0FBYixFQUFnQkUsTUFBaEIsR0FBeUIsT0FBSy9ELE9BQUwsQ0FBYTZELENBQWIsQ0FBekI7O0FBRUEsdUJBQUs3RCxPQUFMLENBQWE2RCxDQUFiLEVBQWdCRyxXQUFoQixDQUE0QixPQUE1QixFQUFxQyxZQUFNO0FBQ3pDLHdCQUFHLE9BQU9KLFFBQVAsSUFBbUIsV0FBdEIsRUFBa0M7QUFDaENBLGlDQUFTQyxDQUFUO0FBQ0Q7QUFDRixpQkFKRDtBQVIyQjs7QUFHL0IsaUJBQUssSUFBSUEsSUFBSSxDQUFiLEVBQWdCQSxJQUFJM0QsYUFBYWdDLE1BQWpDLEVBQXlDLEVBQUUyQixDQUEzQyxFQUE4QztBQUFBLHNCQUFyQ0EsQ0FBcUM7QUFVN0M7O0FBRUQsaUJBQUtJLFNBQUw7QUFDSDs7QUFFRDs7Ozs7O2tDQUdVQyxXLEVBQWFOLFEsRUFBVTtBQUM3QixnQkFBSUcsU0FBUyxJQUFJbEQsT0FBT0MsSUFBUCxDQUFZcUQsTUFBaEIsQ0FBdUI7QUFDaENDLDBCQUFVLElBQUl2RCxPQUFPQyxJQUFQLENBQVllLE1BQWhCLENBQXVCcUMsWUFBWUcsR0FBbkMsRUFBd0NILFlBQVlJLElBQXBELENBRHNCO0FBRWhDckUscUJBQUssS0FBS0EsR0FGc0I7QUFHaENzRSxzQkFBTTtBQUNKQyx5QkFBTSxLQUFLakU7QUFEUDtBQUgwQixhQUF2QixDQUFiOztBQVNBLG1CQUFPd0QsTUFBUDtBQUNGOzs7b0NBRVU7QUFDVixnQkFBSVUsU0FBUyxJQUFJNUQsT0FBT0MsSUFBUCxDQUFZNEQsWUFBaEIsRUFBYjtBQUNBLGlCQUFLLElBQUliLElBQUksQ0FBYixFQUFnQkEsSUFBRyxLQUFLN0QsT0FBTCxDQUFha0MsTUFBaEMsRUFBd0MsRUFBRTJCLENBQTFDLEVBQTZDO0FBQzNDWSx1QkFBT0UsTUFBUCxDQUFjLEtBQUszRSxPQUFMLENBQWE2RCxDQUFiLEVBQWdCZSxXQUFoQixFQUFkO0FBQ0Q7QUFDRCxpQkFBSzNFLEdBQUwsQ0FBU2dFLFNBQVQsQ0FBbUJRLE1BQW5CO0FBQ0Q7O0FBRUQ7Ozs7Ozs7OzBDQUtrQkksRyxFQUFLO0FBQ25CLGlCQUFLLElBQUk1QyxJQUFJLENBQWIsRUFBZ0JBLElBQUksS0FBS2pDLE9BQUwsQ0FBYWtDLE1BQWpDLEVBQXlDLEVBQUVELENBQTNDLEVBQThDO0FBQzFDLHFCQUFLakMsT0FBTCxDQUFhaUMsQ0FBYixFQUFnQjZDLE9BQWhCLENBQ0VELE9BQU81QyxDQUFQLEdBRUEsS0FBSzVCLGFBRkwsR0FJQSxLQUFLRSxZQUxQO0FBT0g7QUFDSjs7Ozs7O2tCQTNNZ0JWLGUiLCJmaWxlIjoiNS5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBVdGlscyBmcm9tICcuL3NoaXB0aW1pemUtdXRpbHMuanMnOyAgXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNoaXB0aW1pemVHbWFwcyB7XG5cbiAgICBjb25zdHJ1Y3RvcihrZXkpIHtcbiAgICAgICAgdGhpcy5pc1NjcmlwdExvYWRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLm1hcmtlcnMgPSBbXTtcbiAgICAgICAgdGhpcy5tYXAgPSBudWxsO1xuICAgICAgICB0aGlzLnBpY2t1cFBvaW50cyA9IFtdO1xuICAgICAgICB0aGlzLmtleSA9IGtleTtcblxuICAgICAgICAvKiogXG4gICAgICAgICAqIHRoZSByb290IHVybCBmb3IgdGhlIGljb25zIGl0J3MgZGlmZmVyZW50IGZvciBldmVyeSBwbGF0Zm9ybSAgXG4gICAgICAgICAqIG1ha2Ugc3VyZSB0byBpbmNsdWRlIGEgdHJhaWxpbmcgLyBcbiAgICAgICAgICovIFxuICAgICAgICB0aGlzLmljb25fZm9sZGVyID0gc2hpcHRpbWl6ZV9pY29uX2ZvbGRlcjsgIFxuICAgICAgICB0aGlzLmljb25fc2VsZWN0ZWQgPSBzaGlwdGltaXplX2ljb25fZm9sZGVyKydzZWxlY3RlZC5wbmcnO1xuICAgICAgICB0aGlzLmljb25fZGVmYXVsdCA9IHNoaXB0aW1pemVfaWNvbl9mb2xkZXIrJ2RlZmF1bHQucG5nJztcbiAgICAgICAgdGhpcy5jdXJyZW50X2ljb24gPSB0aGlzLmljb25fZGVmYXVsdDsgXG4gICAgfVxuXG5cbiAgICAvKiogXG4gICAgICogQ2hlY2tzIGlmIHdlIGhhdmUgYW4gaWNvbiBmb3IgdGhpcyBjYXJyaWVyLlxuICAgICAqIElmIHllcyB0aGVuIGNoYW5nZSB0aGUgY2FycmllciBpY29uXG4gICAgICogSWYgbm90IHRoZW4gdXNlIHRoZSBkZWZhdWx0IGljb25cbiAgICAgKiBcbiAgICAgKiBAcGFyYW0gaW50IGNhcnJpZXJfaWQgLSB0aGUgY2FycmllciBpZCBcbiAgICAgKi8gXG4gICAgc2V0Q2Fycmllckljb24oY2Fycmllcl9pZCl7XG4gICAgICBsZXQgY2Fycmllcl9pY29uX3VybCA9IHRoaXMuaWNvbl9mb2xkZXIrJycrY2Fycmllcl9pZCsnLnBuZyc7IFxuICAgICAgdGhpcy5jdXJyZW50X2ljb24gPSBVdGlscy5pc1VybFZhbGlkKGNhcnJpZXJfaWNvbl91cmwpID8gIGNhcnJpZXJfaWNvbl91cmwgOiB0aGlzLmljb25fZGVmYXVsdDsgXG4gICAgfVxuXG5cbiAgICAvKiogXG4gICAgICogaWYgdGhlIHNjcmlwdCBoYXMgbm90IGJlZW4gbG9hZGVkICwgbG9hZCBpdCBcbiAgICAgKi9cbiAgICBncmFudFJlYWR5KCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNTY3JpcHRMb2FkZWQpIHtcbiAgICAgICAgICAgIHRoaXMubG9hZFNjcmlwdCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbG9hZFNjcmlwdCgpIHtcbiAgICAgICAgaWYodHlwZW9mKGdvb2dsZSkgPT0gJ3VuZGVmaW5lZCcgfHwgIHR5cGVvZihnb29nbGUubWFwcykgPT0gJ3VuZGVmaW5lZCcpe1xuICAgICAgICAgICAgVXRpbHMuaW5qZWN0RXh0ZXJuYWxTY3JpcHQoXCJodHRwczovL21hcHMuZ29vZ2xlYXBpcy5jb20vbWFwcy9hcGkvanM/a2V5PVwiICsgdGhpcy5rZXkgKyBcIiZjYWxsYmFjaz1zaGlwdGltaXplLmxvYWRNYXBcIik7ICAgIFxuICAgICAgICB9IFxuICAgICAgICB0aGlzLmlzU2NyaXB0TG9hZGVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKiogXG4gICAgICogTG9hZCB0aGUgbWFwIGludG8gdGhlIGVsZW1lbnQgXG4gICAgICogVGhpcyBmdW5jdGlvbiBuZWVkcyB0aGUgc2NyaXB0IHRvIGJlIGxvYWRlZCBcbiAgICAgKi9cbiAgICBsb2FkTWFwKCkgeyAgICAgICAgXG4gICAgICAgIGNvbnNvbGUubG9nKFwiZGlzcGxheWluZyBtYXAgb24gY29udGFpbmVyIHdpdGggXCIgKyBqUXVlcnkoXCIuc2hpcHRpbWl6ZS1waWNrdXBfX21hcFwiKS53aWR0aCgpICsgXCIgXCIralF1ZXJ5KFwiLnNoaXB0aW1pemUtcGlja3VwX19tYXBcIikuaGVpZ2h0KCkgLGpRdWVyeShcIi5zaGlwdGltaXplLXBpY2t1cF9fbWFwXCIpLmdldCgwKSk7IFxuICAgICAgICB0aGlzLm1hcCA9IG5ldyBnb29nbGUubWFwcy5NYXAoalF1ZXJ5KFwiLnNoaXB0aW1pemUtcGlja3VwX19tYXBcIikuZ2V0KDApLCB7XG4gICAgICAgICAgICBjZW50ZXI6IHsgbGF0OiAtMzQuMzk3LCBsbmc6IDE1MC42NDQgfSxcbiAgICAgICAgICAgIHpvb206IDE2LFxuICAgICAgICAgICAgbWFwVHlwZUNvbnRyb2w6IGZhbHNlLFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKiogXG4gICAgICogY2VudGVyIHRoZSBtYXAgXG4gICAgICovXG4gICAgY2VudGVyTWFwKGxhdCwgbG5nKSB7XG4gICAgICAgIHRoaXMubWFwLnNldENlbnRlcihuZXcgZ29vZ2xlLm1hcHMuTGF0TG5nKGxhdCwgbG5nKSk7XG4gICAgfVxuXG4gICAgLyoqIFxuICAgICAqIEV4dHJhY3QgdGhlIGNvdW50cnkgY29kZSBmcm9tIGEgZ2VvY29kZSByZXN1bHRcbiAgICAgKiBAcGFyYW0gZ2VvY29kZSAtIGEgZ29vZ2xlLm1hcHMuR2VvY29kZXIgcmVzdWx0IFxuICAgICAqIEByZXR1cm4gc3RyaW5nIGFscGhhLTIgY29kZSBmb3IgdGhlIGNvdW50cnkgbmFtZSBcbiAgICAgKi8gXG4gICAgZ2V0Q291bnRyeUNvZGVGcm9tUmVzdWx0KGdlb2NvZGUpe1xuICAgICAgaWYodHlwZW9mKGdlb2NvZGUuYWRkcmVzc19jb21wb25lbnRzKSA9PSBcInVuZGVmaW5lZFwiKXtcbiAgICAgICAgcmV0dXJuIFwiXCI7IFxuICAgICAgfVxuXG4gICAgICBsZXQgY29tcG9uZW50cyA9IGdlb2NvZGUuYWRkcmVzc19jb21wb25lbnRzO1xuICAgICAgZm9yKCBsZXQgaT0wOyBpIDwgY29tcG9uZW50cy5sZW5ndGg7ICsraSApe1xuICAgICAgICBsZXQgdHlwZXMgPSBjb21wb25lbnRzW2ldLnR5cGVzOyBcblxuICAgICAgICBmb3IobGV0IGo9MDsgaiA8IHR5cGVzLmxlbmd0aDsgKytqICl7XG4gICAgICAgICAgaWYoIHR5cGVzW2pdID09ICdjb3VudHJ5Jykge1xuICAgICAgICAgICAgcmV0dXJuIGNvbXBvbmVudHNbaV0uc2hvcnRfbmFtZTsgXG4gICAgICAgICAgfSBcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiAgXG4gICAgICogQHBhcmFtIHNoaXBwaW5nRGF0YSwgdGhlIGFkZHJlc3MgcGFydHMgICAgICAgXG4gICAgICogQHBhcmFtIGZfY2FsbGJhY2sgLCB0aGUgZnVuY3Rpb24gdG8gY2FsbCB3aGVuIGFsbCBtaWdodHkgZ29vZ2xlIHJldHVybnMgYSByZXN1bHQgXG4gICAgICovIFxuICAgIGdlb2NvZGUoc2hpcHBpbmdEYXRhLCAgZl9jYWxsYmFjaykgeyBcbiAgICAgIGlmKHR5cGVvZihnb29nbGUpID09ICd1bmRlZmluZWQnKXsgLy9zY3JpcHQgbm90IGxvYWRlZCB5ZXRcbiAgICAgICAgc2V0VGltZW91dCgoKT0+e3RoaXMuZ2VvY29kZShzaGlwcGluZ0RhdGEsIGZfY2FsbGJhY2spOyB9LCAyMDApOyBcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAgIGxldCBnZW9jb2RlciA9IG5ldyBnb29nbGUubWFwcy5HZW9jb2RlcigpO1xuICAgICAgICBsZXQgbWUgID0gdGhpczsgXG5cbiAgICAgICAgdmFyIGFkZHJlc3MgPSBzaGlwcGluZ0RhdGEuQWRkcmVzcy5TdHJlZXRuYW1lMSArIFwiIFwiICsgc2hpcHBpbmdEYXRhLkFkZHJlc3MuU3RyZWV0bmFtZTIgKyBcIiBcIiArIHNoaXBwaW5nRGF0YS5BZGRyZXNzLnBvc3RhbENvZGUgKyBcIiBcIiArIHNoaXBwaW5nRGF0YS5BZGRyZXNzLkNpdHkgKyBcIiBcIiArIHNoaXBwaW5nRGF0YS5BZGRyZXNzLlN0YXRlICsgXCIgXCIgKyBzaGlwcGluZ0RhdGEuQWRkcmVzcy5Db3VudHJ5O1xuICAgICAgICBjb25zb2xlLmxvZygnZ2VvY29kaW5nICcgKyBhZGRyZXNzKTtcblxuICAgICAgICBnZW9jb2Rlci5nZW9jb2RlKHsgJ2FkZHJlc3MnOiBhZGRyZXNzIH0sIGZ1bmN0aW9uKHJlc3VsdHMsIHN0YXR1cykge1xuICAgICAgICAgICAgbGV0IGdlb2NvZGUgPSB7aXNvMjonJywgbGF0OicnLCBsbmc6Jyd9O1xuXG4gICAgICAgICAgICBpZiAoc3RhdHVzID09ICdPSycpIHtcbiAgICAgICAgICAgICAgICBnZW9jb2RlID0gcmVzdWx0c1swXTtcbiAgICAgICAgICAgIH0gIFxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0dlb2NvZGUgd2FzIG5vdCBzdWNjZXNzZnVsIGZvciB0aGUgZm9sbG93aW5nIHJlYXNvbjogJyArIHN0YXR1cyk7XG4gICAgICAgICAgICAgICAgZl9jYWxsYmFjayhnZW9jb2RlKTtcbiAgICAgICAgICAgICAgICByZXR1cm47IFxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgbGF0bG5nID0gZ2VvY29kZS5nZW9tZXRyeS5sb2NhdGlvbjtcblxuICAgICAgICAgICAgZ2VvY29kZS5pc28yID0gbWUuZ2V0Q291bnRyeUNvZGVGcm9tUmVzdWx0KGdlb2NvZGUpO1xuICAgICAgICAgICAgZ2VvY29kZS5sYXQgPSBsYXRsbmcubGF0KCk7IFxuICAgICAgICAgICAgZ2VvY29kZS5sbmcgPSBsYXRsbmcubG5nKCk7IFxuXG4gICAgICAgICAgICBmX2NhbGxiYWNrKGdlb2NvZGUpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBjbGVhck1hcmtlcnMoKSB7XG4gICAgICAgIGlmICh0aGlzLm1hcmtlcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm1hcmtlcnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1hcmtlcnNbaV0uc2V0TWFwKG51bGwpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLm1hcmtlcnMgPSBbXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKiBcbiAgICAgKiBBZGQgdGhlIG1hcmtlcnMgdG8gbWFwIFxuICAgICAqIEBwYXJhbSBhcnJheSBwaWNrdXBQb2ludHMgLSBhbiBhcnJheSBvZiBwaWNrdXBQb2ludHNcbiAgICAgKiBAcGFyYW0gY2FsbGJhY2sgLSBhIGZ1bmN0aW9uIHRvIGNhbGwgd2hlbiB0aGUgbWFya2VyIGlzIGNsaWNrZWQgXG4gICAgICovXG4gICAgYWRkTWFya2VycyhwaWNrdXBQb2ludHMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMucGlja3VwUG9pbnRzID0gcGlja3VwUG9pbnRzO1xuXG4gICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgcGlja3VwUG9pbnRzLmxlbmd0aDsgKyt4KSB7XG4gICAgICAgICAgICB0aGlzLm1hcmtlcnNbeF0gPSB0aGlzLmdldE1hcmtlcihwaWNrdXBQb2ludHNbeF0pO1xuICAgICAgICAgICAgLy8gICAgd2UgbmVlZCB0byBkbyB0aGlzIGJlY2F1c2UgdGhlIHZhbHVlcyBmb3IgbGF0LGxuZyB3ZSBoYXZlIGFyZSByb3VuZGVkLCBzbyB0aGV5IHdpbGwgbm90IG1hdGNoIHRoZSBvbmVzIHJldHVybmVkIGJ5IGdvb2dsZVxuICAgICAgICAgICAgcGlja3VwUG9pbnRzW3hdLm1hcmtlciA9IHRoaXMubWFya2Vyc1t4XTtcblxuICAgICAgICAgICAgdGhpcy5tYXJrZXJzW3hdLmFkZExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbiAgICAgICAgICAgICAgaWYodHlwZW9mKGNhbGxiYWNrKSE9ICd1bmRlZmluZWQnKXtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayh4KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmZpdEJvdW5kcygpXG4gICAgfVxuXG4gICAgLyoqIFxuICAgICAqIFJldHVybiBhIG1hcmtlciBmb3IgdGhlIGdtYXBzIFxuICAgICAqL1xuICAgIGdldE1hcmtlcihwaWNrdXBQb2ludCwgY2FsbGJhY2spIHtcbiAgICAgICAgbGV0IG1hcmtlciA9IG5ldyBnb29nbGUubWFwcy5NYXJrZXIoe1xuICAgICAgICAgICAgcG9zaXRpb246IG5ldyBnb29nbGUubWFwcy5MYXRMbmcocGlja3VwUG9pbnQuTGF0LCBwaWNrdXBQb2ludC5Mb25nKSxcbiAgICAgICAgICAgIG1hcDogdGhpcy5tYXAsXG4gICAgICAgICAgICBpY29uOiB7XG4gICAgICAgICAgICAgIHVybDogIHRoaXMuY3VycmVudF9pY29uXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuIFxuXG4gICAgICAgIHJldHVybiBtYXJrZXI7XG4gICAgIH1cblxuICAgIGZpdEJvdW5kcygpIHtcbiAgICAgIHZhciBib3VuZHMgPSBuZXcgZ29vZ2xlLm1hcHMuTGF0TG5nQm91bmRzKCk7XG4gICAgICBmb3IoIGxldCB4ID0gMDsgeDwgdGhpcy5tYXJrZXJzLmxlbmd0aDsgKyt4ICl7XG4gICAgICAgIGJvdW5kcy5leHRlbmQodGhpcy5tYXJrZXJzW3hdLmdldFBvc2l0aW9uKCkpOyBcbiAgICAgIH0gXG4gICAgICB0aGlzLm1hcC5maXRCb3VuZHMoYm91bmRzKTtcbiAgICB9XG4gXG4gICAgLyoqXG4gICAgICogUmVzZXQgYWxsIG1hcmtlcnMgIFxuICAgICAqIFNlbGVjdCB0aGUgbWFya2VyIG9mIGluZGV4IGlkeCBpbiBtYXAgXG4gICAgICogQHBhcmFtIGludCBpZHggLSB0aGUgaW5kZXggdG8gc2VsZWN0IFxuICAgICAqL1xuICAgIHNlbGVjdE1hcmtlckJ5SWR4KGlkeCkgeyBcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm1hcmtlcnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHRoaXMubWFya2Vyc1tpXS5zZXRJY29uKFxuICAgICAgICAgICAgICBpZHggPT0gaSBcbiAgICAgICAgICAgICAgPyBcbiAgICAgICAgICAgICAgdGhpcy5pY29uX3NlbGVjdGVkXG4gICAgICAgICAgICAgIDpcbiAgICAgICAgICAgICAgdGhpcy5jdXJyZW50X2ljb25cbiAgICAgICAgICAgICk7ICBcbiAgICAgICAgfVxuICAgIH1cblxufSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///5\n")},function(module,exports,__webpack_require__){"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _shiptimizeUtils = __webpack_require__(0);\n\nvar _shiptimizeUtils2 = _interopRequireDefault(_shiptimizeUtils);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nvar ShiptimizeOpenMap = function () {\n    function ShiptimizeOpenMap() {\n        _classCallCheck(this, ShiptimizeOpenMap);\n\n        this.isScriptLoaded = false;\n        this.markers = [];\n        this.map = null;\n\n        /** \n         * the root url for the icons it\'s different for every platform  \n         * make sure to include a trailing / \n         */\n        this.icon_folder = shiptimize_icon_folder;\n    }\n\n    /** \n     *\n     * @param string imageUrl - full url to the icon \n     * @return L.icon object \n     */\n\n\n    _createClass(ShiptimizeOpenMap, [{\n        key: "createIcon",\n        value: function createIcon(imageUrl) {\n            return L.icon({\n                iconUrl: imageUrl,\n                iconSize: [50, 50], // size of the icon \n                iconAnchor: [25, 25], // point of the icon which will correspond to marker\'s location \n                popupAnchor: [-25, -50] // point from which the popup should open relative to the iconAnchor\n            });\n        }\n\n        /** \n         * @param decimal lat \n         * @param decimal lng \n         */\n\n    }, {\n        key: "centerMap",\n        value: function centerMap(lat, lng) {\n            this.map.invalidateSize();\n            var latlng = L.latLng(lat, lng);\n        }\n\n        /** \n         * if the script has not been loaded , load it. \n         * We use this function because we only want to load the script when the user clicks the button \n         */\n\n    }, {\n        key: "grantReady",\n        value: function grantReady() {\n            if (!this.isScriptLoaded) {\n                this.loadScript();\n            }\n        }\n\n        /**\n         *  \n         * @param shippingData, the address parts       \n         * @param f_callback , the function to call when all mighty google returns a result \n         */\n\n    }, {\n        key: "geocode",\n        value: function geocode(shippingData, f_callback) {\n            console.log(shippingData);\n            this.grantReady();\n\n            jQuery.getJSON("https://nominatim.openstreetmap.org/search?format=json&addressdetails=1" + "&city=" + shippingData.Address.City + "&country=" + shippingData.Address.Country, {}, function (response) {\n                var geocode = {\n                    \'iso2\': \'\',\n                    \'lat\': \'\',\n                    \'lng\': \'\'\n                };\n\n                if (response.length > 0) {\n                    var location = response[0];\n\n                    geocode.iso2 = location.address.country_code;\n\n                    geocode.lat = location.lat;\n                    geocode.lng = location.lon;\n                }\n                f_callback(geocode);\n\n                console.log(response);\n            });\n        }\n    }, {\n        key: "loadScript",\n        value: function loadScript() {\n            if (typeof L == \'undefined\') {\n                _shiptimizeUtils2.default.injectExternalScript(SHIPTIMIZE_LEAFLET_URL);\n            }\n\n            this.isScriptLoaded = true;\n            this.loadMap();\n            return;\n        }\n\n        /** \n         * Leaflet does not receive a callback so we wait here for the script to be loaded \n         */\n\n    }, {\n        key: "loadMap",\n        value: function loadMap() {\n            var _this = this;\n\n            if (typeof L == \'undefined\') {\n                setTimeout(function () {\n                    _this.loadMap();\n                }, 1500);\n                console.log("Map not loaded, settimeout ");\n                return;\n            }\n\n            this.icon_selected = this.createIcon(shiptimize_icon_folder + \'selected.png\');\n            this.icon_default = this.createIcon(shiptimize_icon_folder + \'default.png\');\n            this.current_icon = this.icon_default;\n\n            this.map = new L.map(jQuery(".shiptimize-pickup__map").get(0), {\n                "zoom": 16,\n                "center": [51.505, -0.09]\n            });\n\n            L.tileLayer(\'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png\', {\n                "attribution": \'&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors\'\n            }).addTo(this.map);\n        }\n    }, {\n        key: "clearMarkers",\n        value: function clearMarkers() {\n            if (this.markers.length > 0) {\n                for (var i = 0; i < this.markers.length; ++i) {\n                    this.map.removeLayer(this.markers[i]);\n                }\n            }\n            this.markers = [];\n        }\n\n        /** \n         * Add the markers to map \n         * @param array pickupPoints - an array of pickupPoints\n         */\n\n    }, {\n        key: "addMarkers",\n        value: function addMarkers(pickupPoints, callback) {\n            var _this2 = this;\n\n            this.pickupPoints = pickupPoints;\n\n            var _loop = function _loop(x) {\n                _this2.markers[x] = _this2.getMarker(pickupPoints[x]);\n                //    we need to do this because the values for lat,lng we have are rounded, so they will not match the ones returned by google\n                _this2.pickupPoints[x].marker = _this2.markers[x];\n\n                _this2.markers[x].on(\'click\', function () {\n                    if (typeof callback == \'function\') {\n                        callback(x);\n                    }\n                });\n            };\n\n            for (var x = 0; x < pickupPoints.length; ++x) {\n                _loop(x);\n            }\n\n            this.fitBounds();\n        }\n    }, {\n        key: "resetMarker",\n        value: function resetMarker(marker) {\n            marker.setIcon(this.icon_default);\n        }\n    }, {\n        key: "selectMarker",\n        value: function selectMarker(marker) {\n            marker.setIcon(this.icon_selected);\n        }\n\n        /** \n         * Adjust the zoom in the map to display all the markers \n         * There\'s a fit bounds that receives 2 corners, but calculating them is up to us. \n         * corners: top left, bottom right     \n         * then we center the map at the center of the square  \n         */\n\n    }, {\n        key: "fitBounds",\n        value: function fitBounds() {\n            var bottomLeft = [this.pickupPoints[0].Lat, this.pickupPoints[0].Long];\n            var topRight = [this.pickupPoints[0].Lat, this.pickupPoints[0].Long];\n\n            for (var i = 0; i < this.pickupPoints.length; ++i) {\n                var lat = this.pickupPoints[i].Lat;\n                var lng = this.pickupPoints[i].Long;\n\n                if (lat < bottomLeft[0]) {\n                    bottomLeft[0] = lat;\n                }\n\n                if (lat > topRight[0]) {\n                    topRight[0] = lat;\n                }\n\n                if (lng > topRight[1]) {\n                    topRight[1] = lng;\n                }\n\n                if (lng < bottomLeft[1]) {\n                    bottomLeft[1] = lng;\n                }\n            }\n\n            var centerX = bottomLeft[0] + (topRight[0] - bottomLeft[0]) / 2;\n            var centerY = bottomLeft[1] + (topRight[1] - bottomLeft[1]) / 2;\n\n            this.map.panTo([centerX, centerY]);\n\n            this.map.fitBounds([bottomLeft, topRight]);\n        }\n\n        /** \n         * Return a marker for the openLayers \n         * IconAnchor: The coordinates of the "tip" of the icon (relative to its top left corner). \n         * The icon will be aligned so that this point is at the marker\'s geographical location. \n         * Centered by default if size is specified, also can be set in CSS with negative margins.\n         */\n\n    }, {\n        key: "getMarker",\n        value: function getMarker(pickupPoint) {\n            var marker = L.marker([pickupPoint.Lat, pickupPoint.Long], {\n                "icon": this.current_icon,\n                "title": pickupPoint.Information.Name + "\\n" + pickupPoint.Information.Address\n            });\n            marker.addTo(this.map);\n            return marker;\n        }\n\n        /** \n         * Checks if we have an icon for this carrier.\n         * If yes then change the carrier icon\n         * If not then use the default icon\n         * \n         * @param int carrier_id - the carrier id \n         */\n\n    }, {\n        key: "setCarrierIcon",\n        value: function setCarrierIcon(carrier_id) {\n            var _this3 = this;\n\n            if (typeof L == \'undefined\') {\n                setTimeout(function () {\n                    _this3.setCarrierIcon(carrier_id);\n                }, 200);\n                return;\n            }\n            var carrier_icon_url = this.icon_folder + \'\' + carrier_id + \'.png\';\n            this.current_icon = _shiptimizeUtils2.default.isUrlValid(carrier_icon_url) ? this.createIcon(carrier_icon_url) : this.icon_default;\n        }\n\n        /**\n         * Reset all markers  \n         * Select the marker of index idx in map \n         * @param int idx - the index to select \n         */\n\n    }, {\n        key: "selectMarkerByIdx",\n        value: function selectMarkerByIdx(idx) {\n            for (var i = 0; i < this.markers.length; ++i) {\n                this.markers[i].setIcon(idx == i ? this.icon_selected : this.current_icon);\n            }\n        }\n    }]);\n\n    return ShiptimizeOpenMap;\n}();\n\nexports.default = ShiptimizeOpenMap;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9qcy9zaGlwdGltaXplLW9wZW4tbWFwLmpzPzg5YzEiXSwibmFtZXMiOlsiU2hpcHRpbWl6ZU9wZW5NYXAiLCJpc1NjcmlwdExvYWRlZCIsIm1hcmtlcnMiLCJtYXAiLCJpY29uX2ZvbGRlciIsInNoaXB0aW1pemVfaWNvbl9mb2xkZXIiLCJpbWFnZVVybCIsIkwiLCJpY29uIiwiaWNvblVybCIsImljb25TaXplIiwiaWNvbkFuY2hvciIsInBvcHVwQW5jaG9yIiwibGF0IiwibG5nIiwiaW52YWxpZGF0ZVNpemUiLCJsYXRsbmciLCJsYXRMbmciLCJsb2FkU2NyaXB0Iiwic2hpcHBpbmdEYXRhIiwiZl9jYWxsYmFjayIsImNvbnNvbGUiLCJsb2ciLCJncmFudFJlYWR5IiwialF1ZXJ5IiwiZ2V0SlNPTiIsIkFkZHJlc3MiLCJDaXR5IiwiQ291bnRyeSIsInJlc3BvbnNlIiwiZ2VvY29kZSIsImxlbmd0aCIsImxvY2F0aW9uIiwiaXNvMiIsImFkZHJlc3MiLCJjb3VudHJ5X2NvZGUiLCJsb24iLCJVdGlscyIsImluamVjdEV4dGVybmFsU2NyaXB0IiwiU0hJUFRJTUlaRV9MRUFGTEVUX1VSTCIsImxvYWRNYXAiLCJzZXRUaW1lb3V0IiwiaWNvbl9zZWxlY3RlZCIsImNyZWF0ZUljb24iLCJpY29uX2RlZmF1bHQiLCJjdXJyZW50X2ljb24iLCJnZXQiLCJ0aWxlTGF5ZXIiLCJhZGRUbyIsImkiLCJyZW1vdmVMYXllciIsInBpY2t1cFBvaW50cyIsImNhbGxiYWNrIiwieCIsImdldE1hcmtlciIsIm1hcmtlciIsIm9uIiwiZml0Qm91bmRzIiwic2V0SWNvbiIsImJvdHRvbUxlZnQiLCJMYXQiLCJMb25nIiwidG9wUmlnaHQiLCJjZW50ZXJYIiwiY2VudGVyWSIsInBhblRvIiwicGlja3VwUG9pbnQiLCJJbmZvcm1hdGlvbiIsIk5hbWUiLCJjYXJyaWVyX2lkIiwic2V0Q2Fycmllckljb24iLCJjYXJyaWVyX2ljb25fdXJsIiwiaXNVcmxW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QyxHQUF5RSxLQUFLM0IsWUFBbEc7QUFDSDs7QUFFRDs7Ozs7Ozs7MENBS2tCNkIsRyxFQUFLO0FBQ25CLGlCQUFLLElBQUl4QixJQUFJLENBQWIsRUFBZ0JBLElBQUksS0FBSy9DLE9BQUwsQ0FBYTZCLE1BQWpDLEVBQXlDLEVBQUVrQixDQUEzQyxFQUE4QztBQUMxQyxxQkFBSy9DLE9BQUwsQ0FBYStDLENBQWIsRUFBZ0JTLE9BQWhCLENBQ0llLE9BQU94QixDQUFQLEdBQ0EsS0FBS1AsYUFETCxHQUVBLEtBQUtHLFlBSFQ7QUFLSDtBQUNKOzs7Ozs7a0JBaFBnQjdDLGlCIiwiZmlsZSI6IjYuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgVXRpbHMgZnJvbSAnLi9zaGlwdGltaXplLXV0aWxzLmpzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2hpcHRpbWl6ZU9wZW5NYXAge1xuXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuaXNTY3JpcHRMb2FkZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5tYXJrZXJzID0gW107XG4gICAgICAgIHRoaXMubWFwID0gbnVsbDtcblxuICAgICAgICAvKiogXG4gICAgICAgICAqIHRoZSByb290IHVybCBmb3IgdGhlIGljb25zIGl0J3MgZGlmZmVyZW50IGZvciBldmVyeSBwbGF0Zm9ybSAgXG4gICAgICAgICAqIG1ha2Ugc3VyZSB0byBpbmNsdWRlIGEgdHJhaWxpbmcgLyBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaWNvbl9mb2xkZXIgPSBzaGlwdGltaXplX2ljb25fZm9sZGVyO1xuICAgIH1cblxuICAgIC8qKiBcbiAgICAgKlxuICAgICAqIEBwYXJhbSBzdHJpbmcgaW1hZ2VVcmwgLSBmdWxsIHVybCB0byB0aGUgaWNvbiBcbiAgICAgKiBAcmV0dXJuIEwuaWNvbiBvYmplY3QgXG4gICAgICovXG4gICAgY3JlYXRlSWNvbihpbWFnZVVybCkge1xuICAgICAgIHJldHVybiBMLmljb24oe1xuICAgICAgICAgICAgaWNvblVybDogaW1hZ2VVcmwsXG4gICAgICAgICAgICBpY29uU2l6ZTogWzUwLCA1MF0sIC8vIHNpemUgb2YgdGhlIGljb24gXG4gICAgICAgICAgICBpY29uQW5jaG9yOiBbMjUsIDI1XSwgLy8gcG9pbnQgb2YgdGhlIGljb24gd2hpY2ggd2lsbCBjb3JyZXNwb25kIHRvIG1hcmtlcidzIGxvY2F0aW9uIFxuICAgICAgICAgICAgcG9wdXBBbmNob3I6IFstMjUsIC01MF0gLy8gcG9pbnQgZnJvbSB3aGljaCB0aGUgcG9wdXAgc2hvdWxkIG9wZW4gcmVsYXRpdmUgdG8gdGhlIGljb25BbmNob3JcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqIFxuICAgICAqIEBwYXJhbSBkZWNpbWFsIGxhdCBcbiAgICAgKiBAcGFyYW0gZGVjaW1hbCBsbmcgXG4gICAgICovIFxuICAgIGNlbnRlck1hcChsYXQsIGxuZyl7XG4gICAgICAgIHRoaXMubWFwLmludmFsaWRhdGVTaXplKCk7XG4gICAgICAgIGxldCBsYXRsbmcgPSBMLmxhdExuZyhsYXQsIGxuZyk7ICBcbiAgICB9XG5cbiAgICAvKiogXG4gICAgICogaWYgdGhlIHNjcmlwdCBoYXMgbm90IGJlZW4gbG9hZGVkICwgbG9hZCBpdC4gXG4gICAgICogV2UgdXNlIHRoaXMgZnVuY3Rpb24gYmVjYXVzZSB3ZSBvbmx5IHdhbnQgdG8gbG9hZCB0aGUgc2NyaXB0IHdoZW4gdGhlIHVzZXIgY2xpY2tzIHRoZSBidXR0b24gXG4gICAgICovXG4gICAgZ3JhbnRSZWFkeSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzU2NyaXB0TG9hZGVkKSB7XG4gICAgICAgICAgICB0aGlzLmxvYWRTY3JpcHQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqICBcbiAgICAgKiBAcGFyYW0gc2hpcHBpbmdEYXRhLCB0aGUgYWRkcmVzcyBwYXJ0cyAgICAgICBcbiAgICAgKiBAcGFyYW0gZl9jYWxsYmFjayAsIHRoZSBmdW5jdGlvbiB0byBjYWxsIHdoZW4gYWxsIG1pZ2h0eSBnb29nbGUgcmV0dXJucyBhIHJlc3VsdCBcbiAgICAgKi9cbiAgICBnZW9jb2RlKHNoaXBwaW5nRGF0YSwgZl9jYWxsYmFjaykge1xuICAgICAgICBjb25zb2xlLmxvZyhzaGlwcGluZ0RhdGEpO1xuICAgICAgICB0aGlzLmdyYW50UmVhZHkoKTsgXG5cbiAgICAgICAgalF1ZXJ5LmdldEpTT04oXCJodHRwczovL25vbWluYXRpbS5vcGVuc3RyZWV0bWFwLm9yZy9zZWFyY2g/Zm9ybWF0PWpzb24mYWRkcmVzc2RldGFpbHM9MVwiICtcbiAgICAgICAgICAgIFwiJmNpdHk9XCIgKyBzaGlwcGluZ0RhdGEuQWRkcmVzcy5DaXR5ICtcbiAgICAgICAgICAgIFwiJmNvdW50cnk9XCIgKyBzaGlwcGluZ0RhdGEuQWRkcmVzcy5Db3VudHJ5LCB7fSwgKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IGdlb2NvZGUgPSB7XG4gICAgICAgICAgICAgICAgICAgICdpc28yJzogJycsXG4gICAgICAgICAgICAgICAgICAgICdsYXQnOiAnJyxcbiAgICAgICAgICAgICAgICAgICAgJ2xuZyc6ICcnXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBsb2NhdGlvbiA9IHJlc3BvbnNlWzBdO1xuXG4gICAgICAgICAgICAgICAgICAgIGdlb2NvZGUuaXNvMiA9IGxvY2F0aW9uLmFkZHJlc3MuY291bnRyeV9jb2RlO1xuXG4gICAgICAgICAgICAgICAgICAgIGdlb2NvZGUubGF0ID0gbG9jYXRpb24ubGF0O1xuICAgICAgICAgICAgICAgICAgICBnZW9jb2RlLmxuZyA9IGxvY2F0aW9uLmxvbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZl9jYWxsYmFjayhnZW9jb2RlKTtcblxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKHJlc3BvbnNlKTtcbiAgICAgICAgICAgIH0pO1xuICAgIH1cblxuICAgIGxvYWRTY3JpcHQoKSB7XG4gICAgICAgIGlmICh0eXBlb2YoTCkgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIFV0aWxzLmluamVjdEV4dGVybmFsU2NyaXB0KFNISVBUSU1JWkVfTEVBRkxFVF9VUkwpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5pc1NjcmlwdExvYWRlZCA9IHRydWU7XG4gICAgICAgIHRoaXMubG9hZE1hcCgpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLyoqIFxuICAgICAqIExlYWZsZXQgZG9lcyBub3QgcmVjZWl2ZSBhIGNhbGxiYWNrIHNvIHdlIHdhaXQgaGVyZSBmb3IgdGhlIHNjcmlwdCB0byBiZSBsb2FkZWQgXG4gICAgICovXG4gICAgbG9hZE1hcCgpIHtcbiAgICAgICAgaWYgKHR5cGVvZihMKSA9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7IHRoaXMubG9hZE1hcCgpOyB9LCAxNTAwKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiTWFwIG5vdCBsb2FkZWQsIHNldHRpbWVvdXQgXCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5pY29uX3NlbGVjdGVkID0gdGhpcy5jcmVhdGVJY29uKHNoaXB0aW1pemVfaWNvbl9mb2xkZXIgKyAnc2VsZWN0ZWQucG5nJyk7XG4gICAgICAgIHRoaXMuaWNvbl9kZWZhdWx0ID0gdGhpcy5jcmVhdGVJY29uKHNoaXB0aW1pemVfaWNvbl9mb2xkZXIgKyAnZGVmYXVsdC5wbmcnKTtcbiAgICAgICAgdGhpcy5jdXJyZW50X2ljb24gPSB0aGlzLmljb25fZGVmYXVsdDtcblxuICAgICAgICB0aGlzLm1hcCA9IG5ldyBMLm1hcChqUXVlcnkoXCIuc2hpcHRpbWl6ZS1waWNrdXBfX21hcFwiKS5nZXQoMCksIHtcbiAgICAgICAgICAgIFwiem9vbVwiOiAxNixcbiAgICAgICAgICAgIFwiY2VudGVyXCI6IFs1MS41MDUsIC0wLjA5XVxuICAgICAgICB9KTtcblxuICAgICAgICBMLnRpbGVMYXllcignaHR0cHM6Ly97c30udGlsZS5vcGVuc3RyZWV0bWFwLm9yZy97en0ve3h9L3t5fS5wbmcnLCB7XG4gICAgICAgICAgICBcImF0dHJpYnV0aW9uXCI6ICcmY29weTsgPGEgaHJlZj1cImh0dHBzOi8vd3d3Lm9wZW5zdHJlZXRtYXAub3JnL2NvcHlyaWdodFwiPk9wZW5TdHJlZXRNYXA8L2E+IGNvbnRyaWJ1dG9ycydcbiAgICAgICAgfSkuYWRkVG8odGhpcy5tYXApO1xuICAgIH1cblxuICAgIGNsZWFyTWFya2VycygpIHtcbiAgICAgICAgaWYgKHRoaXMubWFya2Vycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubWFya2Vycy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIHRoaXMubWFwLnJlbW92ZUxheWVyKHRoaXMubWFya2Vyc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tYXJrZXJzID0gW107XG4gICAgfVxuXG5cbiAgICAvKiogXG4gICAgICogQWRkIHRoZSBtYXJrZXJzIHRvIG1hcCBcbiAgICAgKiBAcGFyYW0gYXJyYXkgcGlja3VwUG9pbnRzIC0gYW4gYXJyYXkgb2YgcGlja3VwUG9pbnRzXG4gICAgICovXG4gICAgYWRkTWFya2VycyhwaWNrdXBQb2ludHMsY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5waWNrdXBQb2ludHMgPSBwaWNrdXBQb2ludHM7IFxuXG4gICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgcGlja3VwUG9pbnRzLmxlbmd0aDsgKyt4KSB7XG4gICAgICAgICAgICB0aGlzLm1hcmtlcnNbeF0gPSB0aGlzLmdldE1hcmtlcihwaWNrdXBQb2ludHNbeF0pO1xuICAgICAgICAgICAgLy8gICAgd2UgbmVlZCB0byBkbyB0aGlzIGJlY2F1c2UgdGhlIHZhbHVlcyBmb3IgbGF0LGxuZyB3ZSBoYXZlIGFyZSByb3VuZGVkLCBzbyB0aGV5IHdpbGwgbm90IG1hdGNoIHRoZSBvbmVzIHJldHVybmVkIGJ5IGdvb2dsZVxuICAgICAgICAgICAgdGhpcy5waWNrdXBQb2ludHNbeF0ubWFya2VyID0gdGhpcy5tYXJrZXJzW3hdO1xuXG4gICAgICAgICAgICB0aGlzLm1hcmtlcnNbeF0ub24oJ2NsaWNrJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmKHR5cGVvZihjYWxsYmFjaykgPT0gJ2Z1bmN0aW9uJyl7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKHgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5maXRCb3VuZHMoKTtcbiAgICB9XG5cbiAgICByZXNldE1hcmtlcihtYXJrZXIpIHtcbiAgICAgICAgbWFya2VyLnNldEljb24odGhpcy5pY29uX2RlZmF1bHQpO1xuICAgIH1cblxuICAgIHNlbGVjdE1hcmtlcihtYXJrZXIpIHtcbiAgICAgICAgbWFya2VyLnNldEljb24odGhpcy5pY29uX3NlbGVjdGVkKTtcbiAgICB9XG5cbiAgICAvKiogXG4gICAgICogQWRqdXN0IHRoZSB6b29tIGluIHRoZSBtYXAgdG8gZGlzcGxheSBhbGwgdGhlIG1hcmtlcnMgXG4gICAgICogVGhlcmUncyBhIGZpdCBib3VuZHMgdGhhdCByZWNlaXZlcyAyIGNvcm5lcnMsIGJ1dCBjYWxjdWxhdGluZyB0aGVtIGlzIHVwIHRvIHVzLiBcbiAgICAgKiBjb3JuZXJzOiB0b3AgbGVmdCwgYm90dG9tIHJpZ2h0ICAgICBcbiAgICAgKiB0aGVuIHdlIGNlbnRlciB0aGUgbWFwIGF0IHRoZSBjZW50ZXIgb2YgdGhlIHNxdWFyZSAgXG4gICAgICovXG4gICAgZml0Qm91bmRzKCkge1xuICAgICAgICBsZXQgYm90dG9tTGVmdCA9IFt0aGlzLnBpY2t1cFBvaW50c1swXS5MYXQsIHRoaXMucGlja3VwUG9pbnRzWzBdLkxvbmddO1xuICAgICAgICBsZXQgdG9wUmlnaHQgPSBbdGhpcy5waWNrdXBQb2ludHNbMF0uTGF0LCB0aGlzLnBpY2t1cFBvaW50c1swXS5Mb25nXTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucGlja3VwUG9pbnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBsZXQgbGF0ID0gdGhpcy5waWNrdXBQb2ludHNbaV0uTGF0O1xuICAgICAgICAgICAgbGV0IGxuZyA9IHRoaXMucGlja3VwUG9pbnRzW2ldLkxvbmc7XG5cbiAgICAgICAgICAgIGlmIChsYXQgPCBib3R0b21MZWZ0WzBdKSB7XG4gICAgICAgICAgICAgICAgYm90dG9tTGVmdFswXSA9IGxhdDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGxhdCA+IHRvcFJpZ2h0WzBdKSB7XG4gICAgICAgICAgICAgICAgdG9wUmlnaHRbMF0gPSBsYXQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChsbmcgPiB0b3BSaWdodFsxXSkge1xuICAgICAgICAgICAgICAgIHRvcFJpZ2h0WzFdID0gbG5nO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobG5nIDwgYm90dG9tTGVmdFsxXSkge1xuICAgICAgICAgICAgICAgIGJvdHRvbUxlZnRbMV0gPSBsbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuXG4gICAgICAgIGxldCBjZW50ZXJYID0gYm90dG9tTGVmdFswXSArICh0b3BSaWdodFswXSAtIGJvdHRvbUxlZnRbMF0pIC8gMjtcbiAgICAgICAgbGV0IGNlbnRlclkgPSBib3R0b21MZWZ0WzFdICsgKHRvcFJpZ2h0WzFdIC0gYm90dG9tTGVmdFsxXSkgLyAyO1xuXG4gICAgICAgIHRoaXMubWFwLnBhblRvKFtjZW50ZXJYLCBjZW50ZXJZXSk7XG5cbiAgICAgICAgdGhpcy5tYXAuZml0Qm91bmRzKFtcbiAgICAgICAgICAgIGJvdHRvbUxlZnQsXG4gICAgICAgICAgICB0b3BSaWdodFxuICAgICAgICBdKTtcbiAgICB9XG5cbiAgICAvKiogXG4gICAgICogUmV0dXJuIGEgbWFya2VyIGZvciB0aGUgb3BlbkxheWVycyBcbiAgICAgKiBJY29uQW5jaG9yOiBUaGUgY29vcmRpbmF0ZXMgb2YgdGhlIFwidGlwXCIgb2YgdGhlIGljb24gKHJlbGF0aXZlIHRvIGl0cyB0b3AgbGVmdCBjb3JuZXIpLiBcbiAgICAgKiBUaGUgaWNvbiB3aWxsIGJlIGFsaWduZWQgc28gdGhhdCB0aGlzIHBvaW50IGlzIGF0IHRoZSBtYXJrZXIncyBnZW9ncmFwaGljYWwgbG9jYXRpb24uIFxuICAgICAqIENlbnRlcmVkIGJ5IGRlZmF1bHQgaWYgc2l6ZSBpcyBzcGVjaWZpZWQsIGFsc28gY2FuIGJlIHNldCBpbiBDU1Mgd2l0aCBuZWdhdGl2ZSBtYXJnaW5zLlxuICAgICAqL1xuICAgIGdldE1hcmtlcihwaWNrdXBQb2ludCkge1xuICAgICAgICBsZXQgbWFya2VyID0gTC5tYXJrZXIoW3BpY2t1cFBvaW50LkxhdCwgcGlja3VwUG9pbnQuTG9uZ10sIHtcbiAgICAgICAgICAgIFwiaWNvblwiOiB0aGlzLmN1cnJlbnRfaWNvbixcbiAgICAgICAgICAgIFwidGl0bGVcIjogcGlja3VwUG9pbnQuSW5mb3JtYXRpb24uTmFtZSArIFwiXFxuXCIgKyBwaWNrdXBQb2ludC5JbmZvcm1hdGlvbi5BZGRyZXNzXG4gICAgICAgIH0pO1xuICAgICAgICBtYXJrZXIuYWRkVG8odGhpcy5tYXApO1xuICAgICAgICByZXR1cm4gbWFya2VyO1xuICAgIH1cblxuICAgIC8qKiBcbiAgICAgKiBDaGVja3MgaWYgd2UgaGF2ZSBhbiBpY29uIGZvciB0aGlzIGNhcnJpZXIuXG4gICAgICogSWYgeWVzIHRoZW4gY2hhbmdlIHRoZSBjYXJyaWVyIGljb25cbiAgICAgKiBJZiBub3QgdGhlbiB1c2UgdGhlIGRlZmF1bHQgaWNvblxuICAgICAqIFxuICAgICAqIEBwYXJhbSBpbnQgY2Fycmllcl9pZCAtIHRoZSBjYXJyaWVyIGlkIFxuICAgICAqL1xuICAgIHNldENhcnJpZXJJY29uKGNhcnJpZXJfaWQpIHtcbiAgICAgICAgaWYgKHR5cGVvZihMKSA9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7IHRoaXMuc2V0Q2Fycmllckljb24oY2Fycmllcl9pZCk7IH0sIDIwMCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNhcnJpZXJfaWNvbl91cmwgPSB0aGlzLmljb25fZm9sZGVyICsgJycgKyBjYXJyaWVyX2lkICsgJy5wbmcnO1xuICAgICAgICB0aGlzLmN1cnJlbnRfaWNvbiA9IFV0aWxzLmlzVXJsVmFsaWQoY2Fycmllcl9pY29uX3VybCkgPyB0aGlzLmNyZWF0ZUljb24oY2Fycmllcl9pY29uX3VybCkgOiB0aGlzLmljb25fZGVmYXVsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXNldCBhbGwgbWFya2VycyAgXG4gICAgICogU2VsZWN0IHRoZSBtYXJrZXIgb2YgaW5kZXggaWR4IGluIG1hcCBcbiAgICAgKiBAcGFyYW0gaW50IGlkeCAtIHRoZSBpbmRleCB0byBzZWxlY3QgXG4gICAgICovXG4gICAgc2VsZWN0TWFya2VyQnlJZHgoaWR4KSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5tYXJrZXJzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB0aGlzLm1hcmtlcnNbaV0uc2V0SWNvbihcbiAgICAgICAgICAgICAgICBpZHggPT0gaSA/XG4gICAgICAgICAgICAgICAgdGhpcy5pY29uX3NlbGVjdGVkIDpcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRfaWNvblxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH1cbn0iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///6\n')}]);